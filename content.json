{"posts":[{"title":"[1강~2강] node.js 원리, 개념, 개발환경 구축","text":"1강 node.js 원리 및 개념 node.js 란 서버환경에서 작동하는 Javascript 웹 브라우저 밖에서 Javascript 를 사용하기 위한 움직임 Javascript의 단점인 속도를 개선, 대규모 네트워크 어플리케이션을 만들 수 있음 node.js와 기존 웹서버의 차이점은 네트워크 입출력 방식의 차이 기존 웹서버는 Thread 기반, 동기 방식으로 네트워크 입출력을 처리 node.js는 Event 기반, 비동기 방식으로 네트워크 입출력을 처리 Thread 기반: 처리해야하는 프로세스가 n개 있을 때, 이를 n개의 몸으로 나눠서 처리하는 방법(동기식) Event 기반: 처리해야하는 프로세스를 Event가 발생했을 때만 처리하는 방식(비동기식) 2강 node.js 개발 환경 구축 맥 OS 설치 node.js 다운로드 설치 terminal로 실행해보기 12345$ node&gt; console.log('hello world');hello world&gt; process.exit(1);$ ... console, process 와 같은 Javascript 개념은 다음 장에서 배울 예정","link":"/2018/01/03/2018-01-03-node-01/"},{"title":"k-최근접 이웃 알고리즘","text":"시작하며 안녕하세요, TaeBbong 입니다. 오늘은 기계학습 알고리즘의 기초 수업의 첫 단계인 k-최근접 이웃 알고리즘, 이하 kNN 알고리즘에 대해 공부해볼겁니다. 기계학습 알고리즘은 앞서 설명하였듯, 두 가지의 목적성으로 크게 나뉘어집니다. 첫 번째는 분류, 두 번째는 회귀이지요. 다시 이들은 지도 학습과 비지도 학습으로 나뉘어지는데, 이 부분은 intro: 기계학습 알고리즘의 이해 에서 자세히 살펴보시면 됩니다. 오늘 공부할 kNN 알고리즘은 이 중 지도 학습 - 분류 알고리즘에 해당합니다. 즉 input data에 대한 output 결과 data를 test set 으로 넣고 특정 데이터에 대한 결과를 예측하는 것이 목표이지요. 또한 추정하고자 하는 것은 해당 데이터가 어느 분류에 속하는지, 분류를 알고 싶을 때 사용하게 됩니다. 우선 오늘의 학습은 알고리즘 개념의 이해, 알고리즘 step 별 이해, 그리고 간단한 실습 프로젝트로 진행할 예정입니다. 프로젝트 목표 kNN 알고리즘의 원리와 개념, 필요성 및 용도를 알 수 있다. kNN 알고리즘을 활용한 분류기를 제작할 수 있다. 영화 분류기를 제작할 수 있다. k-최근접 이웃 알고리즘이란? 영화를 장르별로 분류한다고 생각합시다. 어떤 영화가 액션영화, 로맨스영화일까요?? 많이 간단하게 생각하면, 스킨십 장면이 많이 나오는 영화는 로맨스, 발차기나 격투 장면이 많이 나오면 액션 영화이지 않을까? 이와 같은 개념에서 만들어지는 알고리즘이 kNN 알고리즘입니다. 어떠한 기준 factor 에 대해 분류를 하게 되는 것이지요. 영화얘기는 생뚱 맞을 수 있으니 조금 더 이론적으로 접근합시다. kNN 알고리즘은 말 그대로 k개의 가장 근접한 이웃을 기반으로 분류하는 알고리즘입니다. 한 데이터를 기준으로 k개의 가장 근접한 이웃들의 다수가 A 분류, 소수가 B 분류라면 해당 데이터는 A 분류에 속하게 되는 것이지요. 즉, k개의 가장 근접한 이웃들이 해당 데이터의 분류를 결정하는, 즉 가까운 쪽에 속하게 되는 상당히 간단하고 쉬운 개념의 분류 알고리즘입니다. 여기서 의문점이 생길 수 있어요. 왜 가장 가까운 1개의 데이터에 따르지 않고 굳이 k개를 골라서 투표를 하는 번거로운 과정을 거칠까요? 이는 이상데이터, outlier 때문입니다. 데이터의 전체 경향을 볼 수 없는 상황에서 일반적이지 않은 예외스러운 데이터가 존재할 가능성이 다분하죠. 가장 가까운 1개의 데이터를 고를 경우 이러한 outlier에 대한 처리가 미흡할 수 있기 때문에 우리는 k개를 선택합니다. 이것이 k-NN의 기본적인 컨셉이죠. kNN 알고리즘의 프로세스 kNN 알고리즘의 프로세스는 다음과 같아요. 간단하게 정리해봅시다. 기존 훈련 데이터 집합(train data set)을 준비한다. 해당 훈련 데이터들에는 라벨(label)이 붙어 있다. 즉 각 데이터가 어떤 분류인지 정해져있다. 이후 라벨링이 되지 않은 새로운 데이터가 input 으로 들어온다. 해당 데이터를 기준으로 ‘거리’가 가장 가까운 ‘k’개의 데이터를 뽑아 그 데이터들의 분류를 확인한다. 이때 k개의 데이터들의 분류 중 가장 많은 쪽, 즉 다수결로 해당 데이터의 분류를 결정한다. 상당히 간단한 프로세스에요. 일반적인 기계학습 알고리즘이 갖는 훈련 집합을 기반으로 학습을 하고, 라벨링 과정을 거치지 않은 새로운 데이터의 라벨을 붙이는 과정. 이것이 해당 알고리즘의 전부이죠. 여기서 k는 임의의 정수 값으로, 알고리즘을 만드는 당신이 임의로 설정할 수 있어요!(일반적으로 20미만의 값) 가장 합리적인 k값을 찾는 것 또한 하나의 object 이겠네요. 또한 거리라는 개념을 썼는데, 거리는 여기서 유사도를 의미해요. 기계학습 알고리즘에서 유사도를 측정하는 방법에는 여러가지가 있고, 지금 우리가 공부하는 kNN 알고리즘은 거리를 기반으로 계산하게 됩니다. 이 거리를 어떻게 계산하는지는 추후에 알아봐봅시다:) kNN 프로젝트: 영화 분류기 만들기 여기서는 여태 이해한 알고리즘을 직접 간단한 예제와 함께 만들어볼거에요! 앗, 아직 우리는 거리를 계산하는 방식을 모르는군요! 하지만 거리를 계산하려면 데이터가 필요하겠죠? 그래서 지금 실제로 데이터를 가지고 다루어봅시다. 데이터 이해하기 및 거리 계산에 대한 감 익히기 우선 다음과 같은 영화별 액션 장면 수와 스킨십 장면 수가 있다고 해봅시다. title #action scene #romance scene type movie 1 3 104 로맨스 movie 2 2 100 로맨스 movie 3 1 81 로맨스 movie 4 101 10 액션 movie 5 99 5 액션 movie 6 98 2 액션 movie ? 18 90 ? 이때 거리는 다음과 같이 계산해요. 1d = sqrt((x1 - x2)^2 + (y1 - y2)^2) 일반적인 2차원 평면 상의 거리 계산 식과 같죠? 당연히 여기서 x와 y는 #action scene, #romance scene을 의미합니다:) 그렇게 ‘movie ?’을 기준으로 계산한 거리는 다음과 같아요. title distance from ? movie 1 20.5 movie 2 18.7 movie 3 19.2 movie 4 115.3 movie 5 117.4 movie 6 118.9 실제 코드 작성해보기 그럼 이제 실제 코드를 작성해볼까요! 우선 프로젝트를 생성하고, 두 개의 파이썬 파일을 만들거에요. 하나는 함수 라이브러리, 나머지 하나는 본체 코드이지요. kNN.py 123456789101112131415161718192021222324252627282930from numpy import *import operatordef createDataSet(): group = array([[3.0, 104.0], [2.0, 100.0], [1.0, 81.0], [101.0, 10.0], [99.0, 5.0], [98.0, 2.0]]) # [#action_scene, #romance_scene] labels = ['R', 'R', 'R', 'A', 'A', 'A'] # R: Romance, A: Action return group, labelsdef classify(inX, dataSet, labels, k): # classifier method(inX: data that we want to know, dataSet: trained dataset, labels: label of each trained data, k: number of neighbors we chose) dataSetSize = dataSet.shape[0] # total data train set's size diffMat = tile(inX, (dataSetSize, 1)) - dataSet # make matrix that is fully completed with inX, then calc difference sqDiffMat = diffMat ** 2 # mult each data in diffMat sqDistances = sqDiffMat.sum(axis = 1) # sum each data's mult results in diffMat distances = sqDistances ** 0.5 # sqrt sqDistances sortedDistIndices = distances.argsort() # sort sqDistances so low data comes to the top classCount = {} for i in range(k): # select k(3) nearest neighbors from to the top: (0, 1, 2) voteIlabel = labels[sortedDistIndices[i]] # find each neighbor's label classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 # count up neighbor's label count sortedClassCount = sorted(classCount.items(), key = operator.itemgetter(1), reverse = True) # sort all label counts in descending order return sortedClassCount[0][0] # return most voted label 좋아요! 이렇게 하면 훈련 데이터 셋을 정의, 만들어서 반환까지 하는 함수를 만든 것이죠. 분류기 함수가 정의되어있고, 알고 싶은 데이터와 기존 데이터 값, 그리고 몇 개의 이웃을 쓸지 설정합니다. 그리고 첫 블록의 코드들은 코드만 복잡하지 각 데이터 별 알고 싶은 데이터와의 거리 값을 계산하는 코드를 나눠 써놓은거에요. 반복문에 있는 건 그렇게 거리 순으로 정렬된 데이터에서 가장 위의 k개의 데이터들의 label 값들을 조사해서 이를 또 다시 dictionary에 저장하고, 이들을 또 다시 정렬, 가장 높은 표를 받은 label 값을 반환하는 것이죠. 프로그램을 실제로 실행하는 메인 부분입니다. main.py 12345import kNN# executing whole codes with sample data [18, 90]group, labels = kNN.createDataSet()print(kNN.classify([18, 90], group, labels, 3)) main.py를 실행시키면 다음과 같은 결과가 나와요! {:width=”500” height=”200”} 분류기 검사해보기 기계학습 알고리즘을 만들 때 가장 필요한 작업은 검증 작업입니다. 해당 분류기가 정말 잘 돌아가는지 확인하려면 어떻게 해야할까요? 우선은 자체적 안정성을 위해 훈련용 데이터가 많이 필요하겠죠. 또한 일부 데이터는 라벨이 없는 채로 들어가 본인의 실제 라벨과 분류기에서 판단한 라벨이 동일한지도 확인해야겠어요. 이 비율을 뭐 적당히 훈련 8: 테스트 2 로 정해봅시다. 이와 같이 전체 훈련용 데이터 집합에서 일부를 테스트 데이터로 따로 빼서 검증하고, 그러한 일부를 무작위로 수차례 뽑아서 테스트를 진행하는 것을 ‘교차 검증’ Cross Validation 이라고 합니다. 여기서는 이를 자세히 다루지는 않겠지만, 조만간 포스트에서 이를 코드로까지 구현해볼거에요. 대신 우리는 그럼 간단하게 수차례 뽑지 않고 한 번만 뽑아서 테스트를 해볼게요. 다시 코드를 작성해볼까요? kNN.py 123456789101112131415def validTest(): hoRatio = 0.2 dataSet, labels = createDataSet() # set data m = dataSet.shape[0] # set empty matrix with dataSet numTestVecs = int(m * hoRatio) # number of test data errorCount = 0.0 # error count for i in range(numTestVecs): # select numTestVecs from dataSet to testSet classifierResults = classify(dataSet[i, :], dataSet[numTestVecs:m, :], labels[numTestVecs:m], 3) # test with testSet and trainSet print('classifier:', str(classifierResults), 'real:', str(labels[i])) # print results if classifierResults is not labels[i]: # count up errorCount += 1.0 print('error rate:', str(errorCount / float(numTestVecs))) # print error rate main.py 1kNN.validTest() 결과는 어떻게 나왔나요? {:width=”500” height=”100”} 현재 데이터셋이 6개 밖에 없어 0.2 비율로 하면 1개 뿐이라 결과가 잘 나온 것처럼 보이네요. 이처럼 검증 과정을 거치기 위해선 데이터가 꽤 필요하답니다:) 번외: scikit-learn을 써보자. 우리는 여태 꽤 많은 코드를 작성했어요. 거리계산부터 정렬, 선별, 투표, 결정 그리고 마지막 검증까지. 이러한 kNN 알고리즘은 이 모델이 대부분이에요. 즉 분류기는 변하지 않는다는 말이죠. 그렇다면 이 코드를 매번 작성 해야할까요? 다행스럽게도, 이와 같은 알고리즘들을 라이브러리 형태로 만들어놓은 오픈 소스가 있습니다. 바로 scikit-learn이지요! scikit-learn에는 오늘 배운 kNN 알고리즘 뿐만 아니라 여러 앞으로 배울 기계학습 알고리즘들이 존재합니다. 오늘 그러면 간단하게 이를 사용해보도록 해요:) 코드가 대폭 줄어드는 경험을 할 것입니다. 일단 scikit-learn을 사용하려면 설치를 해야해요. 터미널을 켜봅시다. 1sudo pip install scikit-learn 간단하게 설치를 마쳐주고, 코드를 작성해봅시다:) 12345678910from sklearn.neighbors import KNeighborsClassifier # import kNN from scikit learngroup = [[3.0, 104.0], [2.0, 100.0], [1.0, 81.0], [101.0, 10.0], [99.0, 5.0], [98.0, 2.0]] # [#action_scene, #romance_scene]labels = ['R', 'R', 'R', 'A', 'A', 'A'] # R: Romance, A: Actionneigh = KNeighborsClassifier(n_neighbors = 3) # define modelneigh.fit(group, labels) # do it!print(neigh.predict([[18.0, 200.0]])) # print resultprint(neigh.predict_proba([[40.0, 70.0]])) # print result's vote report 결과는 다음과 같아요. {:width=”500” height=”100”} 정말 억울할 정도로 간단하죠? 이처럼 scikit-learn을 활용하면 코드를 훨씬 쉽게 쓸 수 있어요! 공부하는 차원에서는 일단 많이 쓰지는 않을게요:) 마치며 오늘 살펴본 알고리즘, 어렵지 않았죠? 분류기 예제 문제 자체가 상당히 간단하지만, 이게 다에요:) (사실 NN regression, unsupervised NN, kDTree처럼 아직 못한게 많지만) 여기에 데이터를 형태에 따라 수치형으로 가공하고, 정규화를 시키고 하는 데이터 처리 기법만 다를 뿐 기본 베이스 알고리즘은 똑같답니다. 물론 이제 새로 테스트 해본 데이터를 훈련 데이터 집합에 추가하여 점점 똑똑해지는 방식을 취할 수 있지만 이는 굳이 여기서 다루진 않을게요.(append만 하면 되니..) 여기까지 k-NN 알고리즘이었습니다:) 기계학습의 기초 포스팅은 다음 도서를 교재로 사용하고,{:width=”50” height=”100”} 다음 API Document를 참고합니다. scikit-learn","link":"/2018/01/02/2018-01-02-kNN-post/"},{"title":"GitHub 블로그 만들기 &amp; Jekyll로 꾸미기","text":"시작하며 안녕하세요, TaeBbong 입니다. 오늘은 지금 보고 있는 이 블로그를 만들어볼거에요. 블로그를 만드는 것은 예전부터 개발자의 간지로 간직하고 있었어요:) 이왕 만드는 거 네이버 블로그와 같이 귀찮고 조잡한(?!) 블로그 형태가 아닌 깔끔한 블로그를 원했죠. 그래서 깃헙 블로그를 열심히 알아보다가 2018년이 시작되어서야 제대로 시간을 써서 완성하게 되었네요. 깃헙 블로그를 배포하는 것 뿐 아니라 테마를 적용하고 커스터마이징 하는 것까지 기록하려 합니다:) 프로젝트 목표 GitHub 제공 블로그 및 페이지 만들기 Jekyll 테마를 사용하여 블로그 꾸미기 블로그 배포하기 1단계: GitHub Repository 만들기 우선 깃헙 블로그를 만드려면 당연히 깃헙 계정이 있어야겠죠? 본인 깃헙 계정에서 새로운 저장소 Repository 를 만들어 봅시다. 이때 규칙이 존재하는데, 본인계정이름.github.io 의 형태로 저장소의 이름을 설정해봅시다. 계정이름과 동일하지 않을 경우 제대로 실행이 되지 않는다고 깃헙에서 경고를 하거든요:) 이렇게 저장소를 만들면 1단계는 마무리가 됩니다. 2단계: Theme 선택, 다운로드 다음은 블로그를 꾸밀 테마를 선택하는 영역입니다! 우리가 정말 뛰어난 개발자라면 모든 html, css, 구성 파일들을 직접 만들 수도 있겠죠. 하지만 그러기에는 디자인도 해야하고 너무 귀찮은 일이 많으니 있는 테마를 가져와서 응용하는게 낫겠죠? 다음 링크에서 원하는 테마를 선택해서 다운로드 합니다! jekyllthemes.org 다운로드 받고 압축을 풀면 여러 파일들이 나올텐데, 이에 대해서는 추후 커스터마이징을 하며 알아보기로 합시다. 일단은 추후 작업을 위해 터미널을 열고 ‘본인의’ 해당 디렉토리로 이동합시다. 1$ cd /Desktop/myblog 3단계: Jekyll, Bundler 설치(MAC OS) 다음은 테마를 사용하기 위한 몇 가지 라이브러리를 설치해야합니다. 깃헙 블로그 테마를 꾸미기 위한 라이브러리에는 몇 가지가 존재하는데, 우리는 그 중에서 Jekyll(지킬)을 사용할 겁니다. 위에서 다운 받은 테마도 Jekyll 로 만든 것입니다. Jekyll은 Ruby 언어를 베이스로 한 것인데, Mac에는 Ruby가 기본으로 설치되어있습니다. 하지만 대체로 Jekyll 설치를 할 때 버전이 맞지 않는다고 에러가 뜰 것입니다. 터미널을 통해 새로운 버전으로 업데이트를 해봅시다. Mac OS 기준으로 터미널을 열어 다음과 같이 입력합니다. 12$ export PATH=/usr/local/bin:$PATH$ brew link --overwrite ruby 업데이트가 되었으니 이제 본격적으로 Jekyll과 Bunlder를 설치해봅시다. 역시 터미널에서 다음과 같이 입력합시다. 1$ sudo gem install jekyll bundler''' 설치가 끝났습니다! 고생하셨어요 잠시 쉬었다 올까요? 참고) 해당 디렉토리 내에 ‘_config.yml’ 파일에 보면 gems: 영역에 써져있는 라이브러리들이 몇 개 더 있을거에요. 그 친구들도 비슷하게 설치해주면 됩니다:) 4단계: 로컬 서버에서 블로그 실행시켜보기 어서 블로그의 모습을 보고싶군요! 블로그를 당장 배포하지 않고 로컬에서 실행시켜봅시다. 터미널에서 다음과 같이 실행시켜봅시다. 1$ bundle exec jekyll serve https://127.0.0.1:4000 로 이동해서 확인해보면, 블로그가 나와있군요!! 거의 다 오셨습니다:) 5단계: 테마 블로그 커스터마이징 하기 이제 본격적으로 테마 블로그를 ‘내’ 블로그로 만들어 봅니다. 각 파일들에 대해 간단히 알아봐봅시다. _config.yml 파일에 대한 전반적인 설정이 들어가 있어요. 여기서 title, description, email, logo 등 딱 보아도 아 이 부분은 내 정보를 쓰는 거구나 싶은 부분들을 수정하면 됩니다. _posts folder 이 폴더에는 모든 포스트들이 저장될거에요. .md 파일들을 기억합시다:) index.html 말그대로 블로그의 얼굴, 표지를 의미하죠. 테마를 사용하게되면 이 부분은 크게 고칠 필요는 없는데, 가끔 이 곳에도 내 정보를 써야하는 부분들이 있어 그 부분만 수정하시면 돼요. 6단계: 블로그를 GitHub으로 배포하기 자 우선 로컬 깃 Repository를 설정합시다. 1$ git init 그러고 이제 폴더 전체를 add 해야겠죠. 1$ git add --all 커밋, 푸쉬를 해줍니다. 123$ git commit -m &quot;Init blog!&quot;$ git remote add origin https://github.com/본인깃계정/본인깃계정.github.io.git$ git push origin master remote를 초기화할 땐 다음 코드를 사용합니다. 1$ git remote remove --all 이제 ‘본인깃계정.github.io’ 에 접속해보세요! 시간이 조금 걸릴지도 모릅니다:) 7단계: 블로그 포스팅하기 블로그 포스팅은 생각보다 심플해요 지금도 하고 있죠:) 아까 봤던 블로그 테마 폴더 디렉토리에 가보면 _posts 폴더가 있을거에요. 그 폴더에 들어가면 샘플 파일들이 존재합니다. 파일 확장자는 .md 일텐데, 이는 Markdown(마크다운)이라고 하며 텍스트 에디팅을 하는 하나의 문법 정도로 생각하시면 될거 같아요. 아주 간단한 문법만으로 지금 보시는 글 처럼 예쁜 디자인을 얻을 수 있답니다. 마크다운 문법에 대해서는 여기서 깊게 다루지 않고, 블로그를 포스팅하는데 필요한 규칙만 말씀드리자면, 일단 따라해봅시다. 샘플 md 파일을 하나 복사해봐요. 이름을 수정합시다. 이때 이름 규칙은 ‘yyyy-mm-dd-post-name’입니다! 그 후 파일을 열어보면 초반 ‘— —‘ 사이에 여러가지가 리스트업 되어있을겁니다. 이들이 해당 파일의 설정과 같은 존재인데 여기서 title, date, excerpt, tag 를 마음껏 고치시면 됩니다. 그러고 아까 열어두었던 터미널을 사용해 또 1) add –all, 2) commit -m, 3) push 를 시전합시다. 중간에 1$ git status 를 입력하면 어떤 파일들이 변화되어 지금 업데이트가 되는지를 확인할 수 있어요. 이제 블로그를 새로고침하면서 새로 게시된 글을 확인합니다!! 역시 시간이 조금 걸릴 수 있어요:) 마치며 깃헙 블로그를 완성시켰군요! 처음 이런 블로그를 볼 때 참 멋있다고 생각했는데, 그래서인지 블로그를 하나 만든 것만으로도 참 뿌듯하네요:) 이렇게 만든 블로그는 앞으로 개발을 할 때 좋은 동기부여가 될 것입니다.","link":"/2018/01/01/2018-01-01-jekyll-git-post/"},{"title":"[3강~5강] node.js 전역 객체, 기본 모듈, 이벤트","text":"3강 node.js 전역 객체 node.js에는 최상위 객체로 window 객체가 아닌 다른 전역 객체들을 가지고 있음(윈도우 어플리케이션 상에서 돌아가지 않으므로) 전역 객체는 말그대로 프로그램 전역에서 사용할 수 있는 객체를 의미함 이와 함께 전역 변수도 존재함 전역 변수 __filename 해당 파일의 경로 + 파일 이름을 저장 __dirname 해당 파일의 경로를 저장 사용법 node.basic.js12console.log(&quot;filename: &quot;, __filename);console.log(&quot;dirname: &quot;, __dirname); result123$ node node.basic.js&gt; /usr/bin/node_ex/node.basic.js&gt; /usr/bin/node_ex 전역 객체 console node.js console 화면을 다루는 객체 관련 메소드에는 log(), time(), timeEnd() 가 있음 log(): 출력 함수, 문법은 C 언어와 동일 time(): 시간 측정 시작 timeEnd(): 시간 측정 종료 사용 예제 node.basic.js12345console.time(&quot;alpha&quot;);console.log(&quot;%d + %d = %d&quot;, 67, 123, 190);console.log(&quot;hihi&quot;);console.log(&quot;My JSON: %j&quot;, { name: &quot;David&quot; });console.timeEnd(&quot;alpha&quot;); result12345$ node node.basic.js&gt; 67 + 123 = 190&gt; hihi&gt; { 'name': 'David' }&gt; alpha: 2.7ms (depends on your PC) process 프로그램의 정보를 나타내는 객체, nodejs만이 가진 특징 객체의 각 속성들과 메소드들은 다음과 같음 argv: 실행 매개변수를 나타냄 env: 컴퓨터 환경 정보를 나타냄 version: nodejs 버젼을 나타냄 versions: nodejs에 종속된 프로그램의 버젼을 나타냄 arch: 프로세서의 아키텍쳐를 나타냄 platform: 플랫폼을 나타냄 exit(0): 프로그램을 종료시키는 메소드 memoryUsage(): 메모리 사용 정보 객체를 리턴하는 메소드 uptime(): 현 프로그램이 실행된 시간을 리턴하는 메소드 사용 예제(argv, exit()) node.process.js123456789process.argv.forEach(function(item, index) { console.log(index + &quot;:&quot; + typeof item + &quot;:&quot;, item); if (item === &quot;--exit&quot;) { var exitTime = Number(process.argv[index + 1]); setTimeout(function() { process.exit(); }, exitTime); }}); result12340:string: /usr/local/bin/node1:string: /Users/taebbong/Desktop/node_ex/node.process.js2:string: --exit3:string: 10000 결과 분석 프로그램이 실행되면 해당 프로세스의 메타데이터(argv) 정보가 존재하게 되는데, 이를 하나하나 파싱한 것 그렇게 하나하나 출력하다가 –exit이라는 string을 발견하면 일정시간을 기다렸다가 종료되도록 만든 것 export 모듈 만들어서 불러오기 사용 예제 module.js12345export.abs = function(number){ if(number &gt; 0) return number; return -number;}; main.js12var module = require(&quot;./module.js&quot;);console.log(&quot;abs(-273) = %d&quot;, module.abs(-273)); result12$ node main.js&gt; abs(-273) = 273 4강 node.js 기본 모듈 기본 내장 모듈을 공부하려면 node.js API 문서를 보는 것이 좋을 것 node.js API Doc 이제 각 기본 내장 모듈에 대해 알아보자 os os에 관한 메소드, 객체가 존재 개념보다는 문서를 보고 활용함에 집중 사용 예제 node.os.js1234var os = require(&quot;os&quot;);console.log(os.hostname());console.log(os.type());console.log(os.networkInterfaces()); result12345678USERNAME.localDarwinlo0:[ { address: '127.0.0.1', netmask: '255.0.0.0', family: 'IPv4', mac: '00:00:00:00:00:00', } ... ] url url과 관련된 내장 모듈 사용 예제 node.url.js123var url = require(&quot;url&quot;);var parsedObject = url.parse(&quot;https://taebbong.github.io&quot;);console.log(parsedObject); result12345678910111213Url { protocol: 'http:', slashes: true, auth: null, host: 'taebbong.github.io', port: null, hostname: 'taebbong.github.io', hash: null, search: null, query: null, pathname: '/', path: '/', href: 'http://taebbong.github.io/' } crypto 암호화, 해시 생성 모듈 file system 파일 관리, 읽고 쓰기 가능","link":"/2018/01/04/2018-01-04-node-02/"},{"title":"스타트업 Picasso 출근 일기","text":"스타트업 출근기2018.3.6(화) 정식출근1일차! 디바이스 환경 구축 아침에 출근해서 할 일을 리스트업해보자 스트리머 크리에이터, 매니저에게 연락 =&gt; 어떠한 통계(데이터)를 원하는지 얻어냄 [-] Node.js socket.io 공부(11장 끝까지) [-] Pytorch Basic Course Done 2018.3.7(수) 너무 졸립다.. 커피 사러가야지.. ‘유튜브 통계 제공 플랫폼’ 서비스 이름, 서비스 구조, 유저 flow 정리 Node.js socket.io 공부.. [-] Youtube api 정리 크롤러 제작 준비 2018.3.8(목) 출근 3일차 요새 자꾸 늦게 일어난다.. 그래도 물병 들고옴 ㄱㅇㄷ 채널 크롤러 완성 Youtube certificated 받기 위한 방법(채널 id 목록 및 쿼리 제한에 대한 문의) 문의 하기 [-] 데이터베이스 모델링 및 파이프라인 고민 2018.3.9(금) 일주일이 끝나간다.. 개 피곤 휴식이 필요하겠다.. 청약 줄이고 80만원 모으기 + 도시락 쌀 수 있을까 고민하면서 도시락통사기 Youtube api 정리하기 Youtube api 로 대강의 데이터 뽑아보기(일단은 channelId list 만 뽑아도 대성공) [-] 개발 milestone 그려보기 [-] 딥러닝 공부 [-] socket.io 공부 2018.3.13(화) 아이고 잘 쉬었다 요번 일주일도 화이팅..^^ 배곺.. 개발 milestone 그리기 [-] Youtube Api 정리, 문서화 데이터 폼 정의 [-] 딥러닝 공부 2018.3.14(수) 어쩜 하루하루 이렇게 피곤한지.. 집에 가고 싶어요.. Python 버전 크롤러 수정, 완성하기 [-] 외주 크롤러 수정하기 [-] 강의 자료 form 만들기 [-] Python 강의 자료 만들기(기본 문법 편) 2018.3.15(목) 인셉션 꿈 개오반데.. 그래도 덕분에 늦잠 개꿀띠 Node.js 기반 채널별 동영상 url 뽑아오기 1차 완성 비동기 처리 및 데이터 txt 파일에 쓰기 [-] Pytorch 공부하기 [-] 논회 공부하기 2018.3.16(금) 2연속 늦잠 개오반데.. 그래도 이렇게 쉬는건가 싶고ㅎㅎ 오늘은 기필코 크롤러를 완성해내겠다! 집에 가서는 회사일을 하지 않겠다! youtube_videolist_node.js 에서 동영상 개수 maximum = 500 =&gt; total results 로 바꾸기 2018.3.17(토) 강의자료 공통 폼 만들기 Python 기초 강의자료 만들기 0강 =&gt; 이틀에 하나씩..? [-] 크롤러 제작기 블로그 포스팅 [-] 논회 공부하기 2018.3.19(월) 학교 열심히 다니자ㅎㅎ… 이번엔 학점 잘받아야지 태형아.. youtube_channeldetail_node.js 에서 각 채널 url 기반으로 채널 정보 가져오기, 저장하기 youtube_videodetail_node.js 에서 각 동영상 별 상세 정보 가져오기, 파일로 저장하기 [-] 논회 공부하기 2018.3.20(화) 야식은 먹지 말자.. 오늘은 낮잠 절대 자지 말고 일찍 꼭 자자ㅠㅠ 동영상 url txt 데이터 디렉토리 만들기(채널별) txt 파일 이름 정의 크롤러 연동작업 실시(youtube_channeldetail + youtube_videolist + youtube_videodetail) // videolist를 작성하는 동시에 videodetail을 작성해버리기? 2018.3.21(수) 오늘은 왜… 어떻게 잤길래 목이 이렇게 아프나ㅠㅠ 유튜브 크롤러 에러 처리 논회 공부 2018.3.22(목) 정시 출근 성공! 상쾌한 하루^^ 맥북 맛가는줄.. 슬슬 맛 갈 수도 유튜브 크롤러 에러 처리 api url 에 type = channel or video 로 지정해주기(안그러니까 playlist까지 가져와서 동영상 리스트 뻥튀기 되는듯) 2018.3.23(금) 학교 졸려ㅠㅠㅠㅠㅠㅠ 이 수업 너무 오바다ㅎㅎ 유튜브 크롤러 구조 재설계 및 코딩 시작 [-] 아키텍쳐 범위 내에서 완성하기 2018.3.26(월) 흐어어어 피곤해 강의자료도 만들고 과제도 해야하는데.. 논회공부 네트워크 공부는 언제하나.. 유튜브 크롤러 에러 핸들링 Unhandled promise warning 이 화면에 뜨지 않도록!!!! 2018.3.27(화) 너무 늦게 잤어ㅠㅠ 눈치보임..ㅎ [-] 코드 정리 및 최적화 에러 제거 2018.3.29(목) 하루 쉬었으니 더 열심히!! 그래도 쉬니까 아주 기모찌 하고만 크롤러 완성 2018.3.30(금) 오늘은 칼퇴하고 싶다..! 정말루다가! 크롤러 완성 2018.4.2(월) 간만에 일한다 푹 쉬었더니 몸이 아주 가볍구만 4월 2일부터 매일 커밋의 1년을 시작한다! [-] 크롤러 유지보수 외주 크롤러 코드 리뷰 및 수정(한국어 필터링, 채널 시드 자동화) [-] 강의자료도 만들면 좋겠다.. 2018.4.3(화) 12시반ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 인생.. 오전에는 그냥 출근을 하지 말까.. 외주 크롤러 코드 수정(채널 시드 자동화) 아이디어 고민 및 설계 [-] 강의자료 만들고 시퍼요.. [-] 논회 공부도 할래요.. [-] 디비 제안서 &amp; 모델링 코드윙즈 숙제 업로드 2018.4.4(수) 오늘은 칼퇴 후후훗 전 먼저 갑니다~~ 채널 크롤러 timeout 설정 및 python 코드 내에서 해당 크롤러 실행할 수 있게 세팅 시드 순환 설계 2018.4.5(목) 오늘은 아주 개운하고 행복한 아침이얌..ㅎ 오늘 일 얼추 마무리하고 내일은 다른 일 해보자 채널 크롤러 50개 seed 1분 단위 * 5 1차 완성 추출된 seed를 다시 파일로 불러와서 50개 단위로 재반복 [-] 디비 플젝 개발 시작(리소스 만들기) 2018.4.9(월) 힐링 후 출근 ㄱㅁㄸ 이번주 빡시게 일하고 시험기간을 맞이하자.. 형준이형 코드 함께 고치기 작업 리스트 정리 2018.4.10(화) 퀴즈 잘봤다 기모찌 ㅠㅠㅠㅠ 오늘 첫 수업 넘나 떨린다! [-] ES6 표준 지켜서 코드 수정(package, eslint, gitignore 등을 공부) 채널 리스트 크롤러 시드 교체해서 돌려놓기 2018.4.11(수) 랜덤 돌려놓으니까 영 시드 퀄이 안좋네 비디오 개수 많은 애들로 정렬해서 탑 50 단위로 시드로 넣어야겠다 코드를 고쳐야겠어요.. [-] Es6 표준 고치기 [-] 코드 클래스로 나누기, 조금 더 직관적으로 바꾸기 [-] 채널리스트 크롤러 시드 교체 코드 작성","link":"/2018/03/06/2018-03-06-picasso-diary-post/"},{"title":"첫 포스트, 계획과 구성: 블로그를 소개합니다!","text":"인사 안녕하세요, TaeBbong 입니다. 2018년을 맞아 미뤄 두었던 깃헙+지킬 블로그 개설에 성공했습니다! 한 해가 시작할 때 사람들이 가장 많은 계획을 꾸미고 만든다고 합니다. 그러고 한 달이 채 지나지 않아 대부분 지켜지지 않고 버려지긴 하지만요. 제게도 예외는 아닐 것이라 생각합니다. 하지만, 학부 생활이 절반 남은 이 시점에서 더 이상의 시간 낭비는 없길 바랍니다. 이에 열심히는 아니더라도 꾸준히 목표하는 바를 이루기 위한 노력을 하려 합니다. 많은 응원 부탁드립니다. 블로그는 금방 마저 꾸밀게요:) 계획 향후 블로그 포스팅 계획입니다. 우선 블로그는 여러가지 목적으로 개설했지만 우선적인 목표는 개발 프로젝트 기록입니다. 개발 프로젝트 기록을 남기기 위한 포스팅을 대체로 할 것이며, 개인 프로젝트 및 현재 일하고 있는 스타트업에서 개발하며 배우는 내용들을 위주로 기록하겠습니다. 그리고 개인 강의 자료, 과제 자료 등을 올려 놓기 위한 목적이기도 하며, 제 학생들이 이를 쉽게 접근할 수 있도록 만드려고 합니다. 블로그 구성 블로그는 현재 세 가지 파트로 구성되어 있습니다. about, posts, projects about은 제 프로필을 소개하는 자리이고, posts는 모든 포스팅이 기록될 자리입니다. 마지막으로 projects는 posts에 기록된 포스트들을 묶어주는 역할을 할 겁니다. 모든 포스팅을 posts에 기록을 하면 관련 있는 포스팅끼리 연속하여 보기 힘들겠죠? 그래서 projects에서 만들어질 프로젝트 게시물엔 해당 포스팅의 내용을 목차 형식으로 기록, 링크를 연결시켜 놓을 생각입니다. 제가 생각했지만 상당히 깔끔한 구성이군요:) 블로그 사용법 페이스북, 인스타그램, 깃헙 주소 등을 알고 싶으시다면 메인 화면에서 버튼을 클릭하세요! 제 자랑을 보고 싶으시다면 about을 보시면 됩니다. 할게 없어서 그냥 블로그의 모든 글들을 막 읽고 싶으시다면 posts를 봐주세요. 어떠한 프로젝트를 찾고 해당 프로젝트의 모든 글들을 읽고 싶다면 projects의 원하는 프로젝트 게시물을 봐주세요. 방문해주신 모든 분 감사합니다:)","link":"/2018/01/01/2018-01-01-first-post/"},{"title":"[개발TIP&amp;기록] JAVA 실행법 on MAC","text":"Java 실행법 코드 작성 컴파일 1$ javac HelloWorld.java 실행 1$ java HelloWorld","link":"/2018/03/20/2018-03-20-JAVA-TIP-post/"},{"title":"[개발TIP&amp;기록] Terminal, Git Command 완벽 정리","text":"Useful Terminal / GitHub Command KeyTerminal Command Key 디렉토리 이동 * cd directory 파일 이름 변경 * mv file1 file2 파일 복사 * cp /directory1/file /directory2/file 파일 삭제 * rm file 파일 목록 조회 * ls 폴더 생성 * mkdir folder 파일 생성_ touch file_ vim file (edit now) GitHub Command Key Basic Process_ git init_ git add file (or add –all)_ git commit -m “Message”_ git remote add origin https://github.com/user/repo.git * git push origin master Get Clone * git clone https://github.com/user/repo.git Pull * git pull Branch &amp; Merge_ git checkout -b new_branch_name (Make and Go to new branch)_ git checkout master (Back to master branch)_ git push origin new_branch_name_ git merge new_branch_name Force Push * git push -f origin master Cancel Push_ git reset –hard commit_id_ git push –force How to Make a Pull Request Fork Fork project on github website to my repo Clone, Remote Setting git clone https://github.com/user/repo.git git remote add project_name https://github.com/project/repo.git Branch git checkout -b branch_name git branch Add, Commit, Push git add files git commit -m “message” git push origin branch_name Pull Request Press Compare &amp; pull request button on my repo Synchronize &amp; Remove Branch git pull project_name git branch -d develop If we have to repeat git pull project_name Repeat 3~6","link":"/2018/04/02/2018-04-02-terminal-git-command-post/"},{"title":"[회고록] 게으른 나에게 적성인 일은 없다 1편","text":"2018년 회고를 시작하며2018년은 참 짧게 느껴졌지만 신기하게도 많은걸 해낸 한 해였습니다.뭔가 시간 자체는 참 금방 흘러간거 같은데 생각보다 이것저것 잡다하게 많이 했더라구요.아직 나이가 많지 않은데도 이런걸 보면 애늙은이가 맞나봅니다:(평소에 회고록을 쓰는 편도 아니고, 기록이나 일기 쓰기 등이랑은 거리가 상당히 멀지만 그래도 본격적으로 개발 공부를 시작한 첫 해인만큼,그리고 내년에 좀 더 성실하자는 의미에서 한 번 글을 써볼까 합니다.두서 없고 재미도 없을 수 있지만 그래도 심심할 때 읽어보세요ㅎㅎ 2018.01 ~ 2018.02 - 실리콘벨리 연수 in Draper University소프트웨어 마에스트로 활동을 돌아보니2017년 여름부터 했던 소프트웨어 마에스트로 8기 과정을 수료하고, 운이 좋게 해외 연수 대상자에 선발되었습니다. 8기 때부터 인증에 대한 지원금 없이 해외 연수를 무료로 제공하는 것으로 혜택이 바뀌었죠. 제가 서두에 개발 공부를 시작한 첫 해가 2018년이라는 말을 했듯, 개발을 배우고 싶어 들어간 소프트웨어 마에스트로에서는 개발을 하지 못했습니다. 당시 우리 팀은 개발 공부보다는 이력, 수상, 인증에 욕심이 많았고 이 때문에 효율적인 프로젝트를 위해서는 각자가 잘하고 있는 것을 해야했죠. 팀 구성원 중 한 명의 개발 실력이 월등히 높아 개발 면에서 도움 줄 수 있는 내용이 없었어요 특히 C# WPF에 대해서 말이죠. 그래서 전 기획 문서 정리와 발표자료 제작 등을 맡았답니다. 덕분에 PPT 만드는 능력이 수준급으로 성장했고 기획에서 어떻게 어필을 할 수 있는지 등 여러가지를 배웠습니다만, 제가 배우고 싶던건 아니었네요. 소프트웨어 마에스트로를 하고 싶은 분들께 같잖은 충고 한마디 드리자면, 개발을 공부하고 실력이 향상되길 원하시면 꼭 본인과 생각이 비슷한 팀원들끼리 만나세요. 인증같은 떡고물에 욕심 부리지 않고 오롯이 공부에 전념할 수 있는 팀을 구성하는게 제일 중요하다고 생각됩니다. 개발 공부를 드디어 시작하다아무쪼록 뭐, 지나간 일이니 아쉽지만 어쩔 수 없죠. 그래도 미국 다녀왔으니 다행이라고 생각됩니다^^ 실리콘벨리에서는 기업가 정신이라고 번역된 학문인 Entrepreneurship에 대해 배우는 것이 main contents 였습니다. 이를 전문으로 가르치는 Draper University라는, 창업사관학원? 같은 곳에서 대략 한달 넘게 지냈습니다. 사람이 하라는 걸 열심히 해야하는데 꼭 이거 할땐 다른거 하고 싶고 그런가 봅니다. 정작 이곳에서는 기업가 정신에 대해 배울 수 있는 활동들은 그다지 크게 열심히 하지 않고, 개발 공부를 시작했어요. 나에게 한 두달 정도 아무것도 안하고 지낼 수 있는 여유로운 시간이 생겼으니 개발 공부를 하자는 마음이었나봅니다. 이때 그래도 공부한 시간이 참 소중했습니다. Node.js를 공부했는데, 그 동안 익숙했던 언어는 Python, C였고, 웹 개발을 꼭 해보고 싶어 Python Django를 몇 번 시도해봤는데 식견이 적어 제대로 잘 안됐었거든요. 그래서 이때 Node.js로 웹 개발, 백엔드를 공부해볼 수 있었습니다. 처음으로 CRUD 웹 게시판 코드를 작성해보고, MYSQL과 연동하고, Express Framework로 이게 얼마나 간단하게 할 수 있는 일인지도 해봤어요. 뿌듯했답니다:) 이 두달간 사실 머신러닝이나, Django 쪽도 공부를 꼭 해보고 싶었는데, 제가 게으른 사람인지라 여기까지는 손도 대지 못했어요. 그래도 이렇게 한번 공부하는 습관을 들여보았고, 내가 그래도 할 수 있는 사람이다를 알았으니 한국에 돌아가서 열심히 해봐야지 라는 생각이 들었습니다:) 당시 Node.js를 공부했던 내용들은 다음 포스트 링크에서 확인하실 수 있습니다! 2018.03 ~ 2018.06 - 3학년 1학기 &amp; 스타트업 Picasso 재직 in Korea University &amp; 탈잉 강사Picasso를 시작하며2017년 소프트웨어 마에스트로 활동이 거의 끝나가던 무렵, 선배의 지인의 연락을 통해 주식 알고리즘 트레이딩을 구현하고자 하는 경영대생 친구(선배)를 만났습니다. 저를 포함해 총 3명짜리 팀이었고, 나머지 둘다 경영대생이었습니다. 처음엔 그냥 팀 프로젝트로 같이 공부하면서 만들어나가자는 의미에서 시작을 했었고, 그래서 속도는 조금 느렸지만 같이 프로그래밍 언어를 공부하는 것부터 해서 이것저것 연구하고 공부했었죠. 사실 이때는 모든 구성원 다 크게 열심히 한 거 같지는 않았어요. 이후에 전기전자공학부? 친구 한명이 팀에 들어왔고, 이 분은 주식 쪽에 관심이 많은 것 뿐만 아니라 개발도 잘했기 때문에 팀 차원에서 큰 도움이 되었어요. 근데 당시 우리가 같이 공부하던 학교의 스터디룸이 겨울이라 많이 춥더라구요ㅠㅠ.. 번듯한 사무실을 얻어서 작업하자!는 꽤나 가벼운 마음에서 고려대 경영학부 대상 Startup Express에 팀장님이 지원했는데, 덜컥 붙어버렸습니다..! 결국 상까지 타고 창업 지원 공간, 사무실에 입주까지 성공했답니다ㅎㅎ 이때까지는 참 행복했죠. 대회에서 상타서 회식도 하고 참 좋았는데, 이때부터 문제가 시작되었답니다. 아무래도 창업 공간에 들어온 이상 어떤 창업 서비스를 만들어야 하고, 돈을 벌 수 있어야 하고, 그러려면 여느 창업자들처럼 시간과 노력을 엄청 많이 투자해야 했답니다. 물론 저는 입주 직전에 미국 연수가 결정되어 3월에 돌아올게! 라고 말하고 떠났었지만 남아있는 동료들은 그런 문제들을 경험하고 있었나봅니다. 어떤 현실과의 타협과 창업에 대한 두려움, 시간을 낭비하는 것 같아 다들 고민이 많고 이슈들도 많이 있었더라구요. 2월 말에 돌아와보니 팀이 조금은 달라져있었습니다. 원래 주제인 주식을 버린지도 오래 되었고, 팀 구성원도 조금 변경이 있었어요. 그래도 뭐 전 개발을 배우는 입장이니까, 뭐든 좋겠지 싶어 계속 남아있었답니다. 이때 우리는 창업에 대한 진지한 고민과 함께 그래도 우리가 하고 싶던 주식쪽을 진행하려면, 데이터 분석과 관련된 일을 해야하지 않을까 싶었죠. 하지만 경험없는 학부생들에게 데이터 분석을 맡길 회사가 어디있을까요. 결국 우리는 우리만의 서비스를 제작하기로 결정했죠. 그래서 만들기로 한 서비스가 유튜브 관련 데이터 분석 서비스인 “래더 ladder” 입니다. 업무가 지루해지다전 3개월 정도만 이 스타트업에 있었어요. 저 사이트가 베타 런칭을 한 건 대략 910월 쯤이었으니 사실 제가 참여했다 라고 하기에도 민망한 느낌이긴 하네요. 제가 당시 맡았던 업무는 Youtube API를 활용한 Node.js 기반의 크롤링 엔진을 만드는 일이었어요. 백엔드를 개발하기로 한 개발자분이 Node.js Express로 웹 개발을 하신다고 하셔서 호환 문제를 미리 방지하고자 Node.js로 작성했답니다. 미국에서 Node.js를 공부하기 참 잘했다는 생각이 들더라구요. 그래서 부끄럽지만 난생 처음으로 API를 제대로 이해하고 써봤어요. 고등학생땐 API 문서 들어가서 분석해봐, 읽어봐 이래도 아무것도 몰랐고 이걸로 그래서 결국 뭘 하는건지도 몰랐는데, 이제야 이해가 되더라구요. 그래서 대략 12주 만에 크롤링 엔진을 완성했습니다!! 제가 그래도 정보올림피아드 공부했던 경력 덕분인지, 뭘 만들겠다 마음먹으면 빠르게 작업하긴 하더라구요ㅎㅎ.. 이때 제가 맡은 업무가 끝난줄 알았어요. 그러기는 커녕, 아주 기나긴 고행의 시간이 기다리고 있었답니다. 최적화. Optimizing이라는 일이 얼마나 어려운 일인지 그때 알았답니다. 제가 만든 코드는 당시 채널 10만개는 커녕 1만개에 대해서도 시간이 되게 오래 걸렸어요. 또 비동기 방식에 대한 이해가 없었다보니 여러 모로 비효율적인 코드가 많이 있었죠. 그래서 이때부터 백엔드 개발자 분을 마치 사수처럼 대하며 최적화 부분에서 많은 도움을 받아 작업했습니다. 지금 생각해보면 이만큼 많이 도움되는 사수가 없다 싶을 정도였죠. 하지만 당시의 저에게는 너무 지루했나봅니다. 그도 그럴 것이, 원래 개발자라는게 자기가 예전에 짠 코드는 다시 보기 싫잖아요? 물론 계속 보며 고쳐나아가야 하지만 말이죠. 3월 중순에 완성한 코드를 두달 넘게 고치고 있으니 내가 여기서 뭐하고 있나 싶더라구요. 일도 눈에 안들어오고, 점점 하기 싫어지고, 늦잠 자고, 출근 잘 안하고 하다보니 점점 일에 대한 마음이 식어갔어요. 그러면서 학교도 다니고 하려니 나태한 제가 방해되더라구요. 여러모로 이곳에서 더이상 일을 하기 싫다는 생각이 들던 무렵, 같이 일하던 형이 다른 회사에서 제의를 받아 이직하게 되었고, 이때다 싶어 같이 그만두었습니다:) 월급한번 받은 적 없고, 계속 지루한 일만 하며 그래도 몇 가지 배우고 하던 제 첫 스타트업 재직은 그렇게 마쳤습니다. 이때 느낀 것은 사람이 나태해지지 않으려면 끝없이 노력해야 한다는 것, 그리고 나는 재미있는 일을 꼭 해야 한다는 것, 그렇지 않은 일을 하려면 그에 걸맞는 보상이 있어야 한다는 걸 알았어요. 만약 그 당시 월급이라도 있었다면 나름 버티며 일하지 않았을까 싶더라구요. 그렇지도 않다보니 그냥 일이 재미없어져 버리면 순식간에 나태해지는 거죠. 인생 첫 스타트업은 그렇게 마무리가 되었답니다. 아! 그래도 가기 전에 소마에서 1500만원 상당의 지원금을 받도록 데모데이에 나가 상을 탔답니다! 그렇게 큰 컨퍼런스 장에서 발표한건 처음이었는데 생각보다 잘해서 기분이 좋았어요:) 당시 스타트업 출근 일기는 여기서 확인하실 수 있습니다! 소프트웨어 마에스트로 수료생 대상 창업자 데모데이 발표 영상은 여기서 확인하실 수 있습니다! 탈잉으로 연명하기스타트업에 다닐 당시 제게는 돈이 부족했습니다. 소프트웨어 마에스트로 활동 때는 매달 100만원씩 있어 살 수 있었는데, 월급도 안나오는 곳에서 일하는 사람에게 돈이 있을리가요ㅠㅠ 그래서 과외를 다시 알아봤습니다. 요새는 탈잉이라는 플랫폼에서 과외를 많이 하더라구요. 특히 그룹 수업을 잡을 수 있다는 생각에 탈잉에 냉큼 가입해서 파이썬 과외를 올렸습니다. 생각보다 팀 수업을 잡기는 어렵더군요. 그래도 여러 차례 수업 진행해보고, 고려대 의대 학생들을 대상으로 팀 파이썬 스터디도 진행해보면서 나름 돈은 많이 벌 수 있었어요! 이때 강의자료도 직접 만들어봤구요. 진상들도 참 많이 만났습니다. 이 이야기는 나중에 조금 더 자세하게 다루어볼까 해요. 아무쪼록 또 다시 과외로 삶을 살아가는 그런 학생이 되었답니다. 당시 만든 강의자료 목록은 여기서 확인하실 수 있습니다! 안드로이드 개발 첫 경험3학년 1학기 동안 한 공부중에 나름 가장 보람찼던 건 안드로이드 앱 개발 공부였어요! 재수강 하던 데이터베이스 수업에서 DB를 활용한 자유로운 프로젝트를 마지막 기말 대체 과제로 받았었는데, 이때 처음으로 안드로이드 앱 개발을 체험해봤답니다! 인프런에서 나동빈님의 강의를 무작정 따라가보니 어찌저찌 뭐가 다 되더라구요. 자바를 공부해두었던게 참 다행이었죠. 그래서 이때 밤새는줄도 모르고 미친듯이 공부하고 앱을 만들어냈답니다! 물론 지금 와서는 참 못만들었다 싶지만 그래도 이때 처음 앱 개발을, 그것도 단 이틀도 채 안되어 완성했다는게 제일 뿌듯한 점이었습니다. 당시 만든 앱 Repository는 여기서 확인하실 수 있습니다! 회고록 2편","link":"/2018/12/30/2018-12-30-remember2018-1/"},{"title":"[개발TIP&amp;기록] MYSQL 실행법 on MAC","text":"mysql 실행법123456$ where mysql&gt;&gt;&gt; usr/local/bin/mysql$ cd usr/local/bin$ ./mysql -u root -p&gt;&gt;&gt; Enter password: &lt;type your password&gt;mysql&gt;","link":"/2018/03/03/2018-03-21-MYSQL-TIP-post/"},{"title":"Bbong 뽑는 Python 기초","text":"강의 소개 Bbong 뽑는 Python 기초 강의 자료를 공유합니다. 해당 강의 자료는 TaeBbong의 저작권 소유물이며 상업적 이용 및 복제, 수정이 불가합니다. 공부를 위해 사용해주세요:) 또한 강의 자료에 대한 피드백 언제든 환영합니다. 프로젝트 링크 01 출력, 자료형, 입력 02 조건문, 반복문, 함수 03 클래스, 모듈 04 기본 모듈 활용","link":"/2018/04/09/2018-04-09-bbongpython-project/"},{"title":"01 개발 준비: Selenium &#x2F; Requests 개발환경 세팅하기","text":"게시글 링크 01 개발 준비: Selenium / Requests 개발환경 세팅하기 02 블랙보드 게시글 가져와서 출력하기: Selenium 기반 크롤링 엔진 제작 02-1 블랙보드 게시글 가져와서 출력하기: Requests, Session 기반 크롤링 엔진 제작 03 블랙보드 신규 글 확인하기: MySQL 데이터베이스 연동 04 블랙보드 신규 글 알림 기능 제공하기: SMTP 메일링 기능 추가 05 정기적으로 작동하게 만들기: Scheduling 기능 추가 여태까지 최종 결과물 소스코드 레포 06 블랙보드 알림 안드로이드 어플리케이션 만들기: 크롤링 엔진을 Django Rest Framework API 서버로 수정, 서버에 Deploy 07 블랙보드 알림 안드로이드 어플리케이션 만들기: Android 앱 개발, API 서버와의 연동 07-1 블랙보드 알림 챗봇 서비스 만들기: 카카오톡 챗봇 개발, API 서버와의 연동 블랙보드 알림 안드로이드 어플리케이션 결과물 레포 블랙보드 알림 챗봇 서비스 결과물 레포 블랙보드 알림 API 서버 결과물 레포 시작하며 안녕하세요, TaeBbong 입니다. 오늘은 나만의 블랙보드 알림 서비스 제작 프로젝트의 첫 단계인 개발환경 세팅을 진행하겠습니다. 앞서 프로젝트 소개 글에 설명하였듯 시작 단계는 Selenium 기반으로 작성, 이후 Requests를 활용하여 개발하였습니다. 이에 각각의 개발환경을 미리 세팅하여 준비하겠습니다. 단원 목표 Selenium 설치, ChromeDriver을 사용할 수 있다. Requests 모듈 설치, Session과 함께 Requests를 사용할 수 있다. Selenium, 셀레니움이란? Selenium은 웹 테스트 자동화를 위한 툴입니다. 기본적으로는 웹 서비스를 개발하며 테스트를 실제 유저가 하는 것처럼 진행하기 위해 사용합니다. 실제 브라우저를 열어 웹 페이지를 탐색하고 버튼을 누르거나 값을 입력하는 등 진짜 유저가 웹을 사용하는 것처럼 만들 수 있어 유용합니다. 그러한 특징은 웹 크롤링에도 활용할 수 있어서 프로그램이 실제 유저처럼 웹을 탐색하며 데이터를 수집하도록 제작할 수 있습니다. 그로 인해 requests 등의 모듈보다 훨씬 쉽고 유동적으로 데이터를 가져올 수 있습니다. 우리는 후자의 활용법을 사용해 Selenium으로 블랙보드의 데이터를 가져올 수 있도록 할 것입니다. 왜 이번 프로젝트에서 Selenium을 사용하나요? 물론 실제 브라우저를 작동시킨다는 것에서 알 수 있듯 리소스 사용량이 훨씬 많습니다. 그에 따라 속도 저하는 물론 서버에 배포하는데 있어 전혀 적합하지 않습니다. 게다가 대부분의 서버 OS로 채용되는 리눅스 환경에서는 headless option(브라우저를 열지 않고 작동하는 모드)을 사용하지 않으면 작동되지 않습니다. 그러한 단점들이 분명히 있음에도 Selenium을 사용하는 이유는 로그인 등의 기능을 간편하게 자동화 할 수 있기 때문입니다. 로그인과 같이 웹을 탐색할 때 제약사항이 되는 부분들은 대부분 Selenium으로 극-복 할 수 있습니다. 때문에 입문자들은 Selenium으로 적절히 웹 크롤링에 대한 개념을 익힐 수 있고, 이후 session을 활용한 requests 모듈을 사용해 로그인 등의 기능을 직접 개발하여 자동화 할 수 있습니다. Selenium 설치하기 이제 Selenium을 설치해보겠습니다! Pycharm Pycharm 환경에서는 File -&gt; Setting -&gt; Project Intepreter(windows) / Pycharm -&gt; Preference -&gt; Project Intepreter(mac)으로 이동합니다. 여기서 selenium을 검색, 설치합니다. 설치가 완료 되었습니다! CLI Command Line Interface 환경의 경우 다음 명령어를 터미널에 입력합니다. 1$ pip install selenium 추가적으로 설치해두면 이후 좋은 라이브러리는 다음과 같습니다. 12bs4smtp ChromeDriver 다운로드 Selenium이 실제 브라우저를 작동시키기 위해서는 웹 브라우저 드라이버 실행파일이 필요합니다. 대표적으로 사용하는 드라이버는 역시 ChromeDriver입니다. 다음 링크에 이동하여 각자의 OS에 맞는 드라이버를 설치합니다. ChromeDriver 다운로드 되었으면, 해당 파일은 본인이 코드에서 접근하기 좋은 주소에 이동시킵니다. ex) C:, /Users/user_name/ 제가 본 프로젝트에서 드라이버를 저장한 위치는 다음과 같습니다. 1/Users/TaeBbong/Projects/BlackBoard-Tutorial/ Selenium + ChromeDriver 작동 테스트 여기까지 세팅한 내용들이 잘 작동하는지 확인해보겠습니다. 프로젝트 폴더에서 Python 파일을 생성합니다. 이후 다음과 같은 코드를 작성해봅시다. …/BlackBoard-Tutorial/crawl-demo.py 12345from selenium import webdriver # 모듈 불러오기driver = webdriver.Chrome('/Users/TaeBbong/Projects/BlackBoard-Tutorial/chromedriver') # 드라이버 설정(Windows는 chromedriver.exe)driver.implicitly_wait(3) # 3초간 기다려달라(실행 후 준비를 위한 규약적인 시간)driver.get('https://www.naver.com') # 원하는 URL로 이동하기 실행하면 다음과 같이 크롬이 열립니다. 코드는 주석으로 충분한 설명이 되었을거라 믿습니다:) 마치며 이렇게 이번 시간에는 Selenium을 설치하고 테스트 하는 것까지 하였습니다. 다음 포스트부터 본격적으로 프로젝트 개발을 시작하겠습니다:)","link":"/2019/02/11/2019-02-11-blackboard01-post/"},{"title":"02 블랙보드 게시글 가져와서 출력하기: Selenium 기반 크롤링 엔진 제작","text":"게시글 링크 01 개발 준비: Selenium / Requests 개발환경 세팅하기 02 블랙보드 게시글 가져와서 출력하기: Selenium 기반 크롤링 엔진 제작 02-1 블랙보드 게시글 가져와서 출력하기: Requests, Session 기반 크롤링 엔진 제작 03 블랙보드 신규 글 확인하기: MySQL 데이터베이스 연동 04 블랙보드 신규 글 알림 기능 제공하기: SMTP 메일링 기능 추가 05 정기적으로 작동하게 만들기: Scheduling 기능 추가 여태까지 최종 결과물 소스코드 레포 06 블랙보드 알림 안드로이드 어플리케이션 만들기: 크롤링 엔진을 Django Rest Framework API 서버로 수정, 서버에 Deploy 07 블랙보드 알림 안드로이드 어플리케이션 만들기: Android 앱 개발, API 서버와의 연동 07-1 블랙보드 알림 챗봇 서비스 만들기: 카카오톡 챗봇 개발, API 서버와의 연동 블랙보드 알림 안드로이드 어플리케이션 결과물 레포 블랙보드 알림 챗봇 서비스 결과물 레포 블랙보드 알림 API 서버 결과물 레포 블랙보드 로그인 구현 이제 실제 프로젝트 코드를 작성해봅시다! 블랙보드 사이트에 로그인을 진행할건데, 간단하니 함께 따라와주세요:) 우선 블랙보드에 들어가볼게요. (https://kulms.korea.ac.kr) 이제 우리는 크롤링을 할 때 가장 많이 쓰는 툴인 크롬 개발자도구를 써보겠습니다. 크롬 개발자도구를 다음과 같이 키면 이런 화면이 나옵니다! 이 화면에서 왼쪽 상단의 커서를 통해 내가 원하는 웹 구성 요소에 대한 정보를 얻을 수 있습니다. 로그인을 하려면 id, password를 각각 입력하고 로그인 버튼을 눌러야겠죠? 그러면 id 입력 창을 찾아보겠습니다. 이렇게 보시면 input 태그의 id 입력창이 나오는데, 여기 name = &quot;id&quot; 보이시죠? 이걸 활용합니다. 그럼 이제 파이썬으로 돌아와서 다음과 같이 코드를 작성해볼게요. …/BlackBoard-Tutorial/crawl-demo.py 1driver.find_element_by_name('id').send_keys('YOUR_BLACKBOARD_ID') # id 입력하기 위의 코드는 name이 id인 element를 찾아 내가 원하는 string을 입력하도록 하는 코드입니다. 내 블랙보드 아이디를 쓰면 되겠죠? 비밀번호도 마찬가지로 진행합니다. 이제 로그인 버튼을 눌러야 하는데, 로그인 버튼을 찾아서, 오른쪽 마우스 -&gt; copy -&gt; copy by xpath를 눌러 복사합니다. 코드는 이렇게 씁니다. …/BlackBoard-Tutorial/crawl-demo.py 1driver.find_element_by_xpath('//*[@id=&quot;entry-login&quot;]').click() # 로그인 버튼 클릭 위 코드를 통해 버튼 클릭을 실행시킬 수 있습니다. 여기까지의 전체 코드는 다음과 같아요! …/BlackBoard-Tutorial/crawl-demo.py 123456789from selenium import webdriverdriver = webdriver.Chrome('/Users/TaeBbong/Projects/BlackBoard-Tutorial/chromedriver')driver.implicitly_wait(3)driver.get('https://kulms.korea.ac.kr')driver.find_element_by_name('id').send_keys('YOUR_BLACKBOARD_ID')driver.find_element_by_name('pw').send_keys('YOUR_BLACKBOARD_PW')driver.find_element_by_xpath('//*[@id=&quot;entry-login&quot;]').click() 실행시키면 로그인이 원활하게 되는걸 볼 수 있어요:) 코스 과목 목록 가져오기 이제부터는 크롤링의 핵심 도구인 bs4를 사용합니다! 코스로 이동하면 다음과 같이 과목 리스트가 나옵니다. 역시 개발자 도구로 분석해보면 다음과 같네요. 다음에서 볼 수 있듯 큰 div 태그 안에 작은 div id = _22_1termCourses__62_1, 그 안에 ul-li-a 순서대로 나와있네요. 결국 우리가 가져오고자 하는 건 ul-li-a 에 있는 과목별 주소 목록입니다. 그래서 ul-li-a 의 href url을 눌러보니 다음과 같이 나오네요..! 이런 경우에는 과목 url 패턴을 직접 분석해 볼 필요가 있습니다. https://kulms.korea.ac.kr/webapps/blackboard/execute/announcement?method=search&amp;context=course_entry&amp;course_id=_130469_1&amp;handle=announcements_entry 이런 식으로 구성되어있는걸 확인할 수 있네요! 뒤에 &amp;handle= 부터는 지워도 전혀 문제 없이 실행되네요! 그럼 기왕이면 간단한 URL인 다음 형태로 정해봅시다. https://kulms.korea.ac.kr/webapps/blackboard/execute/announcement?method=search&amp;context=course_entry&amp;course_id=_130469_1 우리는 여기서 맨 뒤의 course_id= 부분이 해당 과목의 id란걸 확인할 수 있고 이것이 url에 필요한 구성요소 임을 알 수 있습니다. 이 course_id는 아까 과목 리스트 ul-li-a에서 봤던 주소 안에 들어있었죠! 그럼 우리의 목표는 간단해졌습니다. ul-li-a를 모두 긁어와 그 안에 있는 course_id들을 리스트에 저장하는 일이죠. 그러기 위해서 html을 파싱해야하는데, 이때 사용하는 툴이 BeautifulSoup, BS4 입니다. Selenium Driver의 .getAttribute('innerHTML')을 통해 내가 찾고자 하는 element의 HTML 값을 가져올 수 있습니다. 또한 Selenium의 장점인데 이렇게 데이터를 가져오면 javascript가 실행된 이후의 페이지 데이터에 참조가 가능합니다. 이를 위해선 아래와 같이 드라이버에게 element가 load될때까지 기다려달라고 해야합니다! …/BlackBoard-Tutorial/crawl-demo.py 1234567891011121314151617from bs4 import BeautifulSoup as bsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECtry: # 내가 원하는 element가 load 될때까지 기다리기 element = WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.ID, &quot;_22_1termCourses__62_1&quot;)))finally: passhtml = driver.find_element_by_xpath('//*[@id=&quot;_22_1termCourses__62_1&quot;]/ul').get_attribute('innerHTML')soup = bs(html, 'html.parser') # bs 객체 생성course_list_raw = soup.find_all('a', href=True) # a 태그 중 href(즉 url) 존재하는 값들 모두 가져오기course_list = [] # 과목 id 저장될 리스트for i in course_list_raw: course_each_id = str(i).split('id=')[1].split('&amp;amp')[0] # 원하는 모양으로 파싱 course_list.append(course_each_id)print(course_list) 그 전에 잠깐! soup.find -&gt; element 하나를 return, soup.find_all -&gt; element들을 list 형태로 return 이제 이 course_id 목록들과 앞서 정했던 각 과목별 상세 주소를 연결시켜 위의 코드에 합쳐봅시다! …/BlackBoard-Tutorial/crawl-demo.py 123456789101112131415161718192021from bs4 import BeautifulSoup as bsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECtry: element = WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.ID, &quot;_22_1termCourses__62_1&quot;)))finally: passhtml = driver.find_element_by_xpath('//*[@id=&quot;_22_1termCourses__62_1&quot;]/ul').get_attribute('innerHTML')soup = bs(html, 'html.parser')course_list_raw = soup.find_all('a', href=True)course_list = []course_detail_base = 'https://kulms.korea.ac.kr/webapps/blackboard/execute/announcement?method=search&amp;context=course_entry&amp;course_id='course_detail_list = []for i in course_list_raw: course_each_id = str(i).split('id=')[1].split('&amp;amp')[0] course_list.append(course_each_id) course_each_url = course_detail_base + course_each_id course_detail_list.append([course_each_url]) # 나중에 과제 주소 추가를 위해 리스트 형태로 넣음print(course_detail_list) 좋아요! 이제 각 페이지를 탐색하는 일만 남았네요!! 각 과목별 공지/과제 페이지 URL 가져오기 이미지 위에서 만든 course_detail_list의 각 주소를 들어가보면 위와 같은 형태로 되어있을거에요. 이제 Selenium을 시켜서, 각 주소에 한번씩 들어가서 공지와 과제란에 있는 모든 글들을 가져올겁니다. 그 전에 공지와 과제 URL들을 가지고 있어야겠죠? 마찬가지로 공지와 과제 각각 들어가서 URL이 어떻게 생겼는지 확인해볼게요. 공지:https://kulms.korea.ac.kr/webapps/blackboard/execute/announcement?method=search&amp;context=course_entry&amp;course_id=_130456_1 과제:https://kulms.korea.ac.kr/webapps/blackboard/content/listContent.jsp?course_id=_130456_1&amp;content_id=_2200239_1 공지는 우리가 들어온 URL그대로인데, 과제는 뒤에 content_id라는 친구가 따로 붙네요? 이 경우에는 역시 Selenium을 써서 직접 클릭해서 들어가봐야할거 같아요. 항상 javascript 기반의 웹 페이지는 위에서 작성했던 것처럼 해당 element가 load될때까지 기다렸다가 가져오는 걸 명심하세요! …/BlackBoard-Tutorial/crawl-demo.py 123456789101112131415for i in course_detail_list: driver.get(i[0]) try: element = WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.ID, &quot;courseMenuPalette_contents&quot;))) homework_html = driver.find_element_by_xpath('//*[@id=&quot;courseMenuPalette_contents&quot;]').get_attribute('innerHTML') soup = bs(homework_html, 'html.parser') nav_bars = soup.find_all('a') for bar in nav_bars: if str(bar.find('span').text) == '과제' or str(bar.find('span').text) == 'Assignments': i.append('https://kulms.korea.ac.kr' + str(bar['href'])) except Exception as e: homework_html = None print(e) passprint(course_detail_list) 이제 이 코드를 조금 고치면 모든 글들을 가져올 수 있어요! 각 과목별 공지/과제 포스트 가져오기 이제 위 과정을 통해 모든 과목별 공지/과제 주소를 알고 있고, 심지어 과제란이 있는 페이지와 없는 페이지를 구분할 수 있어요! 그럼 각 페이지의 리소스를 불러와 모든 포스트들을 가져와볼게요. …/BlackBoard-Tutorial/crawl-demo.py 12345678910111213141516171819202122232425262728293031323334353637for i in course_detail_list: driver.get(i[0]) try: # Page Load 기다리기 element = WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.ID, &quot;courseMenuPalette_contents&quot;))) # 공지 가져오기 announce_raw = driver.page_source soup = bs(announce_raw, 'html.parser') announcements = soup.select('li.clearfix')[10:] announcements.reverse() for ann in announcements: print(ann.attrs['id']) print(ann.text) print('---------------') # 과제란이 있으면 가져오기, 없으면 에러발생 -&gt; except homework_html = driver.find_element_by_xpath('//*[@id=&quot;courseMenuPalette_contents&quot;]').get_attribute('innerHTML') soup = bs(homework_html, 'html.parser') nav_bars = soup.find_all('a') for bar in nav_bars: if str(bar.find('span').text) == '과제' or str(bar.find('span').text) == 'Assignments': homework_url = 'https://kulms.korea.ac.kr' + str(bar['href']) i.append(homework_url) driver.get(homework_url) homework_raw = driver.page_source soup = bs(homework_raw, 'html.parser') homeworks = soup.select('ul.contentList &gt; li') for home in homeworks: print(home.attrs['id']) print(home.text) print('---------------') except Exception as e: homework_html = None print(e) pass 이제 실행시키면 감격스럽게도 이렇게 잘 나오네요! 전체 코드는 crawl-demo.py 에서 확인하실 수 있어요! 마치며 이렇게 이번 시간에는 내 블랙보드의 모든 과목과 과목 별 공지/과제 데이터를 가져와서 출력하는 것까지 완료했습니다. 여기까지 정말 고생 많으셨어요!^^ 만약 얘네들을 모두 메일로 보내면 매번 실행시킬 때마다 메일이 수십통씩 오겠죠? 그래서 이 글들을 데이터베이스에 저장하고 새로운 친구가 들어올 때마다 메일을 보낼 수 있도록 데이터베이스 연동을 해야합니다. 다음 시간엔 데이터베이스 연동을 진행해보겠습니다.","link":"/2019/02/11/2019-02-11-blackboard02-post/"},{"title":"[회고록] 게으른 나에게 적성인 일은 없다 2편","text":"2018.07 ~ 2018.09 - 여름방학, 소개팅 안드로이드 앱 개발 외주1차 휴식기한동안 쉬기로 결정했어요. 스타트업 업무에 한창 치였던 저는 개발이 재미가 없다고 느낄만큼 많이 힘든 상태였습니다. 이 길이 내 길이 아닌갑다 싶기도 하고 하면서 고민도 많았죠. 그래서 이때는 아-무 것도 안하고 놀고 쉬게 되었습니다!! 하스스톤도 많이 하고, 유튜브도 많이 보고, 이때 데스크탑도 구매해서 트위치 하스스톤 방송도 해보고(X망했지만) 진짜 종강하고 거의 한 달은 놀기만 하며 지냈던 거 같아요. 이럴 때 꼭 항상 자괴감도 들고, 이렇게 놀고 있어도 되나 싶은 마음도 들지만 전 분명 제 삶 속에서 이런 시간들이 꼭 필요하다고 생각합니다. 이렇게 가끔 아무 걱정 없이, 특히 심적으로 힘들지 않는 상태로 놀 수 있는 그런 시간이 재충전에 큰 도움이 되더라구요. 재밌게 즐길 수 있었던 오픈소스 해커톤제 첫 해커톤은 이것이 아닌 정보보호 해커톤이긴 하지만 그건 별로 기억하고 싶지 않아서 적지 않았어요. 비로소 처음으로 해커톤에 대해 즐길 수 있었고 노력을 많이 했으며 재미있었던 해커톤은 오픈소스 해커톤이 처음이었어요. 회사로부터 탈출하고 싶다는 생각에 여러가지 행사에 지원했었는데, 그 첫번째 행사가 이 오픈소스 해커톤이었죠! 가서 소마 때 알고 지내던 분들도 만나 반가웠고, 해커톤에 가긴 갔지만 잠도 좀 자면서 편하게 일하고 싶다는 생각에 무한복지를 외치며 팀장이 되어 좋은 팀원들도 만나게 되고, 평소에 하고 싶던 프로젝트도 팀원들과 함께 으쌰으쌰 완성해내어서 너무 좋았습니다. 이래서 해커톤 하러 오는구나 싶었죠. 결국 잠도 자며 하려 했던 해커톤 프로젝트는 이틀밤을 거의 꼬박 새고서야 완성해냈습니다. 발표도 재밌었어요! 오픈소스 해커톤 저희 팀 데모영상은 다음 유튜브 영상으로 확인하실 수 있습니다! 첫 수상! 고려대학교 해커톤 - Ekisu: 영어 본문 요약/번역 프로그램얼마 안있어 바로 나간 고려대학교 해커톤이 제 첫 수상 해커톤이에요! 물론 전체 열 몇 팀 중에서 한 팀 빼고 다 상탄 대회였긴 하지만 수상했다는게 참 기분 좋지 않습니까^^ 이 대회에 나가서 하게 된 주제는 “영어 본문을 요약하고 번역하여 제공하는 서비스”입니다! 원래는 이전 스타트업에서 하던 주제를 응용해서 해볼까 했는데 다른 참가자 중에 전 직장 대표님이 계셔서 급선회했답니다. 이 주제를 떠올리게 된건 예전에 시험 범위가 너무 많아서 찡찡대던 저에게 여자친구가 요약하는 프로그램 없냐고 말했었고, 그때 그래서 검색해보니 TextRank라는 알고리즘으로 본문을 요약할 수 있더라구요! 좋은 아이디어를 제공해준 여자친구 덕분에 당시 시험기간에 영어 본문을 파파고에 번역하고 TextRank로 요약해서 공부해서 시험을 꽤 잘 봤던 적이 있는데, 이번 해커톤에서는 이 아이디어를 그대로 가져와 상용 가능한 GUI 프로그램으로 만들어봤어요. 이전에 학교에서 과제할 때 공부했던 PyQT5로 작업했습니다. 그래서 정말 2시간도 채 안되어서 작업이 끝나 해커톤 최초 조기 퇴근을 성공해내었고, 파파고를 활용하였다는 점 덕분에 네이버 특별상도 수상할 수 있었네요! 이후 아마 11월쯤인가 이를 웹 서비스로 개편했어요. 이 덕분에 Django를 어느정도 쓸 수 있게 익혔습니다. Ekisu GUI 프로젝트 Repo는 다음 링크에서 확인하실 수 있습니다!Ekisu Django 웹 프로젝트 Repo는 다음 링크에서 확인하실 수 있습니다! 다시 몸이 근질거리는 일벌레 &amp; 굶어 죽을 뻔하다전 항상 그렇습니다. 노는 것도 그렇게 좋아하고 게으름도 많으면서 뭐 이렇게 하고 싶은 건 또 많은지. 욕심이 많다보니 이것저것 해보고 싶은게 생기더라구요. 뭐 예를 들면 웹 개발 공부를 하고 싶었다거나, 이런거 만들면 재밌겠다! 싶지만 실행력은 정작 부족한 타입이죠. 뭐 그래도 그냥저냥 지내던 중 사건이 발생했어요! 그날도 놀다가 생활패턴이 망가져 새벽같이 고른햇살에 가서 아침을 먹던 날이었죠. 김밥에 냉면을 먹고 6500원을 계산하려는데 카드가 안긁히더라구요..! 당황스러워 하다가 마음 좋으신 이모님이 다음번에 와서 주라고 하셔서 감사합니다 하고 가게를 나와 잔고를 살펴봤죠. 2000원 가량 있더라구요. 전날까지만 해도 10만원 넘게 있어 마음 놓고 있었는데 주택 청약으로 빠지는 날이라는 걸 몰랐던 거죠. 여기서 큰 충격을 받았답니다. 그래서 방에 돌아오자마자 돈 벌 수단을 다 알아봤어요. 알바천국부터 시작해서 이젠 다시 안하겠노라 라고 외쳤던 탈잉으로 들어가 강의도 다시 올려보고. 달콤한 외주의 아픔그러다 마지막에 발견한게 개발 외주였답니다. 소마 활동 때 외주로 돈 잘 번다는 얘기를 듣고 가입을 해뒀었는데, 바로 프로필 채우기 및 프로젝트 지원에 들어갔습니다. 그냥 들어봤다, 할만하겠다 싶으면 무조건 할 수 있다며 달려들었죠. 정말정말 신기하게도 연락이 오더라구요. 위시켓에서 연락 주셨고 소개팅 안드로이드 앱 개발 외주를 맡기신다고 했습니다. 디자인은 다 되어있었고 금액은 무려 700만원 규모의 외주였습니다. 미팅도 무사히 잘 마치고 결국 매칭이 되어 업무를 시작하게 되었어요. 외주에 대한 자세한 내용은 다른 글에서 제대로 다루겠지만 느낀 점만 말하면 정말정말정말 힘들었습니다.. “안드로이드 앱 개발 몇 번 해보니 별거 아니던데?” 라고 말하기엔 경험이 적은 한참 초심자라는 걸 알게 되었고 혼자의 역량으로 할 수 있는 일과 없는 일을 알아 볼 수 있는 계기가 되었습니다. 그래도 능력있는 참 좋은 분들의 도움으로 일을 잘 마무리 지었어요. 방학에 끝날 거 같았던 외주는 9월까지 끌어졌고 난생 처음으로 피할 수 없는 계약이라는 책임감 때문에 일을 해야했던 전 많이 힘들었었답니다:( 700만원이 그 일에 대해서 절대 큰 금액이 아니란 것도 알게 되었어요. 한번 진짜 제대로 고생하긴 했지만 앞으로 외주를 하게 될 때는 더 나은 선택을 하지 않을까 싶네요ㅎㅎ 위시켓 프로필은 다음 링크에서 확인하실 수 있습니다! 2018.10 ~ 2018.12 - 휴식, 공부, 그리고 도전을 위한 결정2차 휴식기당분간 일 안하겠다고 휴식하다가 돈이 없어져 시작한 외주로 한 번 더 크게 얻어맞은 다음, 진짜진짜 아무것도 안하고 쉬었습니다. 학교도 대강대강 다니고, 게임도 많이 하고, 잠을 진짜 많이 잔거 같네요ㅎㅎ.. 지친 몸과 마음을 치유할 수 있는 시간이었습니다:) 귀찮은 사람이 먼저 일을 한다 - 블랙보드 알람 프로젝트 개발해보고 싶던 사이드 프로젝트가 있었어요! 학교 블랙보드 사이트의 과제나 공지사항에 대한 알림 서비스를 만들고 싶었죠. 전 수시로 블랙보드에 들어가 뭐 올라온거 있나 확인하는 습관이 있는데 이걸 프로그램화 시키면 참 좋겠다 싶었죠. 그래서 혼자 개발을 시작했습니다! 집에 계속 켜져있는 데스크탑을 마치 서버처럼 생각해서 DB 세팅도 하고, 기본 구현은 Selenium을 통해 블랙보드의 로그인까지 구현했죠. 이후에는 smtp를 활용해서 내 메일로 보내는 기능까지 만들고 스케쥴링을 통해 6시간마다 크롤링을 반복하도록 완성했어요! 처음 나에게 도움되는 프로그램을 만들어 뿌듯했습니다:) 나중엔 좀 더 상용화할 수 있도록 코드를 수정해서 고대생들을 대상으로 배포해볼까해요. 블랙보드 알람 프로젝트 Repo는 다음 링크에서 확인하실 수 있습니다! 해커톤 데이트 &amp; 공모전 성공! - 헬프맘참, 제 여자친구는 이번에 소프트웨어 융합 학과로의 전과를 성공해내었습니다! 같은 전공을 걸어가는 애인이라니 참 좋더라구요ㅎㅎ 11월에 잡은 특별한 데이트가 있었는데 해커톤을 함께 나가는 거였어요! 그래도 비교적 먼저 시작한 제 입장에서 이런 활동들을 통해 조금 더 여자친구가 이쪽 전공에 흥미를 느낄 수 있으면 좋겠다 싶어 같이 나가게 되었죠. 주제는 여자친구가 제공했는데, “임산부들의 지하철 임산부 배려석 이용을 돕는 서비스” 입니다! 아두이노를 기반으로 작업했고, X2O 해커톤 행사(사실상CJ신사업아이디어공모전) 당일날에 가서는 다른 팀원 분들을 구해서 안드로이드 앱과 서버까지 구성하게 되었어요. 앱과 아두이노 통신을 처음에 와이파이 모듈로 했었는데, 제대로 돌아가지 않았어요ㅠㅠ 그래도 어찌저찌 완성해서 대회에서 멋지게 발표도 하고, 다른 팀들의 내용이나 완성도를 보았을 때 우리 정도면 1등 아니면 2등 정도는 하겠다 싶었는데 그러기는 커녕 상도 못탔어요ㅎ… 뭔가 상당히 아쉬웠죠. 다른 팀들이 우리보다 못했는데! 라기 보다는 수상작들의 주제가 전-부 음식과 관련된 주제였다는 것(대회 주제는 사회문제 해결 해커톤), 그리고 몇 년전에도 보았던 주제, 심지어 서비스도 하고 있는 주제가 1등을 했고 프로토 타입 구현도 안된 팀이 수상했다는게 좀 아쉬웠네요. 그래도 이때 좋은 인연을 만나 KBSC 소프트웨어 공모전에 나가게 되었어요. 이번 공모전에 나가면서는 기존 해커톤에서 개발되었던 앱과 서버를 싹 갈아 엎고 제가 직접! 만들었습니다. 그리고 통신 방식도 블루투스로 바꿨는데, 하드웨어 한번 안해본 여자친구가 신기하게도 이리저리 뚝딱뚝딱 해내더니 회로를 다 조립하여 제가 참 편하게 나머지 작업을 할 수 있었습니다! 그렇게 공모전 마감 한시간 전 지하철 막차 및 카페 마감시간에 쫓겨 일을 하다 결국 발표자료까지 완벽하게 완성을 해내었는데, 이때 얻은 만족감과 뿌듯함은 말로 형용할 수 없었어요. 솔직히 앞선 여러 대회들은 대체로 대충대충하거나, 마지막에 안되는 것도 되는 것처럼 이야기하고 그러면서 지내왔는데, 이렇게 모든 기능이 완벽하게 돌아가는 프로젝트를 그것도 하루만에 해내었다는게 진짜 만족스러웠고 그 쾌감은 올해 느낀 쾌감 중에 가장 컸던거 같아요. 이런 기분을 함께 느낄 수 있어서 참 고맙고 행복했습니다:) 덕분에 대학부 우수상도 탔어요!! 상금 100만원!! 헬프맘 프로젝트 Repo는 다음 링크에서 확인하실 수 있습니다! 종강이다! - 뇌및머신러닝 팀 프로젝트이번 학기는 수업 면에서는 상당히 평이하고 여유로웠어요. 마지막에 하나 남은 과제가 뇌및머신러닝 팀 프로젝트 과제였는데 NUGU 스피커와 연동하는 머신러닝 프로젝트였고, 저희 팀은 무난하게 고려대 도서관 이용 도움 서비스를 개발하여 도서관의 책 예약을 스피커로 할 수 있게끔 하고, Word2Vec 기반의 책 추천 서비스도 개발했습니다! 저는 여기서 NUGU Play 제작을 제외한 모든 것(API 서버, 추천 알고리즘 등)을 맡아 개발했습니다:) 도서관 이용 도움 서비스 API 서버 Repo는 다음 링크에서 확인하실 수 있습니다! 과 내 개발 동아리 DevKor 창단! 맞바꾼 인턴 기회내용 추가 예정입니다 회고를 마치며: 게으른 사람에게 적성인 일은 없다와, 이렇게 써놓고 보니 참 많은 일을 했네요! 하루하루 살펴봤을 때는 참 게으르고 분명 맨날 침대에 누워서 자거나 놀기만 했는데 은근 그래도 이것저것 참 많이 했네요. 원래는 넌 왜 이렇게 게으르니! 하며 타박하려 했는데 그래도 고생했네요, 1년동안. 처음 회고록을 쓰겠다고 다짐하며 생각했던 건 게으른 나에게 앞으로 열심히 살아보자고 이야기하기 위함이었어요. 나를 객관적으로 살펴보았을때 모자란게 참 많았습니다. 개발 공부도 심도있게 하기 보단 얕은 수준에서 만족하고, 정말 자주 놀고 게을렀던거 같아요. 특별히 그렇게 느낀 건 나의 행동을 합리화 하는 방식에서였어요. 스타트업에서 탈출할때는 ‘난 재밌는 일을 해야하나봐’라고 말하며 피하고, 외주를 할땐 ‘책임은 너무 무거워, 난 편하게 일을 해야해’라고, 사업과 동아리를 준비하며 정작 일하기는 귀찮아서 또 핑계를 대고 있을 때 깨달았어요. 난 그저 아주 게으른 사람이라는거. 게으른 사람에게 적성인, 잘 맞는 일이 무엇이 있을까요. 그저 노는 것 뿐이겠죠. 2019년에는 게으름을 조금 이기고 싶어요! 완벽하게 이기진 못하겠지만 2018년 보다는 더 강해지고 싶어요. 게으름한테 그렇게 졌는데도 저만큼 일하고 공부했다면, 좀만 더 이기면 완전 많은걸 해내지 않을까요?^^ 다들 2019년 새해복 많이 받으시고 하려는 일 모두 열심히 할 수 있는 그런 멋있는 사람이 되길 바랍니다:)","link":"/2018/12/30/2018-12-30-remember2018-2/"},{"title":"03 블랙보드 신규 글 확인하기: MySQL 데이터베이스 연동","text":"게시글 링크 01 개발 준비: Selenium / Requests 개발환경 세팅하기 02 블랙보드 게시글 가져와서 출력하기: Selenium 기반 크롤링 엔진 제작 02-1 블랙보드 게시글 가져와서 출력하기: Requests, Session 기반 크롤링 엔진 제작 03 블랙보드 신규 글 확인하기: MySQL 데이터베이스 연동 04 블랙보드 신규 글 알림 기능 제공하기: SMTP 메일링 기능 추가 05 정기적으로 작동하게 만들기: Scheduling 기능 추가 여태까지 최종 결과물 소스코드 레포 06 블랙보드 알림 안드로이드 어플리케이션 만들기: 크롤링 엔진을 Django Rest Framework API 서버로 수정, 서버에 Deploy 07 블랙보드 알림 안드로이드 어플리케이션 만들기: Android 앱 개발, API 서버와의 연동 07-1 블랙보드 알림 챗봇 서비스 만들기: 카카오톡 챗봇 개발, API 서버와의 연동 블랙보드 알림 안드로이드 어플리케이션 결과물 레포 블랙보드 알림 챗봇 서비스 결과물 레포 블랙보드 알림 API 서버 결과물 레포 MySQL 모듈 사용하기 이번에는 앞서 만든 프로그램에 데이터베이스를 연결해보겠습니다. 데이터베이스를 연결하지 않으면 앞서 가져왔던 데이터 모두가 출력되게 됩니다. 따라서 데이터베이스에 모든 글들을 저장해놓고, 가져오는 글이 데이터베이스에 없을 경우에만 출력/메일로 전송하도록 하면 됩니다. 그런 후에 데이터베이스에 글을 저장하면 되는거죠! Python에는 MySQL을 사용할 수 있는 라이브러리가 존재합니다. 코드를 작성하기 전에 우선 데이터베이스를 설치, 세팅해야합니다. MySQL 설치/세팅/SQL 문법 등은 이 포스트에서 다루지 않겠습니다. 설치/세팅이 다 되었다면, 다음과 같이 mysql console을 활성화시킵니다. 123456$ where mysql&gt;&gt;&gt; usr/local/bin/mysql$ cd usr/local/bin$ ./mysql -u root -p&gt;&gt;&gt; Enter password: &lt;type your password&gt;mysql&gt; 데이터베이스/테이블 생성 이제 SQL 문을 작성해볼게요. 우리는 bb라는 데이터베이스를 생성하고, 이 데이터베이스에 announce 와 homework 라는 테이블을 선언하겠습니다. 두 테이블 모두 간단하게 post_id 만 저장할건데요, 그래서 SQL 문은 다음과 같이 간단해집니다. 1234mysql&gt; CREATE DATABASE bb;mysql&gt; USE bb;mysql&gt; CREATE TABLE announce (id varchar(20));mysql&gt; CREATE TABLE homework (id varchar(20)); 또한 pip / pycharm으로 pymysql을 설치해봅시다. 1$ pip install pymysql 여기까지 문제 없이 진행되었다면 MySQL에서 다룰 부분은 끝입니다. Python - MYSQL Adapter 코드 작성 이제는 Python에서 MySQL을 가져다 쓰는 코드를 작성할 차례입니다. 코드로 바로 확인해보겠습니다. …/BlackBoard-Tutorial/crawl-mysql.py 1234import pymysqlconn = pymysql.connect(host='localhost', user='root', password='PASSWORD', db='bb', charset='utf8') # MYSQL connectcurs = conn.cursor() # MYSQL 커서(탐색 도구) 위와 같이 작성하면 이제 Python에서 아까 만든 데이터베이스로의 접근이 자유로워집니다. 그럼 이제 bb 데이터베이스에 있는 announce와 homework를 모두 가져와 리스트로 저장해두겠습니다. 나중에 가져오는 포스트들이 이 리스트에 저장되어있는지 아닌지를 확인하며 작업할 예정입니다. …/BlackBoard-Tutorial/crawl-mysql.py 1234567891011121314announce_db = []homework_db = []sql = &quot;select * from announcement&quot;curs.execute(sql)rows = curs.fetchall()for a in rows: announce_db.append(a[0])sql = &quot;select * from homework&quot;curs.execute(sql)rows = curs.fetchall()for h in rows: homework_db.append(h[0]) 이제 데이터베이스에 있는 모든 post_id들이 리스트에 저장되었습니다. 그럼 post를 가져올 때마다 이 리스트에 있는지 확인을 해야겠죠? 확인해서 이미 있으면 pass, 없으면 출력/메일로 전송 단계를 거치고 데이터베이스로 insert 해야합니다. …/BlackBoard-Tutorial/crawl-mysql.py 123456789for ann in announcements: if ann.attrs['id'] not in announce_db: sql_ann = 'insert into announcement values(\\&quot;' + ann.attrs['id'] + '\\&quot;)' curs.execute(sql_ann) conn.commit() print(ann.attrs['id']) print(ann.text) print('---------------') homework도 마찬가지로 진행하면 돼요! 전체 코드는 crawl-mysql.py 에서 확인하실 수 있어요! 마치며 이번 시간을 통해 우리는 Python으로 MySQL을 제어하고, 이를 활용해 데이터베이스에 없는 포스트만 출력하도록 코드를 작성하였습니다. 데이터베이스에 대해 기본적인 내용만 알고 있으면 크게 어려운 내용은 아니었어요:) 이제는 데이터베이스가 연결되어있으니, 새로운 글이 올라올 때마다 print() 대신 내 메일로 보내주는 코드를 작성해야합니다. 다음시간엔 SMTP를 활용해 메일 보내기 코드를 작성해보겠습니다.","link":"/2019/02/12/2019-02-12-blackboard03-post/"},{"title":"04 블랙보드 신규 글 알림 기능 제공하기: SMTP 메일링 기능 추가","text":"게시글 링크 01 개발 준비: Selenium / Requests 개발환경 세팅하기 02 블랙보드 게시글 가져와서 출력하기: Selenium 기반 크롤링 엔진 제작 02-1 블랙보드 게시글 가져와서 출력하기: Requests, Session 기반 크롤링 엔진 제작 03 블랙보드 신규 글 확인하기: MySQL 데이터베이스 연동 04 블랙보드 신규 글 알림 기능 제공하기: SMTP 메일링 기능 추가 05 정기적으로 작동하게 만들기: Scheduling 기능 추가 여태까지 최종 결과물 소스코드 레포 06 블랙보드 알림 안드로이드 어플리케이션 만들기: 크롤링 엔진을 Django Rest Framework API 서버로 수정, 서버에 Deploy 07 블랙보드 알림 안드로이드 어플리케이션 만들기: Android 앱 개발, API 서버와의 연동 07-1 블랙보드 알림 챗봇 서비스 만들기: 카카오톡 챗봇 개발, API 서버와의 연동 블랙보드 알림 안드로이드 어플리케이션 결과물 레포 블랙보드 알림 챗봇 서비스 결과물 레포 블랙보드 알림 API 서버 결과물 레포 SMTP 모듈 사용하기 이번에는 앞서 만든 프로그램에 메일 보내기 기능을 추가해보겠습니다. 메일은 몇가지 라이브러리를 활용해 보내도록 만들 수 있고, 우리는 여기서 간단한 SMTP 라이브러리를 활용하여 진행해보겠습니다. SMTP는 네트워크 수업 때 배우는 프로토콜의 종류 중 하나인데, 메일 송수신에 관한 규약을 정리한 것입니다. 우리는 이 프로토콜을 Python에 맞게 제작한 기본 내장 라이브러리 smtplib를 활용할 예정입니다. 코드는 다음과 같아요. …/BlackBoard-Tutorial/crawl-smtp.py 12345678import smtplibfrom email.mime.text import MIMEText# Init Mail Servicesmtp = smtplib.SMTP('smtp.gmail.com', 587)smtp.ehlo()smtp.starttls()smtp.login('GMAIL_ID', 'GMAIL_PW') 위 코드를 통해 메일을 보내기 위한 세팅이 완료되었습니다. 새로운 글에 대한 메일 보내기 코드 작성 이제는 새로운 글을 찾을 때마다 메일을 보내면 됩니다! …/BlackBoard-Tutorial/crawl-smtp.py 123456789101112131415# 공지 가져오기announce_raw = driver.page_sourcesoup = bs(announce_raw, 'html.parser')announcements = soup.select('li.clearfix')[10:]announcements.reverse()for ann in announcements: if ann.attrs['id'] not in announce_db: sql_ann = 'insert into announcement values(\\&quot;' + ann.attrs['id'] + '\\&quot;)' curs.execute(sql_ann) conn.commit() msg = MIMEText(ann.text) msg['Subject'] = 'Announcement for ' + i[0].split('&amp;course_id=')[1] msg['To'] = get_target_mail() smtp.sendmail(get_gmail_id(), get_target_mail(), msg.as_string())smtp.quit() Homework도 마찬가지로 해주세요! 전체 코드는 crawl-smtp.py 에서 확인하실 수 있어요! 마치며 와 드디어 메일까지 보내주네요! 거의 모든 기능이 완료되었습니다:) 마지막으로 해볼건 Scheduling Code 작성입니다. 정기적으로 몇시간에 한번씩 코드가 돌아가도록 코드를 작성해볼게요:)","link":"/2019/02/12/2019-02-12-blackboard04-post/"},{"title":"05 정기적으로 작동하게 만들기: Scheduling 기능 추가","text":"게시글 링크 01 개발 준비: Selenium / Requests 개발환경 세팅하기 02 블랙보드 게시글 가져와서 출력하기: Selenium 기반 크롤링 엔진 제작 02-1 블랙보드 게시글 가져와서 출력하기: Requests, Session 기반 크롤링 엔진 제작 03 블랙보드 신규 글 확인하기: MySQL 데이터베이스 연동 04 블랙보드 신규 글 알림 기능 제공하기: SMTP 메일링 기능 추가 05 정기적으로 작동하게 만들기: Scheduling 기능 추가 여태까지 최종 결과물 소스코드 레포 06 블랙보드 알림 안드로이드 어플리케이션 만들기: 크롤링 엔진을 Django Rest Framework API 서버로 수정, 서버에 Deploy 07 블랙보드 알림 안드로이드 어플리케이션 만들기: Android 앱 개발, API 서버와의 연동 07-1 블랙보드 알림 챗봇 서비스 만들기: 카카오톡 챗봇 개발, API 서버와의 연동 블랙보드 알림 안드로이드 어플리케이션 결과물 레포 블랙보드 알림 챗봇 서비스 결과물 레포 블랙보드 알림 API 서버 결과물 레포 Scheduling 모듈 사용하기 이제는 주기적으로 내 코드가 반복되게끔 작성하면 됩니다. 반복의 경우 Scheduling을 사용하면 쉽게 해결할 수 있습니다. 우선 반복할 함수가 필요하므로 여태까지의 코드를 모두 함수로 묶습니다. 이후 다음 코드를 입력하여 Scheduling을 구현합니다. …/BlackBoard-Tutorial/crawl-complete.py 123456from apscheduler.schedulers.background import BlockingSchedulerprint('Scheduler start...')sched = BlockingScheduler()sched.add_job(main_func(), 'interval', hours=12)sched.start() 전체 코드는 crawl-complete.py 에서 확인하실 수 있어요! 마치며 드디어 모든 기능 작성이 완료되었습니다. 개발 완료!! 이제 잠시 쉬었다가, 실제 서비스를 개발 해볼까 해요. 앞서 아주 간단하게 말하긴 했지만, 우리가 여태까지 만든 프로젝트는 실제 서비스가 되기엔 많이 부족합니다. Selenium 자체적인 리소스 문제와 드라이버의 호환 등 아쉬운 점들이 있습니다. 그래서 우리는 이걸 Requests / Session 기반으로 조금 고쳐서 작성해야 합니다. 이는 천천히 수정해볼 예정이에요. 실제 서비스는 크게 두가지로 생각하고 있는데, 안드로이드 어플리케이션 혹은 챗봇 쪽으로 생각중입니다. 끝까지 읽어주셔서 감사합니다. 그럼 다들 즐거운 개발! 언제든 피드백 남겨주세요:)","link":"/2019/02/13/2019-02-13-blackboard05-post/"},{"title":"[매일 개발 프로젝트 1: 네모(네 모든 생각을 알려줘)]","text":"프로젝트 개요 네모 프로젝트(네 모든 생각을 알려줘)는 내가 묻고 싶은 나에 대한 질문지를 친구들에게 공유해서 익명의 답변을 얻는 웹 서비스입니다. 단번에 이해가 안되신다면 옛날 카카오스토리에서 유행하던 첫인상 써주기나 에스크를 생각하시면 이해가 쉬울거 같아요. 제가 중학교 다닐 때 쯤 카카오스토리가 유행했었는데 그 때 한창 하던게 친구들 첫인상과 관련된 50문답 같은거 하는거였거든요. 뭐 꼭 카카오스토리가 아니더라도 문답과 관련한 제품은 꽤 있잖아요? 근데 저만 그런건진 모르겠는데 카카오스토리 문답 시절에는 내가 얘꺼를 해준다 하는 느낌이라 익명이 아니었죠. 그래서 뭔가 솔직하게 하지는 못했던거 같아요. 누가 면전에 부정적인 얘기를 쓰겠어요ㅎㅎ.. 근데 저는 솔직한 답변을 원하거든요. 제가 이 프로젝트를 시작하게 된 가장 큰 이유는 나에 대한 주변인들의 객관적인 평가가 궁금해서였어요. 꽤 많은 사람들이 그런 생각 한번쯤은 했을거 같아요. 나 나름 괜찮게 생긴편인가?? 내 성격은 나름 재밌는 편일까? 나 너무 아싸 같은 이미지는 아닐까?? 제가 주변 신경을 좀 쓰는 편이다보니 전 이런게 진짜 미친듯이 궁금하더라구요. 근데 이걸 어떻게 직접 물어봅니까.. 어렵죠 그래서ㅎㅎ 그래서 익명으로 문답해주는 서비스가 있으면 좋겠다고 생각했고, 한참전부터 만드려고 했는데 이제야 시작을 하네요. 프로젝트 기능 &amp; UX 기본적으로 문답을 마치 설문지처럼 만들 수 있는 웹 서비스입니다. 너무 많으면 힘드니까 최대 10~15개 정도 질문만 만들 수 있도록 하고, 이거를 링크 형태로(에스크의 사례처럼) 공유할 수 있도록 할거에요. 일단 여기까지가 기본 프로토타입의 형태이자 목표입니다. 추가 예정인 기능 아무나가 아닌, 날 아는 사람이 답변할 수 있도록 하는 필터링 질문 단계(못풀면 아예 답변 못남기게) 문답을 해주는 사람들의 참여도를 높이기 위한 보상 시스템(문답 만든 사람이 기프티콘을 사서 상품으로 걸어놓고, 기간내 답변자들 중에 랜덤으로 추첨해서 증정) 그 외 또 추가할게 생각나면 적겠습니다. 예상 마감 기한 8월 중순 프로토 타입 배포(초중학생들 방학 끝나기 직전) 프로젝트 세부사항 언어: Python, HTML 프레임워크: Django, Bootstrap 배포: Heroku(프로토), AWS EC2(상용화) 프로젝트 기술 스택 선정 이유 일단 전 Django로 웹개발 하는게 제일 친숙합니다. 제일 빨리 만들 수 있는 툴이라고 생각해서 선정했고, Bootstrap의 경우도 쉽고 빠르게 UI를 구성할 수 있을거라 생각했습니다. 심지어 Bootstrap Studio라는 프로그램을 구매했는데, 이거 진짜진짜 편하고 멋있더라구요..!(안드로이드 스튜디오 Bootstrap 버전이라고 이해하심 됩니다.) 물론 SPA(Single Page Application)를 구성할 수 없어서 UX가 좋지 않겠지만.. 이런 문제 해결을 위해 추후에 개선 사항으로 프론트를 Vue.js로 재구성할 수 있으면 좋겠습니다. 하지만 당장은 거의 튜토리얼 따라하는 수준이라 패스.. 프로젝트 링크 네모 프로젝트 레포지토리 매일 한 줄 - 네모 프로젝트 일기쓰기","link":"/2019/07/08/2019-07-08-nemo-side-project/"},{"title":"00 Scrapy Tutorial","text":"게시글 링크 프로젝트 링크 시작하며 안녕하세요, TaeBbong 입니다. 이번 글에서는 Scrapy 공식 Document의 Tutorial을 번역 &amp; 정리해보겠습니다. 완벽한 번역보다는 개인적으로 공부한 것을 정리하는 느낌으로 작성할 것이며, 정확한 원문은 다음링크에서 확인할 수 있습니다. Scrapy Tutorial 이 글은 Scrapy 공식 Document Tutorial을 참고합니다. 이 튜토리얼은 Scrapy가 설치되어있음을 전제로 진행됩니다. 설치 가이드는 다음 링크에서 확인하실 수 있습니다. 이 튜토리얼에서는 quotes.toscrape.com에서 유명 작가들의 문장들을 스크랩할 예정입니다. 본 튜토리얼에서 진행할 일들은 다음과 같습니다: Scrapy 프로젝트 만들기 사이트를 크롤링하고 데이터를 추출할 Spider 생성하기 Scrape한 데이터를 내보내기 링크를 따라 재귀적으로 Spider 작동시키기 Spider Argument 사용하기 Project 생성하기! 프로젝트가 저장될 디렉토리에 터미널 등으로 접근하여 다음 명령어로 Scrapy 프로젝트를 생성합니다. 1$ scrapy startproject tutorial 이 명령어를 통해 tutorial이라는 폴더가 생성되었습니다. 이 폴더는 다음과 같은 구조를 가지고 있습니다. 12345678910tutorial/ scrapy.cfg # 배포 설정 파일 tutorial/ # 프로젝트의 파이썬 코드들이 존재하는 디렉토리 __init__.py items.py # items 정의 파일 middlewares.py # middleware 정의 파일 pipelines.py # pipelines 정의 파일 settings.py # setting 파일 spiders/ # Spider를 작성하는 디렉토리 __init__.py (역자) 위의 디렉토리 구조에서 spiders만 주로 작성하게 되며, 다른 파일들은 거의 수정하지 않습니다. 첫번째 Spider 만들기 Spiders는 Scrapy가 타겟 웹사이트(들)로부터 정보를 scrape할 수 있도록 우리가 정의하는 클래스입니다. 이는 scrapy.Spider의 subclass 형태이며, 초기 요청을 정의해야하고, 선택적으로 어떤 링크를 따라 진행할지, 혹은 어떻게 데이터를 파싱해서 가져올지에 대해 정의할 수 있습니다. quotes_spider.py라는 이름의 파이썬 파일을 다음과 같이 작성하여 spiders/ 디렉토리에 생성합니다. (역자) 주석으로 설명을 달았습니다. 12345678910111213141516171819import scrapyclass QuotesSpider(scrapy.Spider): name = &quot;quotes&quot; # scrapy 실행을 위한 spider의 고유 이름 def start_requests(self): # 일련한 requests을 return, spider의 시작점 설정 부분으로 세팅한 urls에 따라 자동으로 크롤링 시작 urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) # parse를 콜백으로 부름으로, 매 request마다 발생하는 response를 처리 def parse(self, response): # request마다 발생한 response를 처리하는 부분 page = response.url.split('/')[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) self.log('Saved file %s' % filename) (추가) starts_requests 생략하기 starts_requests 메소드는 다음과 같은 형태로 축약하여 사용할 수 있습니다. 123456789101112131415import scrapyclass QuotesSpider(scrapy.Spider): name = &quot;quotes&quot; start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): # request마다 발생한 response를 처리하는 부분 page = response.url.split('/')[-2] filename = 'quotes-%s.html' % page with open(filename, 'wb') as f: f.write(response.body) self.log('Saved file %s' % filename) (역자) 위와 같은 형태로 축약하면, spider 클래스에서는 자동으로 starts_urls라는 클래스 구성요소를 인식하여 start_requests 메소드를 기본값으로 선언, 작동하게 됩니다. (역자) parse 또한 마찬가지로 각 url의 request에 따라 콜백으로 지정이 되는데, 이 역시 parse가 scrapy의 기본 콜백 메소드이기 때문이며, 따로 지정하지 않아도 실행됩니다. Scrapy 실행하기 프로젝트의 가장 상위 디렉토리, 즉 scrapy.cfg 파일이 있는 디렉토리에서 다음 명령어를 입력해 실행합니다. 1$ scrapy crawl quotes 이 명령이 실행되면 우리가 지정한 spider의 name인 ‘quotes’가 실행되며, request를 타겟 url에 대해 보내게 됩니다. 선언한 로그가 정상적으로 print되면 잘 작동한 것입니다. 2개의 html 파일이 저장되면 정상적으로 작동한 것입니다. 데이터 추출하기 bash 환경에서 데이터 추출하는 연습을 해볼 수 있습니다. 터미널 등에서 다음 명령어를 입력해보세요. (단, url에 &amp; 등의 문자로 인자가 담긴 경우 bash 환경에서 잘 작동하지 않습니다.) 1$ scrapy shell 'http://quotes.toscrape.com/page/1/' 다음과 같이 실행됨을 확인할 수 있습니다. 1234567891011121314[ ... Scrapy log here ... ]2016-09-19 12:09:27 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://quotes.toscrape.com/page/1/&gt; (referer: None)[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x7fa91d888c90&gt;[s] item {}[s] request &lt;GET http://quotes.toscrape.com/page/1/&gt;[s] response &lt;200 http://quotes.toscrape.com/page/1/&gt;[s] settings &lt;scrapy.settings.Settings object at 0x7fa91d888c10&gt;[s] spider &lt;DefaultSpider 'default' at 0x7fa91c8af990&gt;[s] Useful shortcuts:[s] shelp() Shell help (print this help)[s] fetch(req_or_url) Fetch request (or URL) and update local objects[s] view(response) View response in a browser (역자) 위에 보시면 Available Scrapy objects라고 되어있는데, 이 부분에서 선택할 수 있는 Scrapy 객체들이 적혀있습니다. 이를 활용해 여러가지 기능을 확인해볼 수 있습니다. CSS를 기반으로 response object에서의 element를 골라볼 수 있습니다. 12&gt;&gt;&gt; response.css('title')[&lt;Selector xpath='descendant-or-self::title' data='&lt;title&gt;Quotes to Scrape&lt;/title&gt;'&gt;] 12&gt;&gt;&gt; response.css('title::text')[0].get()'Quotes to Scrape' (역자) 원문에서는 정규표현식 등으로 파싱하는 내용도 기술되어있지만, 이 부분은 생략하겠습니다. XPath로도 당연히 element를 골라볼 수 있습니다. 12&gt;&gt;&gt; response.xpath('//title/text()').get()'Quotes to Scrape' (역자) 이하 파싱을 활용해 각종 데이터를 추출, 정리하는 내용이 포함되어있습니다. 진행이 어려우신 초보 분들은 원문에서 코드를 확인해보세요! Spider 코드에서 데이터 추출하기 여태까지 Shell을 활용해 데이터를 추출해봤으며, 앞서 작성했던 Spider 객체 내에서도 데이터 추출을 적용해볼 수 있습니다. Scrapy Spider는 일반적으로 페이지에서 추출한 데이터들을 포함하고 있는 많은 Dictionary를 생성합니다. 이를 위해 yield 키워드를 활용할 것입니다. 1234567891011121314151617import scrapyclass QuotesSpider(scrapy.Spider): name = &quot;quotes&quot; start_urls = [ 'http://quotes.toscrape.com/page/1/', 'http://quotes.toscrape.com/page/2/', ] def parse(self, response): for quote in response.css('div.quote'): yield { 'text': quote.css('span.text::text').get(), 'author': quote.css('small.author::text').get(), 'tags': quote.css('div.tags a.tag::text').getall(), } 다음 결과를 얻을 수 있습니다. 12342016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://quotes.toscrape.com/page/1/&gt;{'tags': ['life', 'love'], 'author': 'André Gide', 'text': '“It is better to be hated for what you are than to be loved for what you are not.”'}2016-09-19 18:57:19 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://quotes.toscrape.com/page/1/&gt;{'tags': ['edison', 'failure', 'inspirational', 'paraphrased'], 'author': 'Thomas A. Edison', 'text': &quot;“I have not failed. I've just found 10,000 ways that won't work.”&quot;} 스크랩한 데이터 저장하기 Feed exports 방식이 데이터 저장할 때 가장 간단합니다. 다음 명령으로 간단하게 저장할 수 있습니다. 1$ scrapy crawl quotes -o quotes.json Scrapy는 인자로 들어온 파일에 덮어 쓰는 것이 아닌, 해당 파일에 append하기 때문에, 저 명령어를 기존 파일을 지우지 않고 여러번 쓰면 JSON 파일이 손상되니 주의해야 합니다. JSON Lines와 같은 다른 포맷도 사용할 수 있습니다. 작은 프로젝트에서는 데이터를 그냥 저장해도 괜찮지만, 좀 더 복잡한 프로젝트를 수행할때는 Item Pipeline을 쓰게 됩니다. 이는 project 내의 tutorial/pipelines.py 에서 설정할 수 있습니다. (역자) 이에 대한 자세한 내용은 추후 추가될 Item Pipeline 포스트에서 확인할 수 있습니다.","link":"/2019/04/01/2019-04-01-scrapy01-post/"},{"title":"작심삼일에 대한 연구: 과연 이번의 다짐은 성공할 것인가?","text":"시작하며: 언제나 작심삼일스러운 목표들.. 항상 무언가 시작하면 괜히 들떠서 목표들을 잡습니다. 뭐 독서라던지, 운동, 산책 같은 규칙적이고, 왠지 멋있을 것만 같은 그런 목표들 있잖아요. 저도 이런 목표 세우는거 참 좋아합니다. 이루는거 말고 세우는거요^^ 이게 참 처음에는 괜찮다 싶다가도 점점 피곤하고 일 많아지고 귀찮고 바빠지면 합리화와 함께 밀리더라구요. 저만 그런 건 아닐거라고 굳게 믿으며 위로를 합니다ㅎㅎ.. 작심삼일에 대한 연구 그런 작심삼일스러운 목표들을 어떻게 하면 꾸준히 이룰 수 있을 지 고민했어요. 사실 꼭 무언가 시작할 때 말고도 평소에 다양한 목표나 일이 있잖아요. 근데 이런 것들은 대부분 정리해보면 보상이 없어요. 자기계발, 미래를 위한 투자 뭐 이런 느낌 뿐?? 그에 비해 어떻게든 하게 되는 일들은 다 보상이나 안하면 주어지는 벌이 있죠. 외주, 학교 과제, 시험 같은 것들 말이에요. 결국 우린 보상 없는 일을 해야해요. 내 시간을 따로 내어서 말이죠. 이게 되게 억울하게? 느껴질 수도 있고 힘들게 느껴질 수도 있어요. 내가 매일 이렇게 고생하는데 왜 누구도 알아주지 않지? 이런 느낌으로 말이에요. 그래서 우리는 운동, 독서와 같은 목표를 잘 못 이루게 되는거에요. 작심삼일에 대한 연구 2 또 한가지의 난관은 목표를 세우면 뭔가 대단히 해야할거 같은 기분이에요. 참 사람 욕심이라는게, 기왕 내가 운동을 해야겠다 싶으면 매일 한두시간은 해야할거 같고, 기왕 독서를 하겠다 하면 하루에 1시간씩 해서 한달에 한권 정도는 끝내야할거 같고(책을 하도 안읽어서 감이 안오네요ㅎ) 이런 목표에 거는 기대치가 큰거 같다는 생각이 들었어요. 자기계발에 대한 성과를 마치 앞선 내용에서 말했던 보상으로 여기는거죠. 처음에는 재밌고 쉽게 달성합니다. 뭔가 이대로만 가면 보상을 얻을 수 있을거 같거든요. 근데 사람 인내심이 며칠 있으면 바닥이 나게 되죠. 내가 최근 며칠 이렇게 했는데 왜 안변하지? 변하는게 이상한거죠ㅇㅇ.. 우리가 산게 몇년인데 그 며칠 뭐 했다고 바뀌겠습니까. 결국 보상이 명확히 주어지지 않는다는 것, 그리고 눈에 보이는 성과를 급하게 기대하는 마음 이 두가지가 우리의 작심삼일을 만들어내는 핵심 원인으로 생각됩니다. 작심삼일에 대한 개인적 시도 저는 항상 작심삼일스러운 목표를 세워왔고, 실패해왔어요. 그때마다 항상 특별한 고민이나 시도는 하지 않았죠. 이번에는 다르지 않을까 하는 그런 막연한 기대감을 갖고 한번 시도해보고 싶은게 있어요. 바로 그날 할 일을 아주아주 작고 사소하게 잡아놓는거에요. 이를테면 사이드프로젝트 개발 10분, 운동 7분 매일하기 같은거요. 10분 10분 합해서 20분이면 자기 전, 씻기 전에 해도 충분하거든요. 안되겠다 싶으면 타이머라도 맞춰볼거에요. 10분이라는 시간 정도는 내가 충분히 참을 수 있을거에요 아마. 유튜브 요새 영상들 하나가 10분 남짓인데, 얼마나 시간 후딱 갑니까. 아마 엥 벌써 끝났어? 뭐 하지도 못했는데? 싶을거 같아요. 지금 이 글도 퇴근하고 와서 쓰는데 벌써 30분째 쓰고 있거든요. 이렇게 나름 지키기 쉬운 규칙을 만들고 매일 지키게만 하는 것. 당장 운동 효과가 어떻고 개발 진척이 안나가도 매일 지켰다는 것만으로 충분히 대단한 성과를 냈다고 생각해요. 아마 이 패턴으로 쭉 지내다보면 20분, 30분, 1시간씩 하게 될거에요.(아닐 수도 있어요ㅎㅎ..) 그럼 어느샌가 내가 원하던 모습이 되어있지 않을까요?ㅎㅎ 작심삼일 프로젝트 무튼 그래서 함 해보겠습니다!! 제가 잡은 목표는 네가지 정도인데요, 첫째, 매일 한 줄 - 인턴 출근 일기 작성하기 둘째, 10분 개발 - 사이드 프로젝트 개발하기 셋째, 매일 한 줄 - 사이드 프로젝트 일기쓰기 넷째, 7분 운동 - 매일 7분씩 운동하기 에휴 항상 이렇게 잡는데 뭐 얼마나 잘 될런지는 모르겠어요. 이론상 저거 다 하는데 22분 내외인데… 그래도 작심삼일 장점이 초반에 파이팅 넘치는거 아니겠습니까ㅎㅎ 꾸준히 함 잘 해볼게요! 다들 파이팅:)","link":"/2019/07/08/2019-07-08-threedays-post/"},{"title":"매일 한 줄 - 보이저엑스 인턴 출근 일기","text":"07/08(월) 첫 출근! 걱정 반 기대 반이었는데 이제는 기대만 넘치게된 하루에요:) 07/09(화) 적응기의 인턴은 너무 심심해요… 프로젝트 팀 선정이 참 고민됩니다 비주도적으로 일하지만 엄청 배우는 팀과 혼자서 모든걸 부딪히며 배워야 하는 팀(개인..) 07/10(수) 역시 심심했지만 동기들과 식사는 좋았고, 프로젝트 레포의 README에 오탈자가 있어 수정하는 풀리퀘를 보내서 뿌듯했는데 뭔가 너무 앞서나간 것처럼 보일까봐 걱정되었어요..! 07/11(목) 할게 없으니 너무너무 피곤해요ㅠㅠ 팀선택은 무난하게 하나 싶었는데 큰 난관에 부딪혀 걱정 중입니다:( 07/12(금) 혼자서 적당히 큰 프로젝트에 들어가게 되었어요! 원하던 프로젝트가 맞지만 괜히 걱정되기 시작했어요ㅎㅎ.. 07/15(월) 드디어 뭔가 일을 시작하는 듯 합니다..! 아직은 배우면서 잡일 중이지만.. 걱정도 많이 되고 기대도 됩니다ㅠㅠ 07/16(화) 오늘 처음으로 야근을 했습니다ㅎㅎ.. 들어와서 정말 다양한 경험을 하게 되네요! 잡무를 열심히 맡았는데 팀원분들이 칭찬 해주셔서 기분이 좋았습니다:) 07/17(수) 실수 연발하면서 조금은 위축되고 우울했던 오전이었습니다ㅠㅠ 오후에는 사수님과 친해지기 미션을 떠올리고 달성해야겠다고 생각했습니다! 07/18(목) 오늘은 사수분 옆에 딱 붙어서 많이 배웠습니다! 왠지 뭔가 할 수 있을 것만 같은 근거없는자신감이 생겼어요ㅎㅎ.. 에러 수정하고 빌드해서 배포하고.. 참 다양한 경험을 하고 있습니다! 07/19(금) 오늘은 여유롭다가 퇴근할 때 쯤 일이 몰아쳤어요ㅠㅠ 역시 퇴근 때 일 생기는건 국룰인가.. 금요일이 항상 기다려집니다ㅎㅎ 07/22(월) 주말의 휴식 덕에 상쾌한 월요일! 사수분 없이 혼자 개발했는데 간단한 기능 수정이랑 UI 수정이 생각보다 너무 잘돼서 기분이 좋았습니다:) 07/23(화) 오늘도 몇 가지 에러와 UI 수정을 혼자 힘으로(구글과 기존코드의 힘) 해냈습니다! 점점 적응되어가고 있다는 느낌과 뭔가 생각보다 잘 풀린다는 느낌을 받아 좋았습니다! 07/24(수) 환 사 수 영 오셨습니다ㅎㅎ 제가 짜 놓은 것들 대부분 잘 넘어갔고 오늘도 함께 여러 기능, UI 수정을 진행했습니다. 아직 미숙하다는 느낌이 많이 들었고, 그러면서도 평화로웠죠! 07/25(목) 오늘은 베타 출시! 하면서 여러가지 에러도 수정하고 그랬는데, 당연하지만 사수분은 척척 해결하시고 전 뭔가 멍하고 있었어서 앞으로 열심히 해야지 라는 생각을 했습니다. + 소고기 회식!! 07/26(금) 사수분이 퇴사하셨습니다!ㅠㅠ 입사 3주만에 PM이 되어버렸네요ㅎㅎ… 잘 할 수 있을지 모르겠지만 잘 해야지 어쩌겠습니까ㅎㅎ 07/29(월) 의문의 서버에러로 주말에 전화를 받고 월요일 아침 일찍 출근했습니다… 화난다.. 07/30(화) 서버 쪽 지식이 전무하여 시니어 분이 고치는걸 구경만 했습니다. 자괴감과 무력감이 몰려오는 하루였습니다ㅎㅎ 07/31(수) 어찌저찌 해결이 된거 같기도..? 모니터링 코드를 작성하여 슬랙으로 알람을 보내는 기능을 만들어 나름 뿌듯했습니다! 08/01(목) 혼자서 에러를 고치는 과정은 참 심심하고 외로운거 같아요.. 맞게 하고 있는지도 모르겠고.. 08/02(금) PM으로 진행하는 첫 주간 보고! 너무 떨렸지만 기분이 좋았습니다ㅎㅎ 하루 종일 구현하던거 퇴근 직전에 딱 되어서 너무 좋았습죠! 08/05(월) 오늘은 월급날~!!! 마음편히 노가다만 열심히 할 수 있어 꽤 편안한 하루였습니다:) 08/06(화) 막히는 부분을 해결하기 너무 어렵습니다ㅠㅠ 역시 남 코드 고치는 건… 제가 기초가 많이 부족하다는 것도 많이 느껴 공부를 조급하지 않게 기초부터 해야할 것 같습니다. 08/07(수) 오늘은 첫 반차 사용날!!! 반차를 쓴다는 사실만으로 행복해지는 하루였습니다. 08/08(목) 한참 고민하던 문제를 다른 분이 아주 간단하게 해결하시면 앞으로 나아갈 길이 많구나라고 새삼 느끼게 됩니다. 08/09(금) 이것저것 할 일이 정말 많은데, 능력이 부족해 너무 오래 걸리고 있습니다.. 이 쪽이랑 잘 안맞는 걸까요?? 08/12(월) 또 다시 다른 분 도움을 받아 원활히 해결했습니다.. 그래도 점점 뭔가 기본부터 공부해야겠다는 생각이 계속 들고 있어 다행입니다. 08/13(화) 오늘은 혼자서 여러가지 일을 해결할 수 있었어요! 역시 뭐든 잘 되면 일할 기분이 납니다ㅎㅎ 08/14(수) 첫 재택 근무를 해봤습니다!! 상당히 편하고 행복했습니다ㅎㅎ 앞으로 자주 해야겠어요. 08/15(목) 공휴일!! 08/16(금) 오늘에서야 뭔가 비로소 회사에 마음을 열 수 있었던 것 같아요! 일을 대하는 마음도 편해지고 생활 면에서도 많이 편해진 것 같아요. 08/19(월) 일을 위한 테스트를 위한 일.. 그래도 생각보다 잘돼서 나름 좋았습니다:) 08/20(화) 미팅이 있어 쫄았는데 게다가 해외 본사와의 미팅..! 몇 마디 못했지만 뭔가 두근두근 뿌듯했습니다. 08/21(수) 생각했던 것 만큼 일이 잘되어 뿌듯했습니다! 대신 코드를 이렇게 써도 되려나 싶기도 했어요ㅎㅎ.. 08/22(목) 오늘은 뭔가 혼자만의 시간을 갖고 싶어 오후 반차를 썼습니다! 여유로운 시간이군요ㅎㅎ 08/23(금) 뭔가 마음이 떠서 일이 그렇게 잘 되지는 않았어요. 역시 금요일…. 08/26(월) 오늘은 제일 쉬우면서 재밌는(할만한) 앱 UI 추가를 했습니다! 점점 회사에 녹아들고 있는 것 같아요. 08/27(화) 오늘부터 3일간 친한 동기 두명이 대회에 나가서 없어요ㅠ 게다가 오늘은 많은 분들이 휴가/재택하셔서 심심했습니다.. 08/28(수) 오늘도 역시 조금 심심했지만 그래도 할 일들이 꽤 있어서 적당히 심심한 듯 재밌게 잘 마무리 했습니다. 08/29(목) 반차 쓰는 날은 참 행복합니다ㅎㅎ 제게 하루 8시간은 너무 긴 것 같아요ㅠㅠ 08/30(금) 밀린 고객들의 피드백을 정리하고 이것저것 정리하는 시간을 가졌습니다. 드디어 개강이군요..! 09/02(월) 학교와 회사를 병행하니 참 피곤합니다ㅠㅠ 오늘 새 인턴분이 오셨는데 프로젝트에 관심을 많이 가져주셔서 참 기쁘면서도 일이 엄청 커질까봐 걱정도 됩니다:) 09/03(화) 첫 정식 출시를 진행했습니다..! 참 무섭네요ㅎ.. 사회생활 짬이 부족함을 느낀 하루였습니다. 09/04(수) 적당히 해볼만한 할 일이 있는게 제일 좋은 것 같아요:) 09/05(목) 항상 내 나름대로 구현하는 것들은 믿지 못하겠어요.. 주니어에게 있어 사수의 필요성을 느끼고 있습니다. 09/06(금) 오늘은 학교 가는 날! 이지만 오전에는 일 했습니다:) 당연하지만 제가 너무 부족한 것 같다고 또 느꼈습니다ㅠ 09/09(월) 오늘은 오전에 학교 갔다가 오후에 재택 근무했습니다! 재택은 참 힐링되는 이벤트입니다ㅎㅎ 09/10(화) 제 부족하고 조잡한 로직을 통해 이슈를 해결해보았습니다..! 빨리 추석이 왔으면 좋겠어요ㅠ 09/11(수) 추석이 드디어 다가왔습니다! 일찍 퇴근하는게 우리 회사만인줄 알았더니 다 그러네요ㅠ 09/16(월) ~ 09/19(목) 그냥그냥 지내고 있는 하루들이었습니다. 딱히 기억에 남지 않네요. 09/20(금) 학교 문제로 퇴사에 대한 고민을 대표님께 전달했습니다. 09/23(월) 퇴사가 확정되었습니다! 사람들을 만나며 정리를 하고 있습니다. 09/24(화) 회사 갔다가 학교 가는게 참 힘들지만 얼마 남지 않았습니다. 09/25(수) 인턴 동기들과 회식 했습니다! 뭔가 정말 끝나는 기분이네요:( 09/26(목) 재택근무를 하며 문서를 정리했습니다. 09/27(금) 이렇게 퇴사를 하게 되다니 참 아쉬우면서도 홀가분 하고 기분 좋았습니다! 이제 끝!^^","link":"/2019/07/08/2019-07-08-voyagerx-post/"},{"title":"[개발TIP&amp;기록] 웹 크롤링을 위해 Selenium Ubuntu 서버에 배포하기","text":"환경 Ubuntu 18.0.4 (AWS EC2 인스턴스) Chrome 74 들어가며 웹 크롤링을 전문으로 외주를 진행하면, Selenium을 정말 많이 쓰게 됩니다.(절대 웹 테스트용으로는 안쓰네요ㅎ..) 실 서비스에 항상 적합한 툴은 아니지만, 자주 안 돌려도 되거나, 찾을 데이터가 많지 않은 경우 종종 배포까지 사용하기도 합니다. Selenium을 서버에서 사용하려면 Chrome 및 Chromedriver를 서버에 세팅해야하는데, 초반에는 자료가 많이 없어 헤맸었습니다. 그래서 기록을 목적으로 설치 및 배포 방법을 정리해보려합니다. Chrome 설치 많이 놓치는 부분이 Chromedriver를 쓰려면 Chrome도 설치되어야 한다는 점입니다. Chrome을 Ubuntu에서 설치하려면 다음과 같은 명령어를 입력합니다. 12$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -$ sudo sh -c 'echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google-chrome.list' 위와 같은 명령어로 apt-get을 위한 준비를 진행합니다. 이후 다음 명령어를 입력해 실제 설치를 진행합니다. 12$ sudo apt-get update$ sudo apt-get install google-chrome-stable 이를 통해 안정화 버전의 크롬을 설치할 수 있습니다. **크롬 버전**을 확인해야합니다! 1$ google-chrome --version 현재 시점에는 74.x.x 버전으로 설치가 됩니다. 이 버전에 호환되는 Chromedriver를 다운로드 받아야합니다. Chromedriver 다운로드 다음 링크에서 버전에 맞는 Chromedriver를 찾으면 됩니다. Chromedriver 이 프로젝트에서는 74버전에 맞게 진행하겠습니다. 버전을 선택하면 OS 별로 다운로드 받을 수 있는 링크가 보이는 페이지로 이동하는데, 여기서 linux 링크를 오른쪽 마우스로 복사합니다. 이후 서버에서 다음과 같은 명령어로 다운로드 받습니다. 1$ wget https://chromedriver.storage.googleapis.com/74.0.3729.6/chromedriver_linux64.zip 다운로드된 압축파일을 풀면 됩니다! 압축파일을 풀기 위해 unzip을 설치합니다. 1$ sudo apt-get install unzip 압축을 풀어봅시다! 1$ unzip chromedriver_linux64.zip 압축을 풀면 같은 디렉토리에 chromedriver 파일이 생성된걸 볼 수 있습니다! 이를 프로젝트 폴더로 이동시켜서(본인이 설정한 path) 사용하시면 됩니다. 예시: Django 프로젝트에서 사용하기 Django에서 이를 연동하여 사용할 수 있습니다. 당연히 selenium을 설치해야겠죠? 가상환경에서 설치해봅시다. 1(myvenv) $ pip install selenium 배포할 때에는 실제로 크롬 창이 열릴 필요가 없죠! 그래서 headless 상태로 만들어서 돌려야합니다. 다음과 같이 코드를 작성해볼게요. 1234driver_path = os.path.join(os.path.dirname(__file__), 'chromedriver') # Chromedriver Path 가져오기options = Options() # Option 객체 생성options.headless = True # headless option True 설정driver = webdriver.Chrome(driver_path, options=options) # WebDriver 객체 생성 이제 설정이 완료되었습니다. 나머지는 로컬에서 작업하시는 것과 동일하기 때문에 바로 Selenium 프로젝트를 시작하시면 됩니다! Selenium이 꽤 무겁고, 시간도 오래걸려서 물론 서버에서 사용할 때 많은 주의를 기울여야 합니다.(이것 때문에 서버 한번 날렸..) 여기까지 Selenium을 Ubuntu 서버 환경에서 사용하는 방법을 알아보았습니다:)","link":"/2019/05/20/2019-05-20-selenium-deploy-post/"},{"title":"AWS Fargate 알아보기","text":"AWS Fargate란{: width=”100” height=”100”}Fargate를 이해하기 위해서는 컨테이너 오케이스트레이션에 대해 살짝 알아야 합니다.컨테이너라는게 명확히 이해하기는 어렵지만, 도커나 쿠버네티스를 생각하면 조금 더 쉽습니다.일반적으로 웹 서비스를 배포할 때 백엔드 설정을 직접 해주게 됩니다.이 직접 설정해야하는 부분을 단계별로 자동화할 수 있는데, 얼마만큼 자동화하느냐에 따라 IaaS, PaaS, SaaS 등으로 나뉘어집니다.","link":"/2019/07/15/2019-07-12-fargate-post/"},{"title":"AWS Lambda 알아보기","text":"AWS Lambda란{: width=”100” height=”100”}AWS에 Lambda를 검색해서 들어가면 이벤트에 대한 응답으로 코드를 실행하고 자동으로 기본 컴퓨팅 리소스를 관리하는 서버리스 컴퓨팅 서비스입니다. 라고 나와있네요.상당히 딱딱한 문장 구성이라 이 문장만으로는 이해가 잘 안됩니다.우선 서버리스라는 말이 나오는데, 이에 대해 알아볼 필요가 있습니다. 서버리스(Serverless), 말 그대로 서버가 없다는 얘기입니다.일반적으로 우리가 서비스를 만든다고 하면 서버가 필요하잖아요? 클라이언트에서 필요한 데이터 접근이나 기능적 처리를 해주는 백엔드의 서버가 필요하고, php, django, spring 등 많은 프레임워크로 이를 코딩해왔습니다. Lambda는 FaaS(Function as a Service)입니다. 서버 없이 함수만 등록해서 해당 함수를 호출하는 방식으로 굴러 간다고 이해하면 될거 같습니다.예시를 들어보면, 게시판에 사진을 유저가 업로드 한다고 생각해볼게요.운영자는 이 사진을 원본과 썸네일 버전 둘 다 저장을 해야겠죠.대체로 이런 경우 서버에서 사진을 S3(AWS 저장소 서비스)에 업로드 하고, 사진을 썸네일로 만들어서, 다시 S3에 저장을 합니다.근데 사진을 올리는 기능이 여러 파트에 포함되어있다면(자유게시판, 공지게시판, 프로필 수정 등) 그 파트 구현하는 부분에 매번 썸네일 만드는 기능이 포함되어야겠죠.이럴 때 Lambda는 어떤 식으로 해결해주냐면, 사진이 저장되는 S3를 Lambda가 계속 모니터링하도록 설정합니다.어떻게든 S3에 사진이 저장이 되면(어느 경로든) Lambda는 이를 감지하고 미리 지정된 코드(함수)를 수행합니다. 이 경우에서는 썸네일을 만들어서 S3에 저장하는 기능이겠죠.이러한 시스템을 직접 구현할 필요 없이, Lambda가 해당 작업만을 전담해서 처리해주게 됩니다.AWS 서비스인만큼 이용한만큼만 요금을 지불합니다. API Gateway란{: width=”100” height=”100”}API Gateway는 라우터 정도로 이해하고 있습니다./user라는 API 요청이 왔을 때 이를 어디로 보낼지 제어하고, 요청을 바꿔서 연결할 수도 있는 등 다양한 활용법이 있는 AWS 서비스라고 합니다. 뜬금없이 API Gateway가 나온 이유는 Lambda랑 함께 활용하면 서버 구현 없이 Restful API를 만들 수 있기 때문입니다! 자세한 방법은 저보단 이 글을 참고하시는게 나을거 같습니다.간단하게 아키텍처만 첨부하자면 이런 느낌인거 같아요.어떻게든 이해해보자면, API Gateway에 전달된 API 요청들은 Gateway에서 라우팅되어 각각의 기능들이 매칭되어있는 Lambda로 전달되고, Lambda는 지정된 기능을 수행하여 그 결과를 반환하게 될겁니다. 정리하며서버를 직접 구현하는게 때때로 어렵고, 복잡하며 신경써야할게 많습니다.그런 대체 방안으로 *aaS가 존재하고, 이들은 복잡하고 귀찮은 작업들을 대신 해주기로 유명합니다. 나름 GUI이기도 하구요.허나 AWS를 몇 번 써보면, 이것도 공부할 일이고 충분히 할일이 많다는 것을 알 수 있습니다.개인적으로는 코드를 쓰는게 AWS 서비스 이용보다 쉬운 거 같다는 생각이 듭니다.하지만 적절히 활용할 수 있도록 많은 시도를 해보고, 익숙해진다면 최대한의 효율을 낼 수 있는 말그대로 도구가 되지 않을까 싶습니다.도구라는게 원래 적절한 곳에 써야 편하지, 소잡는 칼로 닭잡으려하면 얼마나 무겁고 힘들겠습니까.최대한 저도 AWS의 도구를 익혀보고, 이를 가장 적절히 쓸 수 있는 곳에서 적절히 쓰려고 노력하려 합니다.","link":"/2019/07/12/2019-07-12-lambda-post/"},{"title":"[Django Rest Framework로 게시판 처음부터 끝까지 만들기]","text":"프론트엔드와 백엔드요즘 웹 개발의 흐름은 react.js, vue.js의 JS 기반 프론트엔드 프레임워크가 지배하고 있다고 느껴집니다. 웹 개발을 할 때 react.js나 vue.js 없이 개발하는 사례가 거의 없는거 같아요. (프론트를 거의 안해봐서 잘 모르겠지만) 워낙 쉽게 모든 걸 할 수 있고, 기존 jquery, js로 구현하기 어려웠거나 불편했던 것의 해결, 유지 보수 등이 좋아 인기가 많은 것 같습니다. 이러다 보니 웹을 만드는 프로젝트를 할 때(비즈니스 레벨 혹은 학교 팀 프로젝트 레벨이더라도) 프론트엔드 프레임워크를 담당하는 사람(들)이 꼭 있습니다. 짧은 식견으로는 라우팅이나 기존 새로고침을 통해 제공해야 했던 데이터의 변경을 프론트엔드에게 넘겨주고, 백엔드에서는 그저 DB에 접근해 요청에 맞는 데이터를 제공하는 API 서버를 개발하도록 된 것으로 생각됩니다. 이렇게 개발하게 되면 얻을 수 있는 장점은 프론트엔드 개발자와 백엔드 개발자 간 협업이 상당히 쉬워진다는 것입니다. 프론트엔드 개발자는 UI나 로직을 구현하면 되고, 필요한 데이터가 발생한다면 백엔드 개발자가 만들어놓은 API를 가져다 쓰면 됩니다. 혼자 개발을 한다면 이 둘을 굳이 분리할 필요가 없겠지만, 개발자 둘이 한 몸이 되지 않는 이상 코드 공유부터 수정, 테스트까지 정말 불편한 일들이 많을 것입니다. 특히 백엔드의 API 서버는 단지 웹에만 적용되지 않고, 앱이나 여러 http 프로토콜로 통신하는 프로젝트에 그대로 적용될 수 있어 활용성이 정말 좋습니다. REST API가 API 개발에서 제일 대표적인 방법이며, 이에 대한 설명은 다른 분들이 더 잘해주셔서 이를 첨부하겠습니다. Redhat - API란? REST API 제대로 사용하기 왜 Django Rest Framework??REST API를 개발하기 위한 프레임워크는 정말 다양합니다. 최근 정말 인기 있는 node.js의 express, python의 flask, java의 spring boot까지. 정말 다양한 언어로 개발된 프레임워크들이 있고 모든 분야가 그렇듯 다 경험 해보고 본인이 쓰기 편한 것으로 개발하시면 됩니다. 저 또한 express, flask, 그리고 Django Rest Framework 이렇게 세 종류를 경험해보았고 이 중에서 Django Rest Framework를 주 활용 스택으로 선택한 이유는 다음과 같습니다. Django! Django의 가장 큰 장점은 &quot;Django스럽다&quot; 라고 말할 수 있습니다. 이게 무슨 뜻이냐 하면, 개발해야하는 여러 대표적인 기능들이 거의 모두 이미 개발되었으니 그냥 가져다 쓰면 된다는 것입니다. 처음엔 오히려 이것저것 복잡해서 낯설고 친해지는데 오래 걸릴 수 있지만, 나중에는 이미 구현된 이 기능 하나하나에 정말 큰 고마움을 느낄 것입니다. Django의 강력한 ORM Django를 사용하다보면 내가 데이터베이스를 쓰고 있던가 싶을 정도로 개발자가 쓰기 좋게 잘 추상화 되어있습니다. 상당히 python 스럽고 직관적인 방법으로 데이터에 접근, 필터링할 수 있으며, 다른 프레임워크로는 얻을 수 없는 경험이라고 생각됩니다. 프로젝트 소개본 프로젝트에서는 Django Rest Framework를 활용하여 게시판을 만들어보겠습니다. 게시판을 만들면서 당연히 CRUD를 구현하게 될 것이고, 이 과정을 시작하면서 최대한 다양한 방법을 제시하고 그 중에서 한 가지 방법으로 통일하여 쭉 작업할 예정입니다. 또한 항상 프로젝트의 시작이 되면서 은근 귀찮고 어려운 회원 가입 / 로그인 인증도 개발할 예정입니다. 당연히 코드도 깃헙을 통해 공유드립니다. 기왕이면 해당 프로젝트 하나만 쭉 따라하면서 공부해도 Django Rest Framework를 여러분들이 마스터 할 수 있기를 바랍니다:) 포스트 링크 01 Django Rest Framework 개발 환경 세팅 02 Django Rest Framework, Serializer, View 개념 익히기 03 DRF로 회원 가입 / 인증 구현하기, 유저 모델 확장하기","link":"/2019/11/04/2019-11-04-drf-project/"},{"title":"AWS S3 알아보기","text":"AWS S3란{: width=”100” height=”100”}S3(Simple Storage Service)는 Key-Value 개념의 파일 저장소입니다.Key-Value 개념은 Python의 딕셔너리에서 접할 수 있는데, 파일명을 Key, 파일을 Value로 이해하면 됩니다.일반적인 파일시스템들의 개념과 다르다고 하는데, 일반적인 파일시스템을 몰라서 정확한 차이는 모르겠지만, MYSQL과 MongoDB 정도의 차이로 이해하고는 있습니다.한 파일 당 최대 5TB까지 가능하고, 접근할 때 REST/HTTP 방식의 프로토콜만 지원합니다.파일 저장소이다보니 코드를 작성하거나 뭐 이런 부분이 없을 거라(아마도) 개념적인 부분만 몇개 보렵니다. 버킷: 객체(파일)들을 묶은 최상위 디렉토리로, 버킷 단위로 지역 설정이나 인증, 접속 제한이 가능합니다. 버전 관리: 각 파일별로 버전관리가 가능하여 참 좋을거 같습니다.","link":"/2019/07/12/2019-07-12-s3-post/"},{"title":"[02 Django Rest Framework, Serializer, View 개념 익히기]","text":"Hello World 코드 설명# (수정) 추후 설명하는 그림을 첨부할 예정입니다. 1GET 127.0.0.1:8000/api/hello/ 지난 시간에 해당 주소로 요청을 보내면 hello world를 print하는 api를 만들었습니다. 각 단계를 다시 따라가보며 세부적인 내용을 살펴보겠습니다. 첫번째 단계는 views.py를 작성하는 것입니다. 현재 사용하고 있는 view의 구조는 함수 기반 뷰, 이른바 FBV 입니다. 123456789# api/views.pyfrom rest_framework.response import Responsefrom rest_framework.decorators import api_view# Create your views here.@api_view(['GET']) # 해당 함수 view에서 처리할 http 메소드def HelloAPI(request): return Response(&quot;hello world!&quot;) # http response 형태로 return views.py에서 다룬 내용은 그냥 Django에서 다룬 것과 크게 다를 것 없이, 요청을 받아 해당 요청에 대한 응답을 제공하는 기능을 합니다. 오늘 배우게 될 serializer와 함께 하면 어떻게 할 수 있는지 이따 알아보겠습니다. 그 다음은 api/urls.py 입니다. 12345678# api/urls.pyfrom django.urls import path, includefrom .views import HelloAPIurlpatterns = [ path(&quot;hello/&quot;, HelloAPI),] 크게 특별할 것 없이 view에 있는 HelloAPI를 가져와 url로 할당시켰습니다. path 사용을 권장한다는 것을 지난 시간에 말씀드렸습니다. Serializer?Serializer는 Django Rest Framework에서 나온 새로운 요소입니다. 사전적 의미는 직렬화 하는 무언가 정도로 볼 수 있습니다. 직렬화라는 말이 와닿지 않는데, 이는 간단하게 파이썬 데이터를 JSON 타입의 데이터로 변환해준다 정도로 생각하시면 됩니다. 기본적으로 웹에서 통신을 할 때, 즉 데이터를 주고 받을 때는 어느 정도 정해진 포맷이 있습니다. 대표적인 타입이 JSON이나 XML인데, 대부분의 REST API에서는 JSON으로 주고 받기 때문에 우리는 그냥 JSON만 잘 알고 있으면 됩니다:) 정확한 의미의 직렬화는 Django 프로젝트에서 내가 만든 모델로부터 뽑은 queryset, 즉 모델 인스턴스를 JSON 타입으로 바꾸는 것입니다. 기존 일반적인 Django에서의 폼과 같은 개념이라고 비유하는 경우가 있는데, 저는 그냥 Django 모델을 JSON으로 변환하기 위한 모양 틀 정도로 이해하고 있고 그게 제일 깔끔한 것 같습니다! 간단한 코드로 예를 들어보겠습니다.(게시판 프로젝트 코드가 아닙니다) 123456789# test/models.pyfrom django.db import models# 설명만을 위한 모델로, 상당히 대충 작성 되었습니다:)class Person(models.Model): id = models.IntegerField() name = models.CharField() phone = models.CharField() addr = models.CharField() email = models.CharField() 123456789# test/serializers.pyfrom rest_framework import serializersfrom .models import Person# ModelSerializer 뒤에서 설명합니다.class BasePersonSerializer(serializers.ModelSerializer): class Meta: model = Person fields = ('id', 'name', 'phone', 'addr') 위에서 보시면 Person이라는 모델을 models.py에 만들고, BasePersonSerializer라는 시리얼라이저를 serializers.py에 만들었습니다.(앱 내에 파일을 생성하셔야 합니다) 이게 어떤 뜻이냐면, “내가 만든 Person이라는 모델에서 데이터를 뽑아서 응답으로 보낼텐데, 응답의 형태 중 하나인 Base 형태를 BasePersonSerializer라고 정의할게!” 라는 뜻입니다. 자세히 보시면 모델에는 email도 정의되어있는데 Base의 fields에는 email이 없습니다. 이는 개발자가 정의한 Base 형태에는 email이 없다는 뜻이죠. 그러면 사람의 이메일 정보를 요청할 때 쓸 수 있는 시리얼라이저는 어떻게 만들 수 있을까요? 123456789# test/serializers.pyfrom rest_framework import serializersfrom .models import Person# ModelSerializer 뒤에서 설명합니다.class EmailPersonSerializer(serializers.ModelSerializer): class Meta: model = Person fields = ('id', 'email') 이렇게 만들어 볼 수 있습니다. 이제 우리는 한 가지 깨달음을 얻을 수 있습니다. 시리얼라이저는 응답으로 보낼 데이터의 형태를 정해주는 하나의 틀과 같구나! Serializer - View 연결하기여기까지 잘 이해되셨다면 이후 단계에서는 더 잘 이해될 것입니다. 이제는 그럼 views.py에 실제로 시리얼라이저가 어떻게 사용되는지 알려드리겠습니다. 12345678910111213141516171819# test/views.pyfrom rest_framework.response import Responsefrom rest_framework.decorators import api_viewfrom .models import Personfrom .serializers import BasePersonSerializer, EmailPersonSerializer@api_view(['GET'])def PersonAPI(request, id): now_person = Person.object.get(id=id) serializer = BasePersonSerializer(now_person) return Response(serializer.data)# =&gt; id=1에 대해 리턴된 Response: {'id': 1, 'name': '태뽕', 'phone': '01012345678', 'addr': '주소주소'}@api_view(['GET'])def EmailAPI(request, id): now_person = Person.object.get(id=id) serializer = EmailPersonSerializer(now_person) return Response(serializer.data)# =&gt; id=1에 대해 리턴된 Response: {'id': 1, 'email': 'email@email.com'} 어떠신가요 바로 이해가 되셨나요? 제가 시리얼라이저를 변환기, 모양 틀로 설명드린게 이런 맥락이었습니다. 각 view에서 무언가 데이터를 요청할 때, 지금 예시에서는 PersonAPI는 사람에 대한 데이터, EmailAPI에서는 이메일에 대한 데이터를 요청할 때 각각 원하는 형태로 응답해줘야 합니다. 하지만 모델은 하나니 필요한 데이터만 골라서 보내줘야겠죠? 이 역할을 해주는게 시리얼라이저라고 이해하시면 됩니다. 내가 보낼 데이터(now_person, 모델 인스턴스입니다)를 시리얼라이저에 넣어 변환시키고 그 데이터를 응답으로 보내주는 것이 시리얼라이저 - 뷰 연동 개념입니다. ModelSerializer앞서 진행한 코드에서 한가지 설명 안하고 그냥 넘어간 코드가 있습니다. 바로 시리얼라이저를 선언할 때 사용한 serializers.ModelSerializer입니다. 123456# test/serializers.py# ModelSerializer 뒤에서 설명합니다.class BasePersonSerializer(serializers.ModelSerializer): class Meta: model = Person fields = ('id', 'name', 'phone', 'addr') 원래 가장 기본적인 형태의 시리얼라이저 선언 방법은 serializers.Serializer를 상속 받는 것입니다. 이 형태로 선언하면 다음과 같이 코드를 작성할 수 있습니다. 1234567891011121314151617181920# test/serializers.pyclass BasePersonSerializer(serializers.Serializer): id = serializers.IntegerField() name = serializers.CharField() phone = serializers.CharField() addr = serializers.CharField() def create(self, validated_data): &quot;&quot;&quot; 검증한 데이터로 새 `Person` 인스턴스를 생성하여 리턴합니다. &quot;&quot;&quot; return Snippet.objects.create(**validated_data) def update(self, instance, validated_data): &quot;&quot;&quot; 검증한 데이터로 기존 `Person` 인스턴스를 업데이트한 후 리턴합니다. &quot;&quot;&quot; ... ... return instance 위에서 작성한 시리얼라이저보다 훨씬 길고 복잡해졌죠? 원래 시리얼라이저를 선언할 때는 데이터 형태에 대한 필드(앞선 방법에서는 fields, 지금은 일일이 선언), 그리고 그 데이터를 어떻게 처리할건지에 대한 메소드가 필요합니다. 이 메소드는 create나 update와 같이 이미 선언되어있는 메소드를 재작성하는 것이며, views.py에서 직접 create나 update를 해야 할 것을 시리얼라이저에서 대신 해주는 것이라고 보면 됩니다. 대략 그런 역할을 선언해주고 필드에 대한 상세적인 내용을 직접 정의해야 했다면 serializers.ModelSerializer는 이 내용들을 알아서 해준 형태의 시리얼라이저라고 보시면 됩니다. 따라서 웬만하면 저희는 간편한 ModelSerializer의 형태로 선언하겠습니다. 마치며여태까지 Django Rest Framework에서 가장 중요한 개념인 시리얼라이저에 대해 배웠습니다. 코드 작성 없이 보면서 따라가느라 조금 지루하셨을텐데, 다음 포스트에서는 이렇게 열심히 공부한 개념을 실제 게시판 프로젝트에 적용하겠습니다. 가장 첫 단계인 회원 인증부터 시작합니다:)","link":"/2019/11/06/2019-11-06-drf-2-post/"},{"title":"[01 Django Rest Framework 개발 환경 세팅]","text":"시작하며Python: 3.6.3IDE: VS Code 본 포스트는 Django 튜토리얼은 해보았다는 가정 하에 작성되었습니다.만약 Django가 아예 처음이라면 장고걸스튜토리얼을 먼저 해보시길 바랍니다. Django 개발 환경 세팅원활한 Django 개발을 위해서는 파이썬 가상환경 세팅이 필요합니다. 다음과 같은 명령어로 venv 생성 및 패키지 설치, 초기 세팅을 진행합니다. 1234567$ mkdir Rest-CRUD$ cd Rest-CRUD$ python3 -m venv venv$ source venv/bin/activate$ (venv) pip install django$ (venv) django-admin startproject mysite .$ (venv) python manage.py startapp api 여기까지 진행했을 때 디렉토리 구조는 다음과 같습니다. 12345- Rest-CRUD - api - manage.py - mysite - venv 여기에 추가로 djangorestframework 패키지와 django-rest-knox를 설치하겠습니다.djangorestframework는 당연하게도 Django Rest Framework를 위함이며, django-rest-knox는 추후에 진행할 회원가입/인증에 사용될 패키지입니다. 12$ (venv) pip install djangorestframework$ (venv) pip install django-rest-knox 당장 쓸 패키지가 아닌데도 미리 설치한 이유는 settings.py를 한번에 건드리기 위함입니다(귀찮을테니ㅎㅎ). 123456789101112# mysite/settings.pyALLOWED_HOSTS = ['127.0.0.1']INSTALLED_APPS = [ ... 'api', 'rest_framework', 'knox',]TIME_ZONE = 'Asia/Seoul' 위와 같이 앱을 등록하고 각종 설정을 마치면 migration 단계가 남았습니다. 12$ (venv) python manage.py makemigrations$ (venv) python manage.py migrate 여기까지 세팅이 완료되었다면 실행해봅시다! 1$ (venv) python manage.py runserver 실행하여 로컬호스트 주소로 들어가면 잘 아는 Django 기본 화면이 나오게 됩니다. 여기까지는 그냥 Django 프로젝트랑 다를 바 없기 때문에 그래도 아주 간단한 api 하나 만들고 마치도록 하겠습니다. 1GET 127.0.0.1:8000/api/hello/ 해당 주소로 요청을 보내면 hello world를 print하는 api를 만들겠습니다. 첫번째 단계는 views.py를 작성하는 것입니다. view를 작성하는 방법에는 여러가지가 있고 추후에 정리하겠으며, 지금은 그냥 하셔도 됩니다. 1234567891011# api/views.pyfrom rest_framework import viewsets, permissions, generics, statusfrom rest_framework.response import Responsefrom rest_framework.views import APIViewfrom rest_framework.decorators import api_view# Create your views here.@api_view(['GET'])def HelloAPI(request): return Response(&quot;hello world!&quot;) 그 다음 api/urls.py 파일을 만들겠습니다. 12345678# api/urls.pyfrom django.urls import path, includefrom .views import HelloAPIurlpatterns = [ path(&quot;hello/&quot;, HelloAPI),] 마지막으로는 mysite/urls.py에 url을 등록하겠습니다.(참고) urls.py에서 urlpatterns를 작성하는 방법이 최신버전부터 기존의 정규표현식으로 작성되던 url 기반에서 path 기반으로 변경되었으며 되도록 이 방식을 따르길 권장합니다. 123456789# mysite/urls.pyfrom django.urls import path, includefrom django.contrib import adminurlpatterns = [ path(&quot;admin/&quot;, admin.site.urls), path(&quot;api/&quot;, include(&quot;api.urls&quot;)) ] 이제 실행시키고, 127.0.0.1:8000/api/hello/ 로 접속하시면 다음과 같은 화면을 볼 수 있습니다. 와 처음 보는 형태의 화면이죠? Django Rest Framework에서 기본적으로 제공하는 이 화면은 api 형태의 요청에 대한 응답을 다음과 같이 표시해줍니다. api 테스트 툴 대신 충분히 사용할 만한 기능입니다. 여기까지 아주 간단하게 Django Rest Framework에 대한 감 잡기 및 설정까지 마쳤습니다. 다음 포스트에서는 위의 코드에 대한 조금 더 자세한 설명과 view를 작성하는 여러 방법에 대해 다뤄보겠습니다.","link":"/2019/11/05/2019-11-05-drf-1-post/"},{"title":"[03 DRF로 회원 가입 &#x2F; 인증 구현하기, 유저 모델 확장하기]","text":"들어가며# (수정) 추후 설명하는 그림을 첨부할 예정입니다. 지난 시간에는 DRF에서 가장 중요한 개념인 시리얼라이저를 이해하고 어떻게 뷰와 작성하는지를 보았습니다. 이번 글에서는 DRF로 토큰 기반 회원 인증 / 가입 및 로그인을 구현해보도록 하겠습니다. 진행에 앞서 토큰 기반 인증에 대해 알 필요가 있습니다. 해당 개념에 대해서는 다음 블로그 링크를 첨부하는 것으로 넘어가겠습니다. 쉽게 알아보는 서버 인증 1편 - 이호연 블로그 또한, 요즘 서비스에서 소셜 인증을 안 쓸 수 없기 때문에 추후에 소셜 인증으로 해당 포스트를 그대로 다시 작성해보겠습니다. django-rest-knox?우리가 앞서 설치한 패키지인 django-rest-knox는 사용자 당 여러 개의 토큰을 지원하고 여러 보안 기술을 제공합니다. 앞서 설정했던 것처럼 settings.py의 INSTALLED_APPS에 knox를 넣어주셨다면, 아래 내용을 settings.py에 추가해야 합니다. 123456# mysite/settings.py...REST_FRAMEWORK = { &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;: (&quot;knox.auth.TokenAuthentication&quot;,),}... 시리얼라이저 작성다음 단계는 시리얼라이저 작성입니다. 12345678910111213141516171819202122232425262728293031323334353637# api/serializers.pyfrom rest_framework import serializersfrom django.contrib.auth.models import Userfrom django.contrib.auth import authenticate# 회원가입class CreateUserSerializer(serializers.ModelSerializer): class Meta: model = User fields = (&quot;id&quot;, &quot;username&quot;, &quot;password&quot;) extra_kwargs = {&quot;password&quot;: {&quot;write_only&quot;: True}} def create(self, validated_data): user = User.objects.create_user( validated_data[&quot;username&quot;], None, validated_data[&quot;password&quot;] ) return user# 접속 유지중인지 확인class UserSerializer(serializers.ModelSerializer): class Meta: model = User fields = (&quot;id&quot;, &quot;username&quot;)# 로그인class LoginUserSerializer(serializers.Serializer): username = serializers.CharField() password = serializers.CharField() def validate(self, data): user = authenticate(**data) if user and user.is_active: return user raise serializers.ValidationError(&quot;Unable to log in with provided credentials.&quot;) 다른 시리얼라이저는 다 ModelSerializer로 작성하여 간단하게 처리하였고, 로그인의 경우 연결되는 모델이 없기 때문에 그냥 Serializer로 작성하였습니다. 뷰 작성다음은 views.py를 작성하겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# api/views.pyfrom rest_framework import viewsets, permissions, generics, statusfrom rest_framework.response import Responsefrom rest_framework.views import APIViewfrom rest_framework.decorators import api_viewfrom knox.models import AuthTokenfrom .serializers import CreateUserSerializer, UserSerializer, LoginUserSerializer# Create your views here.@api_view([&quot;GET&quot;])def HelloAPI(request): return Response(&quot;hello world!&quot;)class RegistrationAPI(generics.GenericAPIView): serializer_class = CreateUserSerializer def post(self, request, *args, **kwargs): if len(request.data[&quot;username&quot;]) &lt; 6 or len(request.data[&quot;password&quot;]) &lt; 4: body = {&quot;message&quot;: &quot;short field&quot;} return Response(body, status=status.HTTP_400_BAD_REQUEST) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) user = serializer.save() return Response( { &quot;user&quot;: UserSerializer( user, context=self.get_serializer_context() ).data, &quot;token&quot;: AuthToken.objects.create(user), } )class LoginAPI(generics.GenericAPIView): serializer_class = LoginUserSerializer def post(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) user = serializer.validated_data return Response( { &quot;user&quot;: UserSerializer( user, context=self.get_serializer_context() ).data, &quot;token&quot;: AuthToken.objects.create(user)[1], } )class UserAPI(generics.RetrieveAPIView): permission_classes = [permissions.IsAuthenticated] serializer_class = UserSerializer def get_object(self): return self.request.user 이번 뷰는 generic 기반 클래스 뷰로 작성되었습니다. 우선 함수 기반 뷰에서 클래스 기반 뷰로 바뀌면서 수정된 점은 앞서 데코레이터로 미리 http 메소드를 정의해주었던 것을 클래스 안으로 넣었다는 것이 있습니다. 또한 제네릭 뷰의 경우에는 기본적인 기능을 모두 포함하는 뷰로, 자세한 설명은 추후에 첨부하겠습니다. url 설정마지막으로 url을 설정하면 완료됩니다. 12345678910# api/urls.pyfrom django.urls import path, includefrom .views import HelloAPI, RegistrationAPI, LoginAPI, UserAPIurlpatterns = [ path(&quot;hello/&quot;, HelloAPI), path(&quot;auth/register/&quot;, RegistrationAPI.as_view()), path(&quot;auth/login/&quot;, LoginAPI.as_view()), path(&quot;auth/user/&quot;, UserAPI.as_view()),] 123456789# mysite/urls.pyfrom django.urls import path, includefrom django.contrib import adminurlpatterns = [ path(&quot;admin/&quot;, admin.site.urls), path(&quot;api/&quot;, include(&quot;api.urls&quot;)), path(&quot;api/auth&quot;, include(&quot;knox.urls&quot;)),] 여태까지 내용 확인해보기백엔드 API 테스트를 위해 Insomnia 라는 툴을 다운 받아 사용할 수 있습니다. 여러가지 편한 기능이 있으니 사용하시면 좋고, 아니면 그냥 기본 제공 웹 페이지에서 진행해도 됩니다. 회원 가입이나 로그인의 경우 POST 요청으로 보내면 되며 다음과 같이 요청을 보내면 됩니다. - 회원가입 - 로그인 Django 기본 유저 모델 확장하기여기까지 진행한 회원 모델은 Django에서 기본적으로 제공하는 유저 모델입니다. 하지만 실제로 사용하고 싶은 유저 모델은 포인트나 주소 등 여러 부가적인 정보가 들어갈 수 있는 유저이어야 합니다. 따라서 기본 유저 모델을 확장해야 하는데, 확장하는 방법에는 여러가지가 있습니다. Django의 사용자 모델을 수정해보자! 그중에서 제일 간단한 방법인 “프로필 모델 생성 후 one-to-one 연결” 방법을 사용하겠습니다. Profile 모델 생성모델은 다음과 같이 정의하겠습니다. 내용 외 필요한 컬럼이 있다면 추가하시면 됩니다. 12345678910111213141516171819202122232425262728# api/models.pyfrom django.db import models# Create your models here.from django.contrib.auth.models import Userfrom django.db.models.signals import post_savefrom django.dispatch import receiverclass Profile(models.Model): user = models.OneToOneField(User, on_delete=models.CASCADE) user_pk = models.IntegerField(blank=True) email = models.EmailField(max_length=500, blank=True) nickname = models.CharField(max_length=200, blank=True) point = models.IntegerField(default=0) like = models.CharField(max_length=200, blank=True) phone = models.CharField(max_length=200, blank=True)@receiver(post_save, sender=User)def create_user_profile(sender, instance, created, **kwargs): if created: Profile.objects.create(user=instance, user_pk=instance.id)@receiver(post_save, sender=User)def save_user_profile(sender, instance, **kwargs): instance.profile.save() 여기서 @receiver로 작성된 함수들은 User 모델로부터 post_save라는 신호, 즉 User 모델 인스턴스 생성에 맞춰 Profile 모델 인스턴스 또한 함께 생성하라는 것입니다. 이로 인해 여러분이 처음 유/저를 생성하고 username과 password만 입력해도 해당 사용자에 대한 Profile 인스턴스가 함께 생성 됩니다. Profile Serializer 생성다음은 Profile 모델에 대한 시리얼라이저를 만들어보겠습니다. 기본적으로 프로필 정보 조회에 필요한 프로필 ModelSerializer가 필요합니다. 123456# api/serializers.py# 프로필 시리얼라이저class ProfileSerializer(serializers.ModelSerializer): class Meta: model = Profile fields = (&quot;user_pk&quot;, &quot;nickname&quot;, &quot;phone&quot;, &quot;email&quot;) Profile View 생성시리얼라이저를 만들었으니 뷰를 생성할 때입니다. 이번 뷰는 앞선 회원 관련 뷰와 동일하게 제네릭 뷰의 UpdateAPIView를 사용하며, 이로 인해 별도의 로직 작성 없이 간편하게 Update 기능을 구현할 수 있습니다. 12345# api/views.pyclass ProfileUpdateAPI(generics.UpdateAPIView): lookup_field = &quot;user_pk&quot; queryset = Profile.objects.all() serializer_class = ProfileSerializer Profile url 설정언제나 마지막 단계는 urls.py입니다. 프로필 업데이트에 대한 url을 제공하면 되며, 다음과 같이 작성할 수 있습니다. 123456789101112# api/urls.pyfrom django.urls import path, includefrom .views import HelloAPI, RegistrationAPI, LoginAPI, UserAPI, ProfileUpdateAPIurlpatterns = [ path(&quot;hello/&quot;, HelloAPI), path(&quot;auth/register/&quot;, RegistrationAPI.as_view()), path(&quot;auth/login/&quot;, LoginAPI.as_view()), path(&quot;auth/user/&quot;, UserAPI.as_view()), path(&quot;auth/profile/&lt;int:user_pk&gt;/update/&quot;, ProfileUpdateAPI.as_view()),] (번외) admin에 Profile 등록Django의 어드민 페이지에서 Profile 모델의 데이터를 보고 싶다면 admin.py에 등록해야 합니다. 또한 Profile 모델은 User 모델에 종속되어 있는 상황으로 User 인스턴스에 Profile 인스턴스가 포함되어 있는 형태로 보기 위해 다음과 같이 코드를 작성하여 등록합니다. 12345678910111213141516171819202122# api/admin.pyfrom django.contrib import admin# Register your models here.from django.contrib.auth.admin import UserAdmin as BaseUserAdminfrom django.contrib.auth.models import Userfrom .models import Profileclass ProfileInline(admin.StackedInline): model = Profile can_delete = False verbose_name_plural = &quot;profile&quot;class UserAdmin(BaseUserAdmin): inlines = (ProfileInline,)admin.site.unregister(User)admin.site.register(User, UserAdmin) 결과 확인하기이제 모든 개발을 마쳤으니 Profile 기능을 확인할 차례입니다. Insomnia를 활용하여 테스트 해보겠습니다. Django에서 update 기능을 사용할 때는 PUT 메소드로 요청을 보내야 합니다. - User 생성 요청 - Profile 수정 요청 이제 어드민 페이지에서 확인해보겠습니다. 위처럼 superuser 외에 생성한 testuser1이 보이며, 이렇게 나오며 프로필 수정 또한 잘 된 것을 확인할 수 있습니다. 마치며여태까지 회원 가입 / 로그인 관련 API를 작성하였습니다. 사실 이렇게 하면 백엔드에서 할 역할은 얼추 끝이지만, 실제 웹 사이트를 만들어보지 않으면 이게 어떻게 되는지 이해할 수 없기 때문에 다음 시간에는 번외편으로 아주아주 간단한 프론트를 만들어서 실제로 회원가입하고 로그인하는 것을 구현해보겠습니다.","link":"/2019/11/07/2019-11-07-drf-3-post/"},{"title":"[0X 회원 가입&#x2F;로그인 웹 프론트 만들기 with HTML&#x2F;CSS&#x2F;JS]","text":"들어가며지난 시간에 회원 가입 / 로그인 관련 API를 작성하였습니다. 이번 시간에는 번외편으로 아주아주 간단한 프론트를 만들어서 실제로 회원가입하고 로그인하는 것을 구현해보겠습니다. HTML 페이지 구성하기","link":"/2019/11/11/2019-11-11-drf-4-post/"},{"title":"수집광 개발자가 키보드를 덕질할 때","text":"수집광본인은 수집광이다. 크게 덕질하거나 엄청 열정적인 관심 분야가 많지 않지만, 뭔가 모아야 하고 수집하고 싶은 것들이 있으면 정말 모든 걸 다 모으기 위해 노력한다. 어렸을 때 부터 만화책을 참 많이 봐왔는데, 나와 동생의 수집 방식은 정말 달랐다. 동생은 그림이 좋거나 특히 좋아하는 책을 한 두 권 정도 구입하는 반면, 본인은 꼭 1권부터 산다. 그 시리즈의 끝까지 다 사야 직성이 풀리는 타입이며, 다 못 모을거면 아예 사지 말자는 마음으로 쉽사리 만화책을 구매할 수는 없었다. 수집도 돈이 있어야 한다. 어렸을 때는 만화책을 살 돈이 없으니 못샀지만, 용돈으로 유희왕 카드 정도는 다 모을 수 있었다. 또 부모님을 졸라 당시의 탑블레이드 팽이들을 나오는 족족 구매하여 수집했었다. 그러다 스스로 돈을 처음 벌기 시작한 대학교 1학년 때, 본인은 하스스톤이라는 게임에 푹 빠져 과외로 번 돈 대부분을 투자해 모든 카드를 모았고, 지금도 확장팩이 나올 때마다 웬만한 건 다 모으려고 하고 있다. (하스스톤에 여태 이정도 썼다..ㅎㅎ) 최근까지는 나노블럭에 관심을 갖고 많이 모아놨으며, 물론 비싼 가격 탓에 완벽과는 거리가 멀지만 본인이 만족할 만큼 모았다고 여겨져 참 뿌듯하다. 키보드, 개발자, 덕질그러던 중 이제는 키보드의 세계에 빠져버렸다. 본인은 자취하던 시절부터 쭉 개발 환경 세팅을 여러 번 바꿔왔고, 데스크탑 + 맥북 구조에서 맥북 + 모니터, 키보드와 모니터 케이블만 바꿔끼며 맥북 + 데스크탑 + 모니터의 구조를 번갈아가며 사용했었다. 이 구조는 치명적인 단점이 있다. 맥북 + 모니터는 기껏 사놓은 데스크탑을 쓰지 못하며, 케이블을 바꿔끼는 건 정말정말 귀찮다. 데스크탑 + 맥북 구조는 그나마 편하지만 맥북 프로 2017의 고질적인 키보드 문제로 점점 사용하기 불편해져왔다. 그러던 중 멀티 페어링 기능의 블루투스 키보드라는 개념을 처음 알게 되었고, 이를 통해 키보드의 세계에 입문하였다. 그전까지는 추상적으로 기계식과 아닌 키보드 정도로만 알고 있었는데, 이제 얼추 어디서 키보드 얘기하면 낄 정도는 된 것 같다. 서론이 중구난방했지만 본 포스트에서 하고 싶은 말은 본인이 사용해온 키보드의 역사이다. 역사인 만큼 앞으로 계속 추가될 예정이다. (금전만 허락한다면..) 아이온코리아 PLANTIUM KB-324 제품 링크 처음 갖게 된 개인 키보드이다. 소프트웨어 마에스트로 수료식 때 이벤트에 참여해 쪽팔림을 감수하며 얻어낸 키보드이다. 기계식 키감의 키보드라고 광고하는 이 키보드는 플런저 스위치 기반의 키보드이다. 플런저는 멤브레인 방식, 즉 컴퓨터 실에서 사용하던 그 키보드 방식의 응용버전으로, 기계식 키보드처럼 키감을 극대화시킨 방식의 스위치이다. 물론 실제 기계식 스위치와는 느낌이 많이 다르다. 아무튼 이 키보드를 얻고 쓸 일이 없어 방치하다가, 데스크탑을 맞추고 처음 써보게 되었는데, 의외로 쓸 만 했다. 물론 기계식 키감 덕분에 ^^ 소리는 꽤 컸고, 키캡(키보드 버튼)이 전반적으로 너무 커서 조금은 불편했다. 또한 19키 동시 입력을 지원한다고 했지만 본인 손이 문제인지 카트할 때 키 씹히는 현상이 많이 일어났었다. 개발용으로 쓰기에도 뭔가 아쉬운 느낌의 키감이랄까? 아무튼 공짜로 얻은 만큼 편하게 썼고, 꽤 뽕을 뽑은 가성비 괜찮은 키보드였다. 웨이코스 씽크웨이 CROAD C604 체리미엄 PBT 측각 한영 게이밍 키보드 (적축) 제품 링크 그 전까지는 개발할 때는 주로 맥북만 써왔고, 맥북만 쓸 때 굳이 키보드를 연결할 필요가 없었어서 키보드에 대한 관심이 없었다. 그러던 중 인턴으로 입사한 보이저엑스에서 입사 하자마자 개인 키보드를 10만원 이하로 장만하라는 (물론 퇴사 시 반납) 말에 부랴부랴 알아보다가 디자인도 그렇고 회사의 요구인 적축까지 맞는 모델인 웨이코스 CROAD C604를 찾아 구매하였다. 우선 구매 전 제일 마음에 들었던 건 깔끔한 검은 색 디자인과 측각이었다. 심플함의 극에 달하는 블랙 원톤 디자인에, 각인이 키캡 위가 아닌 측면에 배치되어 있는 측각까지. 생긴게 정말 마음에 들었다. 도착을 하고 처음 썼을 때는 조금 당황스러웠다. 정통 체리 적축을 사용하고 있는 이 모델은 제대로 된 기계식 키보드를 한 번도 써보지 못한 내게 나름의 충격을 주었다. 스치기만 해도 입력이 되는 낮은 키압과, 피씨방에서 만나왔던 기계식 키보드와 달리 서걱서걱한 이 느낌은 적응하는데 꽤 시간을 쓰게 했다. 확실히 적축은 사무용 정도로 쓰기 좋은 제품인 것 같다. 코시 KB3139BT 멀티 페어링 블루투스 키보드 제품 링크 퇴사를 했고, 한동안 개발을 쉬었다. 그러다보니 맥북과 데스크탑을 동시에 사용하는 일이 줄었는데, 점점 늘어나는 과제에 이 개발환경을 한 번 더 바꿔야겠다고 생각했다. 그래서 큰맘 먹고 애플 매직 트랙패드 2를 구매했다. 맥북 스탠드와 함께 말이다. 이러다보니 키보드가 절실했고, 상식적으로도 내 책상에 키보드가 두 대나 되면 밥먹으면서 컴퓨터 보기 참 불편하겠다 싶었다. 이 와중에 멀티페어링 블루투스 키보드의 존재를 처음 알게 되었다..! 멀티페어링 블루투스 키보드는 내가 원하던 조건 그 자체였다. 하나의 키보드로 블루투스 연결을 통해 동시에 여러 기기와 사용할 수 있었고, 맥북과 데스크탑 두 대와 사용하기 정말 최적이었다. 곧 다가오는 생일 선물로 여자친구에게 기계식 멀티페어링 블루투스 키보드를 사달라고 말해두고(ㅎㅎ) 그 전까지 이 멀티페어링의 감동을 느끼고 싶어 최대한 싸고 괜찮은 제품을 찾아보았다. 로지텍 K380이 관련 제일 유명한 제품이었지만, 이상하게 디자인이 땡기지 않았고, 어차피 금방 쓰고 다른 키보드 쓸 건데 그냥 싸고 이쁜거 쓰자는 마음으로 코시의 제품을 골랐다. 이 제품은 우선 애플의 블루투스 키보드와 상당히 유사하게 생긴 디자인 컨셉으로, 내 책상과 참 어울리겠다 싶었다. 실제 사용해보니 우선 키보드 방식은 펜타그래프 방식으로, 그냥그냥 쓸 만 했다. 예전 맥북 프로 키보드 느낌보다 조금 더 멤브레인에 가까운 느낌이랄까..? 블루투스 전환도 상당히 괜찮고 사용성이 정말 좋다. 물론 잠시 아무 것도 누르지 않고 있으면 연결이 끊기기는 하지만, 그래도 가격과 내 사용 목적을 생각하면 정말 괜찮은 키보드라고 생각한다. COX CK87 레드/그레이 게이트론 갈축 제품 링크 블랙프라이데이 행사로 4만원 대에 판매하고 있어 (너무) 고민 없이 질렀다.. 유선 키보드이기도 하고 큰 메리트가 없음에도 가격이 너무 착해서 일단 질러봤는데, 아마 어떻게든 처분되지 않을까 싶다ㅎㅎ.. 우선 해당 키보드는 87키의 텐키리스 제품이다. 그동안 항상 풀배열 키보드만 쓰다가 텐키리스의 컴팩트함에 반해 꼭 사고 싶었는데, 텐키리스의 공간 효율은 분명한 장점이 있는 것 같다. 본인은 우측의 숫자배열이랑 엔터키를 꽤 자주 써서 적응이 좀 필요하긴 하지만, 분명히 텐키리스 제품은 그런 강점이 있다. 게이트론 축에 대해 궁금해서, 또 갈축에 대해서도 궁금해서 구매해봤는데, 축의 느낌 자체는 나쁘지 않다. 체리 축을 기준으로 말한다면 적축보다는 청축에 가까운 느낌이 들었다. 게임용으로 쓰기 나쁘지 않은 키보드였다. 하지만 개인의 목적에 대해 생각한다면, 기기 두대를 동시에 사용해야한다는 요구 사항을 만족할 수 없었기 때문에, 메인 키보드로 활용되기엔 부족하여 해당 키보드는 장롱으로 들어갔다.. 혹 3만원에 해당 키보드를 사고 싶은 사람은 댓글을 달면 되겠다ㅎㅎ 웨이코스 씽크웨이 블루투스 턴 BK620 웨이코스 씽크웨이 블루투스 턴 BK620 웨이코스 씽크웨이 CROAD X58 PBT 염료승화냥 108키 키캡 (다크 그레이) 기다리고 기다리던 생일 선물이다! 너무 노래를 불러 미안했지만ㅎㅎ.. 기계식 + 블루투스 + 멀티페어링의 조건을 모두 맞춘 제품이다. 심지어 가격도 7만원 이하라 지금 나에게 딱인 제품일 것이라 생각하여 받고 기분이 참 좋았다. 해당 키보드는 오테뮤 적축이다. 키캡은 기본적으로 ABS이지만 아래의 PBT 염료 승화냥 키캡을 구매하여 전부 교체하였다. 키캡 교체 영상 우선 축과 키감에 대해서 먼저 말해보자면 오테뮤 적축에 대한 걱정이 많았는데 생각보다 너무 마음에 들었다. 적축 특유의 서걱거림, 너무 잘 눌리는 것이 없었고 오히려 적축답지 않은 느낌의 묵직함과 클릭감이 있었다. 물론 키캡 교체 때문에 더 그럴 수 있지만, 생각보다는 무거운 느낌 덕분에 도리어 괜찮다는 느낌을 받았다. 블루투스 기능은 살짝 아쉬운 부분이라면 멀티페어링 기기 전환 시 시간이 꽤 오래 걸린다는 것이다. 앞서 사용해봤던 코시의 제품은 F1 ~ F4 키 하나만 누르고 13초 내로 전환이 되었는데, 본 제품은 Fn + F1 ~ F4 를 짧게(1초) 한 번, 길게(35초) 한 번 눌러야 전환이 된다. 키를 하나만 눌러도 되는 것이 아닌 두개를 눌러야 한다는 것, 그리고 탭이 아닌 꾹 누르고 있어야 한다는 것이 비교적 불편한 부분이었다. Fn + F1 ~ F4를 F1 ~ F4로 매핑할 수 있는 방법만 찾는다면 분명 더 편해질 것이다. 그 외의 부분은 정말 만족스럽다. 우선 하우징의 완성도, 디자인의 완성도 및 알루미늄의 묵직함이 정말 기대 이상이었고, 제품을 사진으로 봤을 때보다 훨씬 고급스럽다. LED도 고급스러운 분위기가 있으며, 볼 때마다 만족감에 웃음이 지어지는 그런 제품이다. (PS. 염료승화냥 키캡 또한 너무 커엽다..) To Be Continue..아직도 주시하고 있는 제품들이 많다. 돈이 없어 못 사고 있지만 추후 돈이 여유로워진다면 또 하나를 얻을 수 있지 않을까 기대 중이다.","link":"/2019/11/22/2019-11-22-dev-keyboards-post/"},{"title":"알고리즘 vs 프레임워크,무엇을 공부해야하는가","text":"커뮤니티 단골 질문, 알고리즘과 개발 프레임워크 중 무엇을 공부해야할까요?","link":"/2020/01/23/2020-01-23-algorithm-framework-md/"},{"title":"[무작정 플러터 강의노트] 01 네비게이션 탭이 있는 앱 프로젝트 구조 설정하기","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// lib/main.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/widget/bottom_bar.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget { _MyAppState createState() =&gt; _MyAppState();}class _MyAppState extends State&lt;MyApp&gt; { TabController controller; @override Widget build(BuildContext context) { return MaterialApp( title: 'Bbongflix', theme: ThemeData( brightness: Brightness.dark, primaryColor: Colors.black, accentColor: Colors.white, ), home: DefaultTabController( length: 4, child: Scaffold( body: TabBarView( physics: NeverScrollableScrollPhysics(), children: &lt;Widget&gt;[ Container( child: Center( child: Text('home'), ), ), Container( child: Center( child: Text('search'), ), ), Container( child: Center( child: Text('save'), ), ), Container( child: Center( child: Text('more'), ), ), ], ), bottomNavigationBar: Bottom(), ), ), ); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// lib/widget/bottom_bar.dartimport 'package:flutter/material.dart';class Bottom extends StatelessWidget { @override Widget build(BuildContext context) { return Container( color: Colors.black, child: Container( height: 50, child: TabBar( labelColor: Colors.white, unselectedLabelColor: Colors.white60, indicatorColor: Colors.transparent, tabs: &lt;Widget&gt;[ Tab( icon: Icon( Icons.home, size: 18, ), child: Text( '홈', style: TextStyle(fontSize: 9), ), ), Tab( icon: Icon( Icons.search, size: 18, ), child: Text( '검색', style: TextStyle(fontSize: 9), ), ), Tab( icon: Icon( Icons.save_alt, size: 18, ), child: Text( '저장한 콘텐츠 목록', style: TextStyle(fontSize: 9), ), ), Tab( icon: Icon( Icons.list, size: 18, ), child: Text( '더보기', style: TextStyle(fontSize: 9), ), ), ], ), ), ); }}","link":"/2020/03/21/2020-03-21-bbongflix-lec01-post/"},{"title":"[무작정 플러터 강의노트] 02 홈 화면에 상단 바 추가하기","text":"12345678910# pubspec.yamlflutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # To add assets to your application, add an assets section, like this: assets: - images/bbongflix_logo.png 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// lib/main.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/screen/home_screen.dart';import 'package:netflix_clone_lecture_note/widget/bottom_bar.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget { _MyAppState createState() =&gt; _MyAppState();}class _MyAppState extends State&lt;MyApp&gt; { TabController controller; @override Widget build(BuildContext context) { return MaterialApp( title: 'Bbongflix', theme: ThemeData( brightness: Brightness.dark, primaryColor: Colors.black, accentColor: Colors.white, ), home: DefaultTabController( length: 4, child: Scaffold( body: TabBarView( physics: NeverScrollableScrollPhysics(), children: &lt;Widget&gt;[ HomeScreen(), Container( child: Center( child: Text('search'), ), ), Container( child: Center( child: Text('save'), ), ), Container( child: Center( child: Text('more'), ), ), ], ), bottomNavigationBar: Bottom(), ), ), ); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// lib/screen/home_screen.dartimport 'package:flutter/material.dart';class HomeScreen extends StatefulWidget { _HomeScreenState createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { @override void initState() { super.initState(); } @override Widget build(BuildContext context) { return TopBar(); }}class TopBar extends StatelessWidget { @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.fromLTRB(20, 7, 20, 7), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Image.asset( 'images/bbongflix_logo.png', fit: BoxFit.contain, height: 25, ), Container( padding: EdgeInsets.only(right: 1), child: Text( 'TV 프로그램', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '영화', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 14), ), ), ], ), ); }}","link":"/2020/03/21/2020-03-21-bbongflix-lec02-post/"},{"title":"[무작정 플러터 강의노트] 05 홈 화면에 원형 이미지 &#x2F; 사각형 이미지 슬라이더 위젯 추가하기","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// home_screen.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/widget/box_slider.dart';import 'package:netflix_clone_lecture_note/widget/carousel_slider.dart';import 'package:netflix_clone_lecture_note/widget/circle_slider.dart';class HomeScreen extends StatefulWidget { _HomeScreenState createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { List&lt;Movie&gt; movies = [ Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), ]; @override void initState() { super.initState(); } @override Widget build(BuildContext context) { return ListView( children: &lt;Widget&gt;[ Stack( children: &lt;Widget&gt;[ CarouselImage(movies: movies), TopBar(), ], ), CircleSlider(movies: movies), BoxSlider(movies: movies), ], ); }}class TopBar extends StatelessWidget { @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.fromLTRB(20, 7, 20, 7), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Image.asset( 'images/bbongflix_logo.png', fit: BoxFit.contain, height: 25, ), Container( padding: EdgeInsets.only(right: 1), child: Text( 'TV 프로그램', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '영화', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 14), ), ), ], ), ); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// circle_slider.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';class CircleSlider extends StatelessWidget { final List&lt;Movie&gt; movies; CircleSlider({this.movies}); @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.all(7), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('미리보기'), Container( height: 120, child: ListView( scrollDirection: Axis.horizontal, children: makeCircleImages(context, movies), ), ), ], ), ); }}List&lt;Widget&gt; makeCircleImages(BuildContext context, List&lt;Movie&gt; movies) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; movies.length; i++) { results.add( InkWell( onTap: () {}, child: Container( padding: EdgeInsets.only(right: 10), child: Align( alignment: Alignment.centerLeft, child: CircleAvatar( backgroundImage: AssetImage('images/' + movies[i].poster), radius: 48, ), ), ), ), ); } return results;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344// box_slider.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';class BoxSlider extends StatelessWidget { final List&lt;Movie&gt; movies; BoxSlider({this.movies}); @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.all(7), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('지금 뜨는 콘텐츠'), Container( height: 120, child: ListView( scrollDirection: Axis.horizontal, children: makeBoxImages(context, movies), ), ) ], ), ); }}List&lt;Widget&gt; makeBoxImages(BuildContext context, List&lt;Movie&gt; movies) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; movies.length; i++) { results.add(InkWell( onTap: () {}, child: Container( padding: EdgeInsets.only(right: 10), child: Align( alignment: Alignment.centerLeft, child: Image.asset('images/' + movies[i].poster), ), ), )); } return results;}","link":"/2020/03/23/2020-03-23-bbongflix-lec05-post/"},{"title":"[무작정 플러터 강의노트] 03 영화 모델 만들고 더미 데이터 생성하기","text":"123456789101112# pubspec.yaml# The following section is specific to Flutter.flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # To add assets to your application, add an assets section, like this: assets: - images/bbongflix_logo.png - images/test_movie_1.png 12345678910111213141516// lib/model/model_movie.dartclass Movie { final String title; final String keyword; final String poster; final bool like; Movie.fromMap(Map&lt;String, dynamic&gt; map) : title = map['title'], keyword = map['keyword'], poster = map['poster'], like = map['like']; @override String toString() =&gt; &quot;Movie&lt;$title:$keyword&gt;&quot;;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// lib/screen/home_screen.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';class HomeScreen extends StatefulWidget { _HomeScreenState createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { List&lt;Movie&gt; movies = [ Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), ]; @override void initState() { super.initState(); } @override Widget build(BuildContext context) { return TopBar(); }}class TopBar extends StatelessWidget { @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.fromLTRB(20, 7, 20, 7), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Image.asset( 'images/bbongflix_logo.png', fit: BoxFit.contain, height: 25, ), Container( padding: EdgeInsets.only(right: 1), child: Text( 'TV 프로그램', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '영화', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 14), ), ), ], ), ); }}","link":"/2020/03/21/2020-03-21-bbongflix-lec03-post/"},{"title":"[무작정 플러터 강의노트] 04 홈 화면에 이미지 캐로셀 슬라이더 위젯 추가하기","text":"12345# pubspec.yamldependencies: flutter: sdk: flutter carousel_slider: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// lib/screen/home_screen.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/widget/carousel_slider.dart';class HomeScreen extends StatefulWidget { _HomeScreenState createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { List&lt;Movie&gt; movies = [ Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), Movie.fromMap({ 'title': '사랑의 불시착', 'keyword': '사랑/로맨스/판타지', 'poster': 'test_movie_1.png', 'like': false }), ]; @override void initState() { super.initState(); } @override Widget build(BuildContext context) { return ListView( children: &lt;Widget&gt;[ Stack( children: &lt;Widget&gt;[ CarouselImage(movies: movies), TopBar(), ], ) ], ); }}class TopBar extends StatelessWidget { @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.fromLTRB(20, 7, 20, 7), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Image.asset( 'images/bbongflix_logo.png', fit: BoxFit.contain, height: 25, ), Container( padding: EdgeInsets.only(right: 1), child: Text( 'TV 프로그램', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '영화', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 14), ), ), ], ), ); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// lib/widget/carousel_slider.dartimport 'package:carousel_slider/carousel_slider.dart';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';class CarouselImage extends StatefulWidget { final List&lt;Movie&gt; movies; CarouselImage({this.movies}); _CarouselImageState createState() =&gt; _CarouselImageState();}class _CarouselImageState extends State&lt;CarouselImage&gt; { List&lt;Movie&gt; movies; List&lt;Widget&gt; images; List&lt;String&gt; keywords; List&lt;bool&gt; likes; int _currentPage = 0; String _currentKeyword; @override void initState() { super.initState(); movies = widget.movies; images = movies.map((m) =&gt; Image.asset('./img/images/' + m.poster)).toList(); keywords = movies.map((m) =&gt; m.keyword).toList(); likes = movies.map((m) =&gt; m.like).toList(); _currentKeyword = keywords[0]; } @override Widget build(BuildContext context) { return Container( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(20), ), CarouselSlider( items: images, onPageChanged: (index) { setState(() { _currentPage = index; _currentKeyword = keywords[_currentPage]; }); }, ), Container( padding: EdgeInsets.fromLTRB(0, 10, 0, 3), child: Text( _currentKeyword, style: TextStyle(fontSize: 11), ), ), Container( child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ Container( child: Column( children: &lt;Widget&gt;[ likes[_currentPage] ? IconButton( icon: Icon(Icons.check), onPressed: () {}, ) : IconButton( icon: Icon(Icons.add), onPressed: () {}, ), Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 11), ) ], ), ), Container( padding: EdgeInsets.only(right: 10), child: FlatButton( color: Colors.white, onPressed: () {}, child: Row( children: &lt;Widget&gt;[ Icon( Icons.play_arrow, color: Colors.black, ), Padding( padding: EdgeInsets.all(3), ), Text( '재생', style: TextStyle(color: Colors.black), ) ], ), ), ), Container( padding: EdgeInsets.only(right: 10), child: Column( children: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.info), onPressed: () {}, ), Text( '정보', style: TextStyle(fontSize: 11), ) ], ), ), ], ), ), Container( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: makeIndicator(likes, _currentPage), ), ) ], ), ); }}List&lt;Widget&gt; makeIndicator(List list, int _currentPage) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; list.length; i++) { results.add(Container( width: 8, height: 8, margin: EdgeInsets.symmetric(vertical: 10.0, horizontal: 2.0), decoration: BoxDecoration( shape: BoxShape.circle, color: _currentPage == i ? Color.fromRGBO(255, 255, 255, 0.9) : Color.fromRGBO(255, 255, 255, 0.4)), )); } return results;}","link":"/2020/03/21/2020-03-21-bbongflix-lec04-post/"},{"title":"[무작정 플러터 강의노트] 06 홈 화면에 원형 이미지 &#x2F; 사각형 이미지 슬라이더 위젯 추가하기","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184// detail_screen.dartimport 'dart:ui';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';class DetailScreen extends StatefulWidget { final Movie movie; DetailScreen({this.movie}); _DetailScreenState createState() =&gt; _DetailScreenState();}class _DetailScreenState extends State&lt;DetailScreen&gt; { bool like = false; @override void initState() { super.initState(); like = widget.movie.like; } @override Widget build(BuildContext context) { return Scaffold( body: Container( child: SafeArea( child: ListView( children: &lt;Widget&gt;[ Stack( children: &lt;Widget&gt;[ Container( width: double.maxFinite, decoration: BoxDecoration( image: DecorationImage( image: AssetImage('images/' + widget.movie.poster), fit: BoxFit.cover, ), ), child: ClipRect( child: BackdropFilter( filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10), child: Container( alignment: Alignment.center, color: Colors.black.withOpacity(0.1), child: Container( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.fromLTRB(0, 45, 0, 10), child: Image.asset( 'images/' + widget.movie.poster), height: 300, ), Container( padding: EdgeInsets.all(7), child: Text( '99% 일치 2019 15+ 시즌 1개', textAlign: TextAlign.center, style: TextStyle(fontSize: 13), ), ), Container( padding: EdgeInsets.all(7), child: Text( widget.movie.title, textAlign: TextAlign.center, style: TextStyle( fontWeight: FontWeight.bold, fontSize: 16), ), ), Container( padding: EdgeInsets.all(3), child: FlatButton( onPressed: () {}, color: Colors.red, child: Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Icon(Icons.play_arrow), Text('재생'), ], ), ), ), Container( padding: EdgeInsets.all(5), child: Text(widget.movie.toString()), ), Container( padding: EdgeInsets.all(5), alignment: Alignment.centerLeft, child: Text( '출연: 현빈, 손예진, 서지혜\\n제작자: 이정효, 박지은', style: TextStyle( color: Colors.white60, fontSize: 12, ), ), ) ], ), ), ), ), ), ), Positioned( child: AppBar( backgroundColor: Colors.transparent, elevation: 0, ), ), ], ), Container( color: Colors.black26, child: Row( mainAxisAlignment: MainAxisAlignment.start, children: &lt;Widget&gt;[ Container( padding: EdgeInsets.fromLTRB(20, 10, 20, 10), child: InkWell( onTap: () {}, child: Column( children: &lt;Widget&gt;[ like ? Icon(Icons.check) : Icon(Icons.add), Padding( padding: EdgeInsets.all(5), ), Text( '내가 찜한 콘텐츠', style: TextStyle( fontSize: 11, color: Colors.white60, ), ) ], ), ), ), Container( padding: EdgeInsets.fromLTRB(20, 10, 20, 10), child: Container( child: Column( children: &lt;Widget&gt;[ Icon(Icons.thumb_up), Padding( padding: EdgeInsets.all(5), ), Text( '평가', style: TextStyle( fontSize: 11, color: Colors.white60), ) ], ), ), ), Container( padding: EdgeInsets.fromLTRB(20, 10, 20, 10), child: Container( child: Column( children: &lt;Widget&gt;[ Icon(Icons.send), Padding(padding: EdgeInsets.all(5)), Text( '공유', style: TextStyle( fontSize: 11, color: Colors.white60), ), ], ), ), ) ], ), ) ], ), ), ), ); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// carousel_slider.dartimport 'package:carousel_slider/carousel_slider.dart';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class CarouselImage extends StatefulWidget { final List&lt;Movie&gt; movies; CarouselImage({this.movies}); _CarouselImageState createState() =&gt; _CarouselImageState();}class _CarouselImageState extends State&lt;CarouselImage&gt; { List&lt;Movie&gt; movies; List&lt;Widget&gt; images; List&lt;String&gt; keywords; List&lt;bool&gt; likes; int _currentPage = 0; String _currentKeyword; @override void initState() { super.initState(); movies = widget.movies; images = movies.map((m) =&gt; Image.asset('images/' + m.poster)).toList(); keywords = movies.map((m) =&gt; m.keyword).toList(); likes = movies.map((m) =&gt; m.like).toList(); _currentKeyword = keywords[0]; } @override Widget build(BuildContext context) { return Container( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(20), ), CarouselSlider( items: images, onPageChanged: (index) { setState(() { _currentPage = index; _currentKeyword = keywords[_currentPage]; }); }, ), Container( padding: EdgeInsets.fromLTRB(0, 10, 0, 3), child: Text( _currentKeyword, style: TextStyle(fontSize: 11), ), ), Container( child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ Container( child: Column( children: &lt;Widget&gt;[ likes[_currentPage] ? IconButton( icon: Icon(Icons.check), onPressed: () {}, ) : IconButton( icon: Icon(Icons.add), onPressed: () {}, ), Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 11), ) ], ), ), Container( padding: EdgeInsets.only(right: 10), child: FlatButton( color: Colors.white, onPressed: () {}, child: Row( children: &lt;Widget&gt;[ Icon( Icons.play_arrow, color: Colors.black, ), Padding( padding: EdgeInsets.all(3), ), Text( '재생', style: TextStyle(color: Colors.black), ) ], ), ), ), Container( padding: EdgeInsets.only(right: 10), child: Column( children: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.info), onPressed: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen( movie: movies[_currentPage], ); })); }, ), Text( '정보', style: TextStyle(fontSize: 11), ) ], ), ), ], ), ), Container( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: makeIndicator(likes, _currentPage), ), ) ], ), ); }}List&lt;Widget&gt; makeIndicator(List list, int _currentPage) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; list.length; i++) { results.add(Container( width: 8, height: 8, margin: EdgeInsets.symmetric(vertical: 10.0, horizontal: 2.0), decoration: BoxDecoration( shape: BoxShape.circle, color: _currentPage == i ? Color.fromRGBO(255, 255, 255, 0.9) : Color.fromRGBO(255, 255, 255, 0.4)), )); } return results;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// circle_slider.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class CircleSlider extends StatelessWidget { final List&lt;Movie&gt; movies; CircleSlider({this.movies}); @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.all(7), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('미리보기'), Container( height: 120, child: ListView( scrollDirection: Axis.horizontal, children: makeCircleImages(context, movies), ), ), ], ), ); }}List&lt;Widget&gt; makeCircleImages(BuildContext context, List&lt;Movie&gt; movies) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; movies.length; i++) { results.add( InkWell( onTap: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen( movie: movies[i], ); })); }, child: Container( padding: EdgeInsets.only(right: 10), child: Align( alignment: Alignment.centerLeft, child: CircleAvatar( backgroundImage: AssetImage('images/' + movies[i].poster), radius: 48, ), ), ), ), ); } return results;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// box_slider.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class BoxSlider extends StatelessWidget { final List&lt;Movie&gt; movies; BoxSlider({this.movies}); @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.all(7), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('지금 뜨는 콘텐츠'), Container( height: 120, child: ListView( scrollDirection: Axis.horizontal, children: makeBoxImages(context, movies), ), ) ], ), ); }}List&lt;Widget&gt; makeBoxImages(BuildContext context, List&lt;Movie&gt; movies) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; movies.length; i++) { results.add(InkWell( onTap: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen( movie: movies[i], ); })); }, child: Container( padding: EdgeInsets.only(right: 10), child: Align( alignment: Alignment.centerLeft, child: Image.asset('images/' + movies[i].poster), ), ), )); } return results;}","link":"/2020/03/23/2020-03-23-bbongflix-lec06-post/"},{"title":"[무작정 플러터 강의노트] 08 플러터와 파이어베이스 연동하기","text":"12345678910111213141516171819202122232425262728293031// Movie Data[{ title: 보헤미안 랩소디 keyword: 음악/드라마/인물 poster: https://movie-phinf.pstatic.net/20181213_264/1544692854634ss65r_JPEG/movie_image.jpg like: false},{ title: 사랑의 불시착 keyword: 가슴 뭉클/로맨스/코미디/금지된 사랑/정반대 캐릭터 poster: https://file.mk.co.kr/meet/neds/2019/12/image_readtop_2019_1046822_15762744634013454.jpg like: false},{ title: 포레스트 검프 keyword: 드라마/외국 poster: https://movie-phinf.pstatic.net/20160901_187/1472711688297YP2jH_JPEG/movie_image.jpg like: false},{ title: 쇼생크 탈출 keyword: 추리/반전/서스펜스 poster: https://movie-phinf.pstatic.net/20160119_278/14531650465287bcuk_JPEG/movie_image.jpg like: false},{ title: 라이언 일병 구하기 keyword: 드라마/전쟁/역사 poster: https://movie-phinf.pstatic.net/20111222_4/1324498435937yqCYm_JPEG/movie_image.jpg like: false}] 123456789# pubspec.yamldependencies: flutter: sdk: flutter carousel_slider: flutter_linkify: url_launcher: cloud_firestore: firebase_core: 12345678910111213141516171819202122// model_movie.dartimport 'package:cloud_firestore/cloud_firestore.dart';class Movie { final String title; final String keyword; final String poster; final bool like; final DocumentReference reference; Movie.fromMap(Map&lt;String, dynamic&gt; map, {this.reference}) : title = map['title'], keyword = map['keyword'], poster = map['poster'], like = map['like']; Movie.fromSnapshot(DocumentSnapshot snapshot) : this.fromMap(snapshot.data, reference: snapshot.reference); @override String toString() =&gt; &quot;Movie&lt;$title:$keyword&gt;&quot;;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// home_screen.dartimport 'package:cloud_firestore/cloud_firestore.dart';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/widget/box_slider.dart';import 'package:netflix_clone_lecture_note/widget/carousel_slider.dart';import 'package:netflix_clone_lecture_note/widget/circle_slider.dart';class HomeScreen extends StatefulWidget { _HomeScreenState createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { Firestore firestore = Firestore.instance; Stream&lt;QuerySnapshot&gt; streamData; @override void initState() { super.initState(); streamData = firestore.collection('movie').snapshots(); } Widget _fetchData(BuildContext context) { return StreamBuilder&lt;QuerySnapshot&gt;( stream: Firestore.instance.collection('movie').snapshots(), builder: (context, snapshot) { if (!snapshot.hasData) return LinearProgressIndicator(); return _buildBody(context, snapshot.data.documents); }, ); } Widget _buildBody(BuildContext context, List&lt;DocumentSnapshot&gt; snapshot) { List&lt;Movie&gt; movies = snapshot.map((d) =&gt; Movie.fromSnapshot(d)).toList(); return ListView( children: &lt;Widget&gt;[ Stack( children: &lt;Widget&gt;[ CarouselImage(movies: movies), TopBar(), ], ), CircleSlider(movies: movies), BoxSlider(movies: movies), ], ); } @override Widget build(BuildContext context) { return _fetchData(context); }}class TopBar extends StatelessWidget { @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.fromLTRB(20, 7, 20, 7), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Image.asset( 'images/bbongflix_logo.png', fit: BoxFit.contain, height: 25, ), Container( padding: EdgeInsets.only(right: 1), child: Text( 'TV 프로그램', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '영화', style: TextStyle(fontSize: 14), ), ), Container( padding: EdgeInsets.only(right: 1), child: Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 14), ), ), ], ), ); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166// carousel_slider.dartimport 'package:carousel_slider/carousel_slider.dart';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class CarouselImage extends StatefulWidget { final List&lt;Movie&gt; movies; CarouselImage({this.movies}); _CarouselImageState createState() =&gt; _CarouselImageState();}class _CarouselImageState extends State&lt;CarouselImage&gt; { List&lt;Movie&gt; movies; List&lt;Widget&gt; images; List&lt;String&gt; keywords; List&lt;bool&gt; likes; int _currentPage = 0; String _currentKeyword; @override void initState() { super.initState(); movies = widget.movies; images = movies.map((m) =&gt; Image.network(m.poster)).toList(); keywords = movies.map((m) =&gt; m.keyword).toList(); likes = movies.map((m) =&gt; m.like).toList(); _currentKeyword = keywords[0]; } @override Widget build(BuildContext context) { return Container( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(20), ), CarouselSlider( items: images, onPageChanged: (index) { setState(() { _currentPage = index; _currentKeyword = keywords[_currentPage]; }); }, ), Container( padding: EdgeInsets.fromLTRB(0, 10, 0, 3), child: Text( _currentKeyword, style: TextStyle(fontSize: 11), ), ), Container( child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ Container( child: Column( children: &lt;Widget&gt;[ likes[_currentPage] ? IconButton( icon: Icon(Icons.check), onPressed: () { setState(() { likes[_currentPage] = !likes[_currentPage]; movies[_currentPage].reference.updateData( {'like': likes[_currentPage]}); }); }, ) : IconButton( icon: Icon(Icons.add), onPressed: () { setState(() { likes[_currentPage] = !likes[_currentPage]; movies[_currentPage].reference.updateData( {'like': likes[_currentPage]}); }); }, ), Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 11), ), ], ), ), Container( padding: EdgeInsets.only(right: 10), child: FlatButton( color: Colors.white, onPressed: () {}, child: Row( children: &lt;Widget&gt;[ Icon( Icons.play_arrow, color: Colors.black, ), Padding( padding: EdgeInsets.all(3), ), Text( '재생', style: TextStyle(color: Colors.black), ), ], ), ), ), Container( padding: EdgeInsets.only(right: 10), child: Column( children: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.info), onPressed: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen( movie: movies[_currentPage], ); })); }, ), Text( '정보', style: TextStyle(fontSize: 11), ) ], ), ) ], ), ), Container( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: makeIndicator(likes, _currentPage), )), ], ), ); }}List&lt;Widget&gt; makeIndicator(List list, int _currentPage) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; list.length; i++) { results.add(Container( width: 8, height: 8, margin: EdgeInsets.symmetric(vertical: 10.0, horizontal: 2.0), decoration: BoxDecoration( shape: BoxShape.circle, color: _currentPage == i ? Color.fromRGBO(255, 255, 255, 0.9) : Color.fromRGBO(255, 255, 255, 0.4), ), )); } return results;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// circle_slider.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class CircleSlider extends StatelessWidget { final List&lt;Movie&gt; movies; CircleSlider({this.movies}); @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.all(7), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('미리보기'), Container( height: 120, child: ListView( scrollDirection: Axis.horizontal, children: makeCircleImages(context, movies), ), ), ], ), ); }}List&lt;Widget&gt; makeCircleImages(BuildContext context, List&lt;Movie&gt; movies) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; movies.length; i++) { results.add( InkWell( onTap: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen( movie: movies[i], ); })); }, child: Container( padding: EdgeInsets.only(right: 10), child: Align( alignment: Alignment.centerLeft, child: CircleAvatar( backgroundImage: NetworkImage(movies[i].poster), radius: 48, ), ), ), ), ); } return results;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// box_slider.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class BoxSlider extends StatelessWidget { final List&lt;Movie&gt; movies; BoxSlider({this.movies}); @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.all(7), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('지금 뜨는 콘텐츠'), Container( height: 120, child: ListView( scrollDirection: Axis.horizontal, children: makeBoxImages(context, movies), ), ) ], ), ); }}List&lt;Widget&gt; makeBoxImages(BuildContext context, List&lt;Movie&gt; movies) { List&lt;Widget&gt; results = []; for (var i = 0; i &lt; movies.length; i++) { results.add(InkWell( onTap: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen( movie: movies[i], ); })); }, child: Container( padding: EdgeInsets.only(right: 10), child: Align( alignment: Alignment.centerLeft, child: Image.network(movies[i].poster), ), ), )); } return results;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188// detail_screen.dartimport 'dart:ui';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';class DetailScreen extends StatefulWidget { final Movie movie; DetailScreen({this.movie}); _DetailScreenState createState() =&gt; _DetailScreenState();}class _DetailScreenState extends State&lt;DetailScreen&gt; { bool like = false; @override void initState() { super.initState(); like = widget.movie.like; } @override Widget build(BuildContext context) { return Scaffold( body: Container( child: SafeArea( child: ListView( children: &lt;Widget&gt;[ Stack( children: &lt;Widget&gt;[ Container( width: double.maxFinite, decoration: BoxDecoration( image: DecorationImage( image: NetworkImage(widget.movie.poster), fit: BoxFit.cover, ), ), child: ClipRect( child: BackdropFilter( filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10), child: Container( alignment: Alignment.center, color: Colors.black.withOpacity(0.1), child: Container( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.fromLTRB(0, 45, 0, 10), child: Image.network(widget.movie.poster), height: 300, ), Container( padding: EdgeInsets.all(7), child: Text( '99% 일치 2019 15+ 시즌 1개', textAlign: TextAlign.center, style: TextStyle(fontSize: 13), ), ), Container( padding: EdgeInsets.all(7), child: Text( widget.movie.title, textAlign: TextAlign.center, style: TextStyle( fontWeight: FontWeight.bold, fontSize: 16), ), ), Container( padding: EdgeInsets.all(3), child: FlatButton( onPressed: () {}, color: Colors.red, child: Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Icon(Icons.play_arrow), Text('재생'), ], ), ), ), Container( padding: EdgeInsets.all(5), child: Text(widget.movie.toString()), ), Container( padding: EdgeInsets.all(5), alignment: Alignment.centerLeft, child: Text( '출연: 현빈, 손예진, 서지혜\\n제작자: 이정효, 박지은', style: TextStyle( color: Colors.white60, fontSize: 12, ), ), ) ], ), ), ), ), ), ), Positioned( child: AppBar( backgroundColor: Colors.transparent, elevation: 0, ), ), ], ), Container( color: Colors.black26, child: Row( mainAxisAlignment: MainAxisAlignment.start, children: &lt;Widget&gt;[ Container( padding: EdgeInsets.fromLTRB(20, 10, 20, 10), child: InkWell( onTap: () { setState(() { like = !like; widget.movie.reference.updateData({'like': like}); }); }, child: Column( children: &lt;Widget&gt;[ like ? Icon(Icons.check) : Icon(Icons.add), Padding( padding: EdgeInsets.all(5), ), Text( '내가 찜한 콘텐츠', style: TextStyle( fontSize: 11, color: Colors.white60, ), ) ], ), ), ), Container( padding: EdgeInsets.fromLTRB(20, 10, 20, 10), child: Container( child: Column( children: &lt;Widget&gt;[ Icon(Icons.thumb_up), Padding( padding: EdgeInsets.all(5), ), Text( '평가', style: TextStyle( fontSize: 11, color: Colors.white60), ) ], ), ), ), Container( padding: EdgeInsets.fromLTRB(20, 10, 20, 10), child: Container( child: Column( children: &lt;Widget&gt;[ Icon(Icons.send), Padding(padding: EdgeInsets.all(5)), Text( '공유', style: TextStyle( fontSize: 11, color: Colors.white60), ), ], ), ), ) ], ), ) ], ), ), ), ); }}","link":"/2020/03/23/2020-03-23-bbongflix-lec08-post/"},{"title":"[무작정 플러터 강의노트] 07 프로필 화면 만들기","text":"1234567# pubspec.yamldependencies: flutter: sdk: flutter carousel_slider: flutter_linkify: url_launcher: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// main.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/screen/home_screen.dart';import 'package:netflix_clone_lecture_note/screen/more_screen.dart';import 'package:netflix_clone_lecture_note/widget/bottom_bar.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget { _MyAppState createState() =&gt; _MyAppState();}class _MyAppState extends State&lt;MyApp&gt; { TabController controller; @override Widget build(BuildContext context) { return MaterialApp( title: 'Bbongflix', theme: ThemeData( brightness: Brightness.dark, primaryColor: Colors.black, accentColor: Colors.white, ), home: DefaultTabController( length: 4, child: Scaffold( body: TabBarView( physics: NeverScrollableScrollPhysics(), children: &lt;Widget&gt;[ HomeScreen(), Container( child: Center( child: Text('search'), ), ), Container( child: Center( child: Text('save'), ), ), MoreScreen(), ], ), bottomNavigationBar: Bottom(), ), ), ); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// more_screen.dartimport 'package:flutter/material.dart';import 'package:flutter_linkify/flutter_linkify.dart';import 'package:url_launcher/url_launcher.dart';class MoreScreen extends StatelessWidget { @override Widget build(BuildContext context) { return Container( child: Center( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.only(top: 50), child: CircleAvatar( radius: 100, backgroundImage: AssetImage('images/bbongflix_logo.png'), ), ), Container( padding: EdgeInsets.only(top: 15), child: Text( 'TaeBbong', style: TextStyle( fontWeight: FontWeight.bold, fontSize: 25, color: Colors.white), ), ), Container( padding: EdgeInsets.all(15), width: 140, height: 5, color: Colors.red, ), Container( padding: EdgeInsets.all(10), child: Linkify( onOpen: (link) async { if (await canLaunch(link.url)) { await launch(link.url); } }, text: &quot;https://github.com/TaeBbong&quot;, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 20), linkStyle: TextStyle(color: Colors.white), ), ), Container( padding: EdgeInsets.all(10), child: FlatButton( onPressed: () {}, child: Container( color: Colors.red, child: Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Icon( Icons.edit, color: Colors.white, ), SizedBox( width: 10, ), Text( '프로필 수정하기', style: TextStyle(color: Colors.white), ), ], ), ), ), ), ], ), ), ); }}","link":"/2020/03/23/2020-03-23-bbongflix-lec07-post/"},{"title":"[무작정 플러터 강의노트] 09 검색 화면 &#x2F; 기능 만들기","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546// main.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/screen/home_screen.dart';import 'package:netflix_clone_lecture_note/screen/more_screen.dart';import 'package:netflix_clone_lecture_note/screen/search_screen.dart';import 'package:netflix_clone_lecture_note/widget/bottom_bar.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget { _MyAppState createState() =&gt; _MyAppState();}class _MyAppState extends State&lt;MyApp&gt; { TabController controller; @override Widget build(BuildContext context) { return MaterialApp( title: 'Bbongflix', theme: ThemeData( brightness: Brightness.dark, primaryColor: Colors.black, accentColor: Colors.white, ), home: DefaultTabController( length: 4, child: Scaffold( body: TabBarView( physics: NeverScrollableScrollPhysics(), children: &lt;Widget&gt;[ HomeScreen(), SearchScreen(), Container( child: Center( child: Text('save'), ), ), MoreScreen(), ], ), bottomNavigationBar: Bottom(), ), ), ); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// search_screen.dartimport 'package:cloud_firestore/cloud_firestore.dart';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class SearchScreen extends StatefulWidget { _SearchScreenState createState() =&gt; _SearchScreenState();}class _SearchScreenState extends State&lt;SearchScreen&gt; { final TextEditingController _filter = TextEditingController(); FocusNode focusNode = FocusNode(); String _searchText = &quot;&quot;; _SearchScreenState() { _filter.addListener(() { setState(() { _searchText = _filter.text; }); }); } Widget _buildBody(BuildContext context) { return StreamBuilder&lt;QuerySnapshot&gt;( stream: Firestore.instance.collection('movie').snapshots(), builder: (context, snapshot) { if (!snapshot.hasData) return LinearProgressIndicator(); return _buildList(context, snapshot.data.documents); }, ); } Widget _buildList(BuildContext context, List&lt;DocumentSnapshot&gt; snapshot) { List&lt;DocumentSnapshot&gt; searchResults = []; for (DocumentSnapshot d in snapshot) { if (d.data.toString().contains(_searchText)) { searchResults.add(d); } } return Expanded( child: GridView.count( crossAxisCount: 3, childAspectRatio: 1 / 1.5, padding: EdgeInsets.all(3), children: searchResults .map((data) =&gt; _buildListItem(context, data)) .toList()), ); } Widget _buildListItem(BuildContext context, DocumentSnapshot data) { final movie = Movie.fromSnapshot(data); return InkWell( child: Image.network(movie.poster), onTap: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen(movie: movie); })); }, ); } @override Widget build(BuildContext context) { return Container( child: Column( children: &lt;Widget&gt;[ Padding( padding: EdgeInsets.all(30), ), Container( color: Colors.black, padding: EdgeInsets.fromLTRB(5, 10, 5, 10), child: Row( children: &lt;Widget&gt;[ Expanded( flex: 6, child: TextField( focusNode: focusNode, style: TextStyle( fontSize: 15, ), autofocus: true, controller: _filter, decoration: InputDecoration( filled: true, fillColor: Colors.white12, prefixIcon: Icon( Icons.search, color: Colors.white60, size: 20, ), suffixIcon: focusNode.hasFocus ? IconButton( icon: Icon( Icons.cancel, size: 20, ), onPressed: () { setState(() { _filter.clear(); _searchText = &quot;&quot;; }); }, ) : Container(), hintText: '검색', labelStyle: TextStyle(color: Colors.white), focusedBorder: OutlineInputBorder( borderSide: BorderSide(color: Colors.transparent), borderRadius: BorderRadius.all(Radius.circular(10))), enabledBorder: OutlineInputBorder( borderSide: BorderSide(color: Colors.transparent), borderRadius: BorderRadius.all(Radius.circular(10))), border: OutlineInputBorder( borderSide: BorderSide(color: Colors.transparent), borderRadius: BorderRadius.all(Radius.circular(10))), ), ), ), focusNode.hasFocus ? Expanded( child: FlatButton( child: Text('취소'), onPressed: () { setState(() { _filter.clear(); _searchText = &quot;&quot;; focusNode.unfocus(); }); }, ), ) : Expanded( flex: 0, child: Container(), ) ], ), ), _buildBody(context) ], ), ); }}","link":"/2020/03/23/2020-03-23-bbongflix-lec09-post/"},{"title":"[무작정 풀스택 강의노트] 소스 코드 레포","text":"프론트엔드(플러터) 레포: https://github.com/TaeBbong/quiz_app_lecture백엔드(DRF) 레포: https://github.com/TaeBbong/quiz_drf_lecture인프런: https://inflearn.com구름에듀: https://edu.goorm.io유튜브: https://youtube.com","link":"/2020/04/05/2020-04-05-fullquiz-lecture01-post/"},{"title":"[오늘의 플러터] 플러터 상태관리 바이블 1편 - setState()","text":"플러터는 대세 프론트엔드 프레임워크입니다. 예전보다 플러터에 관심 갖는 분들이 많아짐을 느끼고 있는데, 요즘 프론트엔드 프레임워크와 뗄 수 없는 내용이 바로 상태관리라고 생각합니다. 상태와 상태관리는 플러터 프론트엔드 개발에서 핵심적인 부분이며, 이를 위한 다양한 도구가 있습니다. 본 포스트에서는 아주 기본적인 개념과 가장 쉬운 예시를 통해 플러터의 대표적인 상태관리 기법들(setState(), Provider, BloC)에 대해 정리해보겠습니다. 상태상태를 아주 간단히 이해해봅시다. 상태란 (언제든) 바뀔 수 있는 데이터입니다! 뭔가 거창한 것 같은 이름인데 별게 없습니다ㅎㅎ.. 그림으로 좀 더 자세히 확인해보겠습니다. 해당 이미지는 플러터 공식 홈페이지에 있는 상태에 대한 예시 이미지입니다. 별 모양 버튼으로 찜하기를 할 수 있는 것을 확인할 수 있습니다. 위 그림처럼 별 모양을 누르면 별이 색칠되면서 카운트가 증가하고, 별 모양을 다시 누르면 별이 흰 색이 되며 카운트가 감소합니다. 그렇다면 위 기능을 구현하기 위해서는 무엇이 필요할까요? 서버와의 통신이고 데이터 저장이고 그런 복잡한 것은 빼고 생각해보면, 찜하기가 눌렸는지 안눌렸는지에 대한 정보가 필요할 것입니다. 그래야 앱이 현재 찜하기가 눌린 상태라면 색칠된 별 모양과 증가된 카운트 수를 보여줄 것이며, 찜하기가 눌리지 않은 상태라면 흰 별 모양과 감소된 카운트 수를 보여주겠죠. 이러한 찜하기 기능은 언제든 눌릴 수 있기 때문에 눌릴 때마다 페이지가 새로고침 된다던지 그러면 불편하겠죠? 즉 눌려졌는지를 잘 기록하고 있고, 그 값의 변화에 따라서 즉각적으로 새로운 모양을 보여줄 수 있도록 하는 것이 상태에 대한 기본적인 내용입니다. setState() 사용 예시위와 같은 예시를 플러터로 작성하려면 StatefulWidget 을 활용해야 합니다. 플러터에서는 기본적으로 StatelessWidget 과 StatefulWidget 을 상속받아 여러 종류의 위젯 클래스를 만들 수 있는데, 변화하는 상태가 있는 위젯은 StatefulWidget, 그렇지 않은, 한번 로드되면 변하지 않는 정적인 위젯은 StatelessWidget 로 만들게 됩니다. 위의 UI 예시를 코드로 나타내면 다음과 같겠습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class HomeScreen extends StatefulWidget { @override createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('setState example'), ), body: Column( children: [ Padding(padding: EdgeInsets.all(10)), Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ Container( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Container( padding: const EdgeInsets.only(bottom: 8), child: Text( 'Oeschinen Lake Campground', style: TextStyle( fontWeight: FontWeight.bold, ), ), ), Text( 'Kandersteg, Switzerland', style: TextStyle( color: Colors.grey[500], ), ), ], ), ), Row( children: [ Icon( Icons.star, color: Colors.red[500], ), Text('41'), ], ), ], ), ], ), ); }} 이제 코드를 실행하면 위에서 봤던 이미지의 형태처럼 텍스트와 함께 빨간색 별이 있는 것을 확인할 수 있습니다. 상태에 초점을 맞추기 위해 불필요한 부분의 코드는 생략했습니다. 코드를 조금 자세히 살펴보겠습니다. 우선 StatefulWidget 클래스를 하나 만들었네요. HomeScreen 이라는 이름에서 알 수 있듯 홈화면을 구성하는 위젯이고, MyApp 클래스의 home 부분에 들어가는 위젯입니다. 플러터 프로젝트를 처음 시작한다면 나오는 MyHomePage 부분을 전부 지우고 위의 내용으로 채우면 문제 없이 실행될 것입니다. 12345678class HomeScreen extends StatefulWidget { @override createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { ...} 그리고 하단에는 _HomeScreenState 라는 클래스를 하나 만들었습니다. 이는 State를 상속받고 있는데, 이처럼 상태를 다루는 위젯을 구성할 때에는 StatefulWidget을 만들고, State를 하나 만든 다음에 StatefulWidget에서 createState()와 같은 함수를 활용하여 해당 클래스에서 사용할 상태 클래스를 가져온다는 개념으로 이해하시면 되겠습니다. 실제로 위젯의 내용을 구성하는 부분은 StatefulWidget이 아닌 State 내부에서 진행합니다. Widget build() 메소드도 State 클래스 안에서 선언하고 있으며, StatefulWidget은 그저 State 클래스를 연결해놓는 것으로 그 역할을 다 하고 있다고 볼 수 있겠습니다. 나머지 코드들은 UI를 구성하는 부분이기 때문에 따로 보지 않고, 우리가 상태 변화를 적용시킬 아이콘 부분만 보겠습니다. 지금은 그냥 간단하게 UI만 구성이 되어있네요. 12345678910...Row( children: [ Icon( Icons.star, color: Colors.red[500], ), Text('41'), ],), 이제 이 부분이 버튼처럼 눌릴 수 있도록 처리를 해보겠습니다. 여러 방법이 있지만 이 경우에는 아이콘을 아이콘버튼으로 변경하는 것만으로 완성할 수 있습니다. 아래와 같이 코드를 수정합니다. 1234567891011...Row( children: [ IconButton( icon: Icon(Icons.star), color: Colors.red[500], onPressed: () {} ), Text('41'), ],), 이제 우리가 구성한 아이콘은 클릭이 가능한 버튼이 되었습니다. 해당 버튼이 눌렸을 때에 발생하는 동작을 onPressed()에 함수 형태로 선언할 수 있습니다. 우리의 의도는 버튼이 눌리면 색이 변경되고 텍스트에 들어가있는 숫자가 바뀌는 것이겠죠. 이 부분을 상태로 다루기 위해서는 다음과 같은 상태를 저장하는 변수가 필요합니다. 1234567class _HomeScreenState extends State&lt;HomeScreen&gt; { bool _isPressed = false; @override Widget build(BuildContext context) { ... }} State 클래스 내부에 선언한 변수인 _isPressed는 상태로 사용할 수 있는 변수입니다. 기본 값으로는 false를 넣어두었습니다. 상태에 대한 선언은 저것으로 끝입니다! 상태라는게 대단한게 아니라 즉각적으로 변할 수 있는 변수에 불과하기 때문에 간단히 처리할 수 있었습니다. _isPressed라는 상태를 정의했기 때문에, 우리는 UI를 어떻게 하면 눌린 상태와 눌리지 않은 상태에 띠라 구성할 수 있는지 알 수 있습니다. 삼항 연산자를 활용해 코드를 아주 간단하게 만들 수 있습니다. 12345678910Row( children: [ IconButton( icon: _isPressed ? Icon(Icons.star) : Icon(Icons.star_border), color: _isPressed ? Colors.red[500] : Colors.white, onPressed: () {} ), Text(_isPressed ? '41' : '40'), ],), 위의 코드를 통해 _isPressed가 true일 때, 즉 눌렸을 때는 빨간색으로 채워진 별 모양을 보여주고 숫자도 41로 보여주게 합니다. false일 때는 빈 별과 40을 보여주게 되겠습니다. 그러면 이제는 버튼이 눌렸을 때 일어나야 하는 일을 쉽게 정의할 수 있습니다. 버튼이 눌렸을 때에는 그저 _isPressed 값을 변경만 해주면 됩니다. 이것만으로 UI가 바뀔까요? 직접 확인해보겠습니다. 1234567891011121314Row( children: [ IconButton( icon: _isPressed ? Icon(Icons.star) : Icon(Icons.star_border), color: _isPressed ? Colors.red[500] : Colors.white, onPressed: () { setState(() { _isPressed = !_isPressed; }); } ), Text(_isPressed ? '41' : '40'), ],), 이제 앱에서 버튼을 눌러보면 아래와 같은 일이 발생합니다. 아주 매끄럽게 버튼을 누를 때마다 화면의 요소들이 변경되는 것을 확인할 수 있습니다. 살짝의 해설을 덧붙이자면, setState()가 실행될 때마다 해당 위젯은 다시 빌드가 됩니다. 앱 전체가 아닌 해당 부분만 다시 빌드되기 때문에 우리는 어떠한 부자연스러움 없이 자연스럽게 동작에 대한 변화를 확인할 수 있습니다. 다시 빌드가 되는 방식이기 때문에 단지 서로 다른 _isPressed 값에 대한 UI를 선언해주는 것만으로 화면을 변경시킬 수 있습니다. 버튼이 눌리면 =&gt; setState()가 실행되면서 =&gt; _isPressed 값이 변경되고 =&gt; 화면이 다시 빌드되면서 =&gt; 화면을 그려주는 부분에서 변경된 _isPressed에 맞춰 화면을 그려준다! 는 흐름으로 위 코드가 동작함을 이해할 수 있습니다. 이런 방식으로 setState()를 활용해 아주 간단한 상태에 대한 처리 및 관리를 할 수 있습니다. 그런데 여기서 하나의 문제는, setState()만으로는 모든 문제를 해결할 수 없다는 것입니다. 어떤 경우에 setState()가 해결할 수 없는 상황이 발생할까요? 이는 다음 게시글의 주제인 Provider에서 확인해보겠습니다.","link":"/2020/06/13/2020-06-13-flutter-state-post/"},{"title":"[무작정 플러터 강의노트] 10 찜한 콘텐츠 화면 &#x2F; 기능 만들기","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243// main.dartimport 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/screen/home_screen.dart';import 'package:netflix_clone_lecture_note/screen/like_screen.dart';import 'package:netflix_clone_lecture_note/screen/more_screen.dart';import 'package:netflix_clone_lecture_note/screen/search_screen.dart';import 'package:netflix_clone_lecture_note/widget/bottom_bar.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget { _MyAppState createState() =&gt; _MyAppState();}class _MyAppState extends State&lt;MyApp&gt; { TabController controller; @override Widget build(BuildContext context) { return MaterialApp( title: 'Bbongflix', theme: ThemeData( brightness: Brightness.dark, primaryColor: Colors.black, accentColor: Colors.white, ), home: DefaultTabController( length: 4, child: Scaffold( body: TabBarView( physics: NeverScrollableScrollPhysics(), children: &lt;Widget&gt;[ HomeScreen(), SearchScreen(), LikeScreen(), MoreScreen(), ], ), bottomNavigationBar: Bottom(), ), ), ); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// like_screen.dartimport 'package:cloud_firestore/cloud_firestore.dart';import 'package:flutter/material.dart';import 'package:netflix_clone_lecture_note/model/model_movie.dart';import 'package:netflix_clone_lecture_note/screen/detail_screen.dart';class LikeScreen extends StatefulWidget { _LikeScreenState createState() =&gt; _LikeScreenState();}class _LikeScreenState extends State&lt;LikeScreen&gt; { Widget _buildBody(BuildContext context) { return StreamBuilder&lt;QuerySnapshot&gt;( stream: Firestore.instance .collection('movie') .where('like', isEqualTo: true) .snapshots(), builder: (context, snapshot) { if (!snapshot.hasData) return LinearProgressIndicator(); return _buildList(context, snapshot.data.documents); }, ); } Widget _buildList(BuildContext context, List&lt;DocumentSnapshot&gt; snapshot) { return Expanded( child: GridView.count( crossAxisCount: 3, childAspectRatio: 1 / 1.5, padding: EdgeInsets.all(3), children: snapshot.map((data) =&gt; _buildListItem(context, data)).toList()), ); } Widget _buildListItem(BuildContext context, DocumentSnapshot data) { final movie = Movie.fromSnapshot(data); return InkWell( child: Image.network(movie.poster), onTap: () { Navigator.of(context).push(MaterialPageRoute&lt;Null&gt;( fullscreenDialog: true, builder: (BuildContext context) { return DetailScreen(movie: movie); })); }, ); } @override Widget build(BuildContext context) { return Container( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.fromLTRB(20, 27, 20, 7), child: Row( mainAxisAlignment: MainAxisAlignment.start, children: &lt;Widget&gt;[ Image.asset( 'images/bbongflix_logo.png', fit: BoxFit.contain, height: 25, ), Container( padding: EdgeInsets.only(left: 30), child: Text( '내가 찜한 콘텐츠', style: TextStyle(fontSize: 14), ), ) ], ), ), _buildBody(context) ], ), ); }}","link":"/2020/03/23/2020-03-23-bbongflix-lec10-post/"},{"title":"[TIL] 21.04.07","text":"BloC 패턴BloC(Business Logic Component) 패턴은 구글 개발자들이 추천하는, 플러터 개발에 적용되는 가장 대표적인 디자인 패턴이다.안드로이드에서의 MVVM 패턴(Model - View - ViewModel)과 거의 동일하며 ViewModel 대신 BloC이 들어가는 구조이다.안드로이드 개발 당시 MVVM을 적용해봤다면 금방 적응할 수 있겠지만… Inherited WidgetBloC을 공부하려다가 Inherited Widget을 기본적으로 사용한다길래 바로 Inherited Widget으로 넘어왔다.Inherited Widget은 가장 기본적인 형태의 전역 상태 관리 방법이다. 즉 상태를 여러 위젯이 공유할 수 있다는 말이다.이전에 사용했던 setState()를 살펴보면, 클래스 내부의 상태를 변경할 수 있었지만 다른 클래스의 상태에 접근하거나 변경할 수 없었다.쉽게 말해 전역 상태에 대한 관리를 할 수 없었고, 이를 보완하기 위한 방법 중 하나가 Inherited Widget이라는 것이다.조금 쉽게 생각하면 Inherited Widget은 자식들이 공용으로 접근할 수 있는 데이터를 갖고 있는 부모와 같은 존재인 것이다. Inherited Widget은 대략 아래와 같은 구조를 가진다. 1234567891011121314151617181920212223// lib/MyInherited.dartimport 'package:flutter/material.dart';class MyInherited extends InheritedWidget { final int shareData; const MyInherited({ Key? key, required this.shareData, required Widget child, }) : super(key: key, child: child); @override bool updateShouldNotify(MyInherited old) { return shareData != old.shareData; } static MyInherited of(BuildContext context) { final MyInherited? result = context.dependOnInheritedWidgetOfExactType&lt;MyInherited&gt;(); assert(result != null, 'No ShareData found in context'); return result!; }} 플러터 공식 문서의 기본 구조 코드를 가져온 것이다.구성 요소를 위에서부터 살펴보면 일단 MyInherited는 InheritedWidget을 상속받아 선언되었다.우리가 공유할 상태는 int shareData로 선언하였다.그 다음으로는 생성자가 나오고, Widget child를 꼭 넣어주어야 한다.updateShouldNotify()는 InheritedWidget의 메소드로, 간단히 생각하면 부모(MyInherited)가 가진 데이터(shareData)가 바뀌었을 때 자식 위젯들을 재빌드하여 업데이트하기 위한 메소드이다.데이터가 변경되었다면 True, 변경되지 않았다면 False이다. 업데이트를 안하겠다면 그냥 return False; 하면 된다.마지막으로 of()를 선언하였는데, 이를 활용하면 자식 위젯들이 부모(MyInherited)의 데이터(shareData)에 .of()만으로 손쉽게 접근할 수 있다. 자식 위젯의 예시까지 확인해보자. 12345678910111213// lib/ChildWidget.dartimport 'package:flutter/material.dart';import 'package:flutter_study/MyInherited.dart';class ChildWidget extends StatelessWidget { @override Widget build(BuildContext context) { final shareData = MyInherited.of(context).shareData; return Container( child: Text('shareData: $shareData'), ); }} final shareData 부분을 보면 그냥 바로 MyInherited.of(context).shareData와 같은 방식으로 부모(MyInherited)의 데이터에 접근하는 것을 볼 수 있다.이제 실제로 동작하게 하기 위한 마지막 처리로, 가장 root 위젯인 MyApp을 MyInherited로 감싸서 앱 전역에서 우리가 만든 MyInherited를 부모로 사용하겠다는 코드와 HomeScreen 코드를 작성한다. 1234567891011121314151617181920// lib/screen_home.dartimport 'package:flutter/material.dart';import 'package:flutter_study/ChildWidget.dart';class HomeScreen extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(&quot;Inherited Widget&quot;), ), body: Column( children: [ Text('This is child'), ChildWidget(), ], ), ); }} 123456789101112131415161718192021222324// lib/main.dartimport 'package:flutter/material.dart';import 'package:flutter_study/MyInherited.dart';import 'package:flutter_study/screen_home.dart';void main() { runApp(MyApp());}class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MyInherited( shareData: 777, child: MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: HomeScreen(), ), ); }} MyApp에서 MyInherited로 감싸는 것을 보면 shareData에 777을 초기값으로 넣는 것을 확인할 수 있다.이후 실행하면 아래와 같다. 이 상태에 대한 업데이트를 하려면 어떻게 해야할까? 기본적으로 Inherited Widget의 데이터는 자식이 변경할 수 없다.그럼 이게 어떻게 상태 관리 도구라고 할 수 있겠나 싶지만, StatefulWidget이나 기타 여러 기법을 결합하면 업데이트가 가능하도록 할 수 있다.어차피 Inherited Widget을 공부한 것은 전역에서, 부모 =&gt; 자식 방향으로 데이터를 공유하는 컨셉에 대한 이해(나중에 BloC에서 사용되는 개념이니)를 위함이었지 이를 활용해 상태 관리를 할 것은 아니니 이 정도에서 공부를 마치겠다. 살짝 다른 길로 샌 느낌이 있지만…. 헷갈리기 쉬운 포인트BloC, Provider는 모두 디자인 패턴이다! 단순히 상태 관리 패키지라고 정의하기엔 무리가 있음.디자인 패턴인만큼 이들은 프로젝트 구조를 다루는 분야이며, 이를 쉽게 구현할 수 있도록 구현해놓은 패키지가 각각 bloc, provider이다.상태 관리와 연관짓게 되는 것은 이들이 반응성을 보장하는 구조이기 때문에, 즉 상태의 변화를 제어할 수 있기 때문이다.","link":"/2021/04/07/2021-04-07-til/"},{"title":"[플러터 팁 백과사전] 001. SplashScreen","text":"SplashScreen??SplashScreen은 앱이 실행될 때 처음 나타나게 되는 일종의 소개 화면입니다. 주로 앱 로고 등을 넣어 사용자에게 어떤 앱인지 알려주는 용도로 사용합니다. 또한 사용자에게는 안보이지만, 앱에서 시간을 들여 가져와야 하는 데이터를 가져올 때 SplashScreen이 보여지는 동안 가져오기도 합니다. SplashScreen의 종류SplashScreen에도 종류가 있습니다. 안드로이드/iOS 각 OS의 Native한 SplashScreen과, Flutter App 단의 SplashScreen 이렇게 두개로 나눠지게 됩니다. 만약 기존에 Flutter 단에서 SplashScreen을 잘 만들고 시행했을 때 검은색 혹은 흰색의 기본 화면이 잠시 나오다가 Flutter SplashScreen이 나오는 경험을 하신 적 있다면, 그것이 두 종류의 SplashScreen을 확인한 것입니다. Flutter level SplashScreen 만들기Flutter level의 SplashScreen을 적용시킬 때에는 특별히 패키지를 가져올 필요는 없습니다. 공개된 패키지가 여럿 있지만, 굳이 없어도 간단히 구현할 수 있습니다. 그냥 로고를 띄워주고 시간이 되거나 데이터를 다 불러왔을 때 메인 화면으로 이동만 시키면 되니까요. 제가 작성한 예시는 아래와 같습니다. 일정 시간이 지나면 메인 화면으로 이동하도록 작성해보았습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// main.dartimport 'package:flutter/material.dart';import 'dart:async';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'MY MEMO', home: SplashScreen(), ); }}class SplashScreen extends StatefulWidget { @override _SplashScreenState createState() =&gt; new _SplashScreenState();}class _SplashScreenState extends State&lt;SplashScreen&gt; {// Future checkFirstSeen() async {// SharedPreferences prefs = await SharedPreferences.getInstance();// bool _seen = (prefs.getBool('seen') ?? false);// if (_seen) {// Navigator.of(context).pushReplacement(// MaterialPageRoute(builder: (context) =&gt; ChatScreen()));// } else {// await prefs.setBool('seen', true);// Navigator.of(context).pushReplacement(// MaterialPageRoute(builder: (context) =&gt; OnBoardingPage()));// }// } @override void initState() { super.initState(); Timer(Duration(milliseconds: 1500), () {// checkFirstSeen(); }); } @override Widget build(BuildContext context) { return Scaffold( body: Container( color: Color(0xff28385e), child: Center( child: Image.asset('images/my_logo.png'), ), ), ); }} 여기에 실제로 데이터를 가져오는 코드를 넣고 싶다면 주석 부분에 코드를 넣으면 됩니다. 물론 시간이 걸리는 코드는 비동기로 작성되어야 합니다. 제가 작성한 주석 부분은 SharedPreference에서 인트로 화면을 본 적이 있는 사용자인지 체크해서 본 적 있으면 바로 메인으로 넘어가고 본 적이 없으면 인트로 화면을 보여주는 코드입니다. Native level SplashScreen 만들기OS Native SplashScreen은 각 OS 별 폴더 내에 있는 파일들을 수정해야 적용됩니다. 이 작업은 꽤 귀찮고 Native가 낯설다면 조금 거부감이 들 수 있기 때문에, 공식 가이드 링크만 첨부하고 저는 다른 방식으로 Native SplashScreen 만드는 것을 알려드리겠습니다. flutter_native_splash라는 패키지가 있습니다. 이는 다른 Splash Screen 관련 패키지와 달리 Native 쪽 설정 코드를 생성하여 직접 적용까지 시켜주는 패키지입니다. 이 때문에 일반적인 패키지와 조금 다른 적용법이 필요합니다. 패키지 설치123// pubspec.yamldev_dependencies: flutter_native_splash: 로고 등록1234// flutter_native_splash.yamlflutter_native_splash: image: images/my_logo.png color: ffffff Splash create1$ flutter pub pub run flutter_native_splash:create Run app 실행하면 아래와 같이 나오게 됩니다. 마치며SplashScreen에 대해 깊이 정리해보았습니다. 앱에서 필수적인 요소인만큼 요긴하게 잘 활용하면 좋겠습니다.","link":"/2020/12/19/2020-12-21-splashscreen-post/"},{"title":"[TIL] 21.04.09","text":"스트림 예제 - 카운터지난번에 이해했던 스트림에 대한 예제를 작성해보겠다. 가장 기본적인 카운터 앱을 예제로 삼아 제작해볼건데, 스트림의 특징을 살리기에는 조금 부족한 예제일 수는 있어도 기본적인 상태 관리에 스트림이 어떻게 적용되는지 알기에는 적합할 것 같다.실제 스트림의 특징인 비동기 처리에 장점을 갖는다는 것은 API를 연동하여 데이터를 가져오는 경우에 확인할 수 있을 것이다. 이는 BloC을 공부하며 심화 예제를 실습할 때 해보겠다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// lib/screen_home.dartimport 'dart:async';import 'package:flutter/material.dart';class HomeScreen extends StatefulWidget { @override _HomeScreenState createState() =&gt; _HomeScreenState();}class _HomeScreenState extends State&lt;HomeScreen&gt; { int _counter = 0; late StreamController _streamController; // late: 나중에 초기화시켜주겠다고 미뤄놓기 late Stream _stream; @override void initState() { super.initState(); _streamController = StreamController(); _stream = _streamController.stream; } void _incrementCounter() { _streamController.sink.add(_counter++); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Counter'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), StreamBuilder( stream: _stream, builder: (BuildContext context, AsyncSnapshot snapshot) { return Text( snapshot.data != null ? snapshot.data.toString() : &quot;0&quot;, ); }) ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); } @override void dispose() { _streamController.close(); super.dispose(); }} 코드를 보면 스트림 관련하여 총 3가지의 객체가 등장한다. 각각에 대해 정리해보겠다. Stream: 앞서 말했던 데이터가 흐르는 강 역할이다. StreamController: 스트림을 제어/관리해주는 객체이다. StreamBuilder: 스트림의 데이터를 활용해 위젯을 빌드하기 위한 객체이다. 스트림 데이터를 받아와 위젯을 빌드한다. 이제 스트림을 대강 살펴보았다. 사실 스트림은 내용이 엄청 많고 할 것도 많음.. 더 봐야겠지만 지금은 BloC을 빨리 적용하고 싶은 마음이 커서 일단은 이정도에서만 마무리하겠다.","link":"/2021/04/09/2021-04-09-til/"},{"title":"[TIL] 21.04.08","text":"스트림또 딴길로 샜는데, 보다보니 Stream이 궁금해져서(역시 마찬가지로 BloC 패턴에서 사용되는 기술이라는데) 함께 공부해보았다. 스트림은 비단 플러터만의 개념은 아니다. 이는 비동기 작업을 할 때 자주 사용되는 개념이다.예전에 회사 다녔을 때 스트림에 대한 사수분의 설명을 빌리자면 데이터가 흐르는 강이라고 할 수 있다. 앱 내에서 다루는 데이터가 많을 때, 웹에서 데이터를 가져오는 것이 시간이 오래 걸린다면 이것을 기다렸다가 다음 단계로 넘어가고.. 비효율적이고 답답할 것이다.이런 것을 해결하기 위한 방법이 비동기 처리이다. 데이터는 데이터대로 가져오고 있도록 하고, 나머지는 일단 각자의 일을 하는 것이다. 그러다가 데이터가 다 가져와졌다면(혹은 최소 사용할 수 있는 만큼 가져와졌다면) 그 데이터를 받아와 처리하는 것이 비동기 방식이다. 이 비동기 방식을 구현하기 위한 방법 중 하나가 스트림이다. 스트림은 비동기 방식의 구현 뿐만 아니라, 엡 전체를 강처럼 흐르고 있는 데이터들을 쭉 관찰하면서(구독이라는 표현도 사용된다) 어떤 위젯에서 필요한 데이터가 변화하였다면 이를 감지하여 해당 위젯에게 알려주고, 해당 위젯의 데이터 부분을 업데이트해주어 반응성(Reactive)있는 앱을 만들어준다. 처음 정리하는거라 내용이 좀 복잡한데, 쉽게 한마디로 말하면 아래와 같다. 앱 전체를 가로지르는 데이터 강(스트림)이 있고, 이 강을 관찰하고 있는 관찰자를 하나 세워두어 내가 원하는 데이터에 변화가 있는지 지켜보다가 변화가 생기면 알아서 그 변화를 반영할 수 있도록 위젯을 만든다(스트림 빌더). 이것이 스트림과 스트림 빌더의 개념이다. 내일은 스트림/스트림 빌더 예제 코드를 작성하는 것을 공부해볼 것이다. 예고편이런 스트림과 스트림 빌더를 보면 UI를 구현하는 코드와 데이터를 관찰하고 처리해주는 스트림/스트림 빌더 영역이 섞이게 된다.그도 그럴 것이 스트림 빌더에 스트림과 위젯 빌더를 함께 선언하기 때문이다.스트림/스트림 빌더를 적극적으로 사용할수록 데이터 처리를 담당하는 코드와 UI 코드가 섞이게 되고, 이를 분리하자는 컨셉이 계속 공부하려 했던 BloC 패턴의 컨셉이다. 헷갈리기 쉬운 포인트BloC, Provider는 모두 디자인 패턴이다! 단순히 상태 관리 패키지라고 정의하기엔 무리가 있음.디자인 패턴인만큼 이들은 프로젝트 구조를 다루는 분야이며, 이를 쉽게 구현할 수 있도록 구현해놓은 패키지가 각각 bloc, provider이다.상태 관리와 연관짓게 되는 것은 이들이 반응성을 보장하는 구조이기 때문에, 즉 상태의 변화를 제어할 수 있기 때문이다. 상태 관리 기법/구조/시스템 정도로는 정의해도 괜찮을 것 같다.","link":"/2021/04/08/2021-04-08-til/"},{"title":"[TIL] 21.04.10, 21.04.12","text":"BloC 패턴BloC(Business Logic Component) 패턴은 구글 개발자들이 추천하는, 플러터 개발에 적용되는 가장 대표적인 디자인 패턴이다.안드로이드에서의 MVVM 패턴(Model - View - ViewModel)과 거의 동일하며 ViewModel 대신 BloC이 들어가는 구조이다. 지난번 내용이 여기까지였는데 이어서 공부해보았다. BloC 패턴의 구조앞서 계속 말했듯 BloC은 패턴이다. 따라서 프로젝트 구조를 어떻게 잡고, 기능을 구현할 때 어떤 요소들을 어떤 단위로 나눠 흐름이 이어지도록 만드는가에 초점을 맞춰 공부해야한다. 이를 파악하기 위한 제일 쉬운 방법 중 하나는 데이터의 흐름(어디서 나와서 어디로 전달되는가)을 확인하는 것이다. 위의 그림을 보면 아주 간단한 형태로 BloC 패턴을 이해할 수 있다. UI: 말그대로 화면 관련 부분 BloC: Presenter 또는 ViewModel의 역할이라고 한다. 그게 무슨 역할이냐면 데이터를 다루는 부분과 화면을 다루는 부분 사이에서 데이터를 잘 주고 받을 수 있도록 제어하는 역할을 하는 것이다. 쉽게 생각해 상태 관리 관련 모든 부분은 여기서 한다고 보면 된다. Repository에 데이터를 요청하고, UI에 데이터를 제공한다. Repository: 아래의 Data Provider와 엮어서 모델 영역으로 생각하면 되며, 여러 Data Provider를 관리 및 BloC 부분과 통신하는 역할을 한다. Network/Local Data Provider: API 연동을 위한 코드 영역이다. BloC 패턴의 구조(보충)여러 문서를 보다가 결국엔 공식 문서(킹갓 Felix)로 돌아왔다. 아래 구조 이미지를 보자. 위에서 설명했던 것과 비슷하지만 좀 더 명확한 느낌이다. 위 구조에서 주목할 점은 UI와 data의 명확한 구분이다. 그 사이에 BloC이 위치하여 중간자 역할을 수행한다. data 영역은 앞서 봤던 것처럼 Repository와 Data Provider로 구분된다. 설명은 위와 동일하다. 패키지 [bloc]https://bloclibrary.dev/#/coreconcepts bloc 공식 문서에 들어가보면 두가지 패키지가 존재한다. 하나는 bloc이고 하나는 flutter_bloc이다. 이 사람의 문서나 예제를 보면 뭔가 이름들이 헷갈리게끔 짓는다는 느낌을 받는데, 이 패키지명들도 마찬가지이다… 내가 이해한 bloc과 flutter_bloc의 차이점은 bloc은 말그대로 위의 패턴에서 가운데에 있는 bloc을 구현하기 위한 패키지이고, flutter_bloc은 Flutter의 UI 영역에서 bloc 관련 내용을 반영하기 위한 위젯들을 모아놓은 패키지라는 것이다. 쉽게 말해 bloc은 BloC 영역을, flutter_bloc은 UI 영역을 위한 패키지라는 것이고 결국 둘 다 필요한 것이다! 결론은 둘 다 알아야 한다는 것이다.^^ 아래 내용에 들어가기에 앞서 이 패키지 내에는 BlocBase라는 기본 클래스가 있다는 사실을 알고 넘어가자. 이 기본 클래스는 Bloc 영역의 구현을 위한 가장 기본 기능들을 모아놓은 클래스이다. 용어 정의(Cubit vs Bloc)Cubit: BlocBase를 상속받은 클래스로, 간단한 상태에 대한 구현을 아주 간결하게 할 수 있도록 도와주는 Bloc 영역의 클래스이다. Bloc: BlocBase를 상속받은 클래스로, 좀 더 복잡한 상태에 대한 구현을 위한 Bloc 영역의 클래스이다. 이 두가지의 방법 중 하나로 Bloc을 구현할 수 있다. 용어가 혼재되어 헷갈리는데, BloC 패턴은 말그대로 디자인 패턴이고, UI와 Data 사이의 중간자 역할을 하는 영역의 이름도 Bloc이며, 그 영역을 구현하기 위한 클래스들(방법들)이 Cubit, Bloc이라는 클래스이다. Bloc이라는 단어가 너무 많은 영역에서 쓰여서 좀 헷갈린다. 일단은 Bloc 영역을 구현하기 위한 클래스로 Cubit을 쓸지 Bloc을 쓸지 고민하는 것이라고만 기억해두자. Cubit 기본각각의 용법에 대해 보충 설명을 해보겠다. Cubit의 경우 간단한 상태에 대한 구현을 한다고 했는데, 그만큼 사용법도 간결하다. 카운터 앱을 예제로 만들건데, 카운터 상태를 위한 CounterCubit은 아래와 같이 만들 수 있다. 123class CounterCubit extends Cubit&lt;int&gt; { CounterCubit() : super(0);} Cubit 클래스를 상속받으면서 라는 타입을 지정해주었다. 이는 타입의 상태를 다루는 Cubit이라는 뜻으로 선언한 것이다. 또한 super(0)을 통해 이 Cubit의 초기 상태 값을 0으로 설정해주었다. 초기화를 외부에서 하게끔(CounterCubit을 생성할 때) 하려면 아래와 같이 쓰면 된다. 123class CounterCubit extends Cubit&lt;int&gt; { CounterCubit(int initialState) : super(initialState);} 상태의 변화에 대해 다루려면 아래와 같이 한다. emit이라는 키워드로 상태를 변화시킬 수 있는데, 그 예시는 아래와 같다. 12345class CounterCubit extends Cubit&lt;int&gt; { CounterCubit() : super(0); void increment() =&gt; emit(state + 1);} CounterCubit 클래스 내에 increment()라는 메소드를 선언해주었고, 이 메소드는 emit()을 활용해 state + 1 값을 CounterCubit으로(내부 상태 값으로) 전달해주었다. 외부에서 CounterCubit의 상태 값을 변경하려면 이 increment() 메소드를 통해 변경할 수 있다. 여기까지 작성한 내용으로 CounterCubit을 사용하려면(이라기보단 확인해보려면) 아래와 같이 작성하면 된다. 1234567void main() { final cubit = CounterCubit(); print(cubit.state); // 0 cubit.increment(); print(cubit.state); // 1 cubit.close();} 아주아주 간단하다. 이전에 그냥 setState()로 관리했던 것과 비슷한 수준인 것 같다. Cubit 스트림하지만 우리의 Cubit과 Bloc의 근본이 되는 BlocBase는 Stream을 확장시킨 클래스이다. Stream 개념을 쓰지 않을 것이라면 굳이 bloc을 쓸 이유가 없다. 우리는 이를 통해 Cubit과 Bloc을 사용함으로 비동기로 로드되는 데이터에 대한 처리를 가능하게끔 할 수 있다. 이래서 앞서 Stream을 알아봤던 것이다! 12345678Future&lt;void&gt; main() async { final cubit = CounterCubit(); final subscription = cubit.stream.listen(print); // 1 cubit.increment(); await Future.delayed(Duration.zero); await subscription.cancel(); await cubit.close();} 위의 예시를 살펴보면 Cubit과 Stream의 만남을 확인할 수 있다. 사실 카운터 예제는 굳이 Stream이 필요 없다보니 조금 이상할 수 있지만, 일단 사용법만 본다고 생각하자. 우리는 subscription이라는 것을 선언하여 cubit의 데이터 변화에 listen하고 있다. cubit의 데이터를 구독하고 있다는 표현과 동일하며 그 데이터에 대한 콜백으로 print 함수를 넣어 변화하는 데이터 각각을 출력하도록 했다. cubit.increment()를 통해 상태 변화를 시켰고, 다 끝나고 나서는 subscription.cancel(), cubit.close()로 구독을 끊고 cubit을 닫았다. Cubit 관찰하기Cubit을 스트림으로 다뤄 비동기적인 데이터 처리를 시킬 수도 있지만, 기본적으로 Cubit의 상태 변화를 관찰하게 할 수도 있다. Cubit의 기본 메소드인 onChange()를 오버라이딩하면 된다. 1234567891011121314151617class CounterCubit extends Cubit&lt;int&gt; { CounterCubit() : super(0); void increment() =&gt; emit(state + 1); @override void onChange(Change&lt;int&gt; change) { print(change); super.onChange(change); }}void main() { CounterCubit() ..increment() ..close();} 이렇게 하면 increment()가 수행된 후에 close()된다. 그리고 increment()가 실행이 되면 emit을 통해 상태가 변화하고, 이 변화를 onChange()가 감지하여 변화했다는 것을 인지하게 되는 것이다. 실행 결과는 아래와 같다. 1Change { currentState: 0, nextState: 1 } BlocObserver로 앱 내 모든 Cubit 관찰하기위의 방법인 onChange()는 단 하나의 Cubit 상태에 대한 변화만을 인지한다. 앱이 조금만 커져도 다루는 상태 값들이 많아질 것이고, 그 개수만큼 Cubit도 있을 것이다. 이 모든 Cubit에 대한 변화를 전부 다 관찰하고 있을 수 있는 슈퍼 구독자가 있다. 이것이 BlocObserver이다. BlocObserver는 bloc 패키지 내에 있는 기본 클래스 중 하나이다. 이 클래스를 확장하여 나만의 BlocObserver를 만들면 앱 전역에 있는 모든 Cubit을 이것 하나로 구독하게끔 할 수 있다. 모든 Cubit들의 변화를 얘가 혼자 다 알려준다. 1234567class SimpleBlocObserver extends BlocObserver { @override void onChange(BlocBase bloc, Change change) { super.onChange(bloc, change); print('${bloc.runtimeType} $change'); }} 이렇게 만들 수 있다. BlocObserver의 경우 앱 내에 하나만 있으면 될 것이다. onChange()를 오버라이딩할 때 BlocBase로 선언되어 있기 때문에 Cubit과 Bloc 둘다 처리해줄 수 있으며, 앱 전체의 Cubit &amp; Bloc을 관찰하기 때문에 앱 내에 하나만 있으면 된다. 그래서 주로 lib 폴더 바로 밑에 넣어두곤 한다. 123456void main() { Bloc.observer = SimpleBlocObserver(); CounterCubit() ..increment() ..close();} 아까 만들었던 CounterCubit에 BlocObserver를 붙여보자. 놀랍게도 단지 저 한줄의 코드만으로 CounterCubit의 변화를 감지할 수 있게 되었다. 12Change { currentState: 0, nextState: 1 }CounterCubit Change { currentState: 0, nextState: 1 } 일단 오늘은 Cubit에 대해 알아보았고, 좀 더 복잡한 상태를 위한 Bloc을 다음번에 알아보자. 어쨌든 하는 역할은 같으니 어렵지 않을 것이다.","link":"/2021/04/12/2021-04-10-til/"},{"title":"[TIL] 21.04.18","text":"BloC 구조로 로그인 예제 구현하기오늘은 로그인 예제를 BloC 구조로 작성해보았다. 이는 bloc 패키지 공식 문서에 나와있는 예제를 따라 만든 것이며, 일부 직관적이지 않은 구조 등을 수정하였다. 물론 공식 문서 예제의 구조가 어떤 점들에 있어 훨씬 유리한 점이 분명 있겠지만, 처음 시작하는 단계에서 이해하기 쉬운 구조가 더 중요하다고 생각되어 구조를 임의로 변경해보았다. 본인은 이 구조가 이해 잘되고 보기도 좋은데, 각자 편한 구조로 구현하면 될 것 같다. 어차피 이 Felix 양반도 무슨 예제마다 구조가 다 다르고 남의 구조나 프로젝트도 막 가져다 쓰고 있거니와, 다른 개발자들의 구조를 봐도 다 다르다. 각자 프로젝트 상황에 맞게 구조를 짜면 되는 것 같은데, 일단 간단한 구조에서는 아래처럼 진행해도 충분히 괜찮아보인다. BloC 프로젝트 구조일단 시작에 앞서 전체 프로젝트 구조는 아래와 같다. 1234567891011121314151617181920212223242526├── lib│ ├── blocs│ │ ├── authentication│ │ │ └── bloc│ │ │ ├── authentication_bloc.dart│ │ │ ├── authentication_event.dart│ │ │ └── authentication_state.dart│ │ └── login│ │ └── bloc│ │ ├── login_bloc.dart│ │ ├── login_event.dart│ │ └── login_state.dart│ ├── main.dart│ ├── models│ │ ├── user.dart│ │ └── values.dart│ ├── repositories│ │ ├── authentication_repository.dart│ │ └── user_repository.dart│ └── views│ ├── screens│ │ ├── home_screen.dart│ │ ├── login_screen.dart│ │ └── splash_screen.dart│ └── widgets│ └── login_form.dart lib 폴더 내부를 보면 main.dart를 중심으로 4개의 큰 폴더가 있다. 각각 repositories, models, blocs, views 인데, 이는 앞서 봤던 그림 구조와 동일하다. 그러면 개발하는 과정을 한단계씩 나아가며 패턴을 익혀보자. 일단 시작 전에 lib 내에 blocs, models, repositories, views 폴더를 만들고 시작하자. 1. Repositories우선은 제일 하단 레이어라고 볼 수 있는 Data 영역부터 구현하겠다. Data 영역은 외부 API나 DB 등과 연결되어 데이터를 가져오는 Data Provider와, 여러 Data Provider들을 관리하고 BloC 영역에 데이터를 제공해줄 수 있는 Repository로 구분된다. 이번에 구현할 로그인 예제는 외부와 연동되지 않고 따로 DB도 사용하지 않기 때문에 Data Provider는 생략된다. 대신 UUID라는 라이브러리로 느낌만 비슷하게 낼 것이며, 관련하여 Data Provider로부터 데이터를 가져왔다고 가정하고 Repository를 작성해본다. Felix의 예제들을 보면 Repository를 패키지로 따로 빼는 경우가 많다. 이는 Repository의 재사용을 위함인데, 생각해보면 확실히 앱마다 BloC 영역이나 Data Provider는 달라질 수 있지만 Repository는 같을 수도 있겠다 싶다. 하지만 조금 복잡해지고 직관성이 떨어지니 lib/repositories 폴더를 만들어서 관리하자. 우선 예제 코드에서 필요한 레포지토리는 authentication_repository.dart와 user_repository.dart이다. authentication_repositoryauthentication_repository는 인증 관련 데이터에 대한 실제 처리를 진행하는 곳이다. 위에서도 말했던 것처럼 레포지토리는 외부 API나 DB와 연동되는 Data Provider를 통합 관리하는 곳이다. 대신 이번 경우에는 실제 Data Provider가 없기 때문에 마치 Data Provider가 있는 것처럼 비슷하게 (데이터를 가져오는 것처럼) 구현할 것이다. 뿐만 아니라 레포지토리의 두번째 역할은 BloC과 통신하여 데이터를 제공할 수 있어야 한다는 것이다. 앱 전역에 있는 BloC들이 해당 데이터에 접근할 수 있도록 하기 위해 Stream으로 데이터를 제공해야 한다. 아주 쉽고 간단하게 위의 설명을 요약하자면 레포지토리는 API 호출과 데이터 관리를 하는 영역이라는 것이다. 그렇기 때문에 authentication_repository에서는 서버와 연결될 로그인, 로그아웃 기능을 구현해야 하고(실제 서버 API에 로그인/로그아웃을 반영시키기 위해) 인증 상태 데이터를 스트림으로 제공해야 한다. 이를 코드로 구현하면 아래와 같겠다. 123456789101112131415161718192021222324252627282930// lib/repositories/authentication_repository.dartimport 'dart:async';enum AuthenticationStatus { unknown, authenticated, unauthenticated }class AuthenticationRepository { final _controller = StreamController&lt;AuthenticationStatus&gt;(); Stream&lt;AuthenticationStatus&gt; get status async* { await Future&lt;void&gt;.delayed(Duration(seconds: 1)); yield AuthenticationStatus.unauthenticated; yield* _controller.stream; } Future&lt;void&gt; logIn( {required String username, required String password}) async { await Future.delayed( Duration(milliseconds: 300), () =&gt; _controller.add(AuthenticationStatus.authenticated), ); } void logOut() { _controller.add(AuthenticationStatus.unauthenticated); } void dispose() { _controller.close(); }} 우선 맨 위에 열거형인 enum으로 AuthenticationStatus를 정의하고 있다. 외부 API와 연동이 된다면 그 데이터를 해당 열거형 포맷으로 맞춰주게 될 것이다.(“인증된 상태”라는 response를 서버로부터 받는다면 그 response를 AuthenticationStatus.authenticated로 바꿔주는 것이다.) await Future.delayed()의 경우 실제 서버와 연결하는 것처럼 시간 소요를 구현하기 위한 코드이며, 겸사겸사 async*를 사용할 수 있게 된다. 그리고 logIn과 logOut을 각각 함수로 구현하고 있다. logIn의 경우 아이디와 비밀번호를 넣어 서버로부터 인증을 받아와야 하기 때문에 Future 타입의 함수이며, logOut은 서버와 관계 없이 클라이언트에서 인증을 해제하기 때문에 그냥 void이다. 왜 로그아웃 기능은 서버와의 연결이 필요없는가에 대해서는 토큰 기반의 인증 관련 내용을 확인하자. 레포지토리 개념과 코드를 이해했다면 BloC의 반은 해냈다고 볼 수 있다. 그만큼 중요하고 조금은 이해하기 어려울 수 있는 부분이라 예시를 하나 더 보고 넘어가겠다. Todo 리스트 앱을 만들기 위해 todo_repository를 만든다고 가정해보자. 그러면 우선 외부 API가 있다는 가정하에, Future&lt;&gt; createTodo(), readTodo(), updateTodo(), deleteTodo() 함수를 각각 만들고 이것이 BloC의 요청과 외부 API 사이에서 연동될 수 있도록 해야 하겠다. 앱에서 Todo 목록을 가져오고 싶다면 todo_repository의 readTodo()를 실행시키고, readTodo()는 외부 API와 연동되어 Todo 목록을 가져오는 것이다. 이 과정에서 데이터를 가져온다면, 이를 가공해서(fromJsonToMap이라던지..) 스트림으로 뿌려줘야 할 것이다. 이것이 레포지토리의 역할이자 개념의 전부이다. user_repository이제 레포지토리를 잘 이해했으니 user_repository도 간단히 만들 수 있을 것이다. user_repository는 회원 정보를 외부로부터 가져온다. 만약 이미 우리 앱에서 로그인한 유저가 있으면 그 유저를 반환한다. 이때 실제 DB에서 관리되는 회원 아이디인 것처럼 UUID로 아이디 값을 생성하여 반환해주도록 하겠다. 123456789101112131415161718// lib/repositories/user_repository.dartimport 'dart:async';import 'package:bloc_login/models/user.dart';import 'package:uuid/uuid.dart';class UserRepository { User? _user; Future&lt;User?&gt; getUser() async { if (_user != null) { return _user; } return Future.delayed( Duration(milliseconds: 300), () =&gt; _user = User(Uuid().v4()), ); }} 이 과정에서 User 객체가 필요하기 때문에 User 모델을 정의하겠다. 모델들은 lib/models 폴더 내에서 관리하면 된다. 123456789101112131415// lib/models/user.dartimport 'package:equatable/equatable.dart';class User extends Equatable { final String id; const User(this.id); @override List&lt;Object&gt; get props { return [id]; } static const empty = User('-');} 레포지토리 완성레포지토리를 완성했다. 이제 우리는 데이터 관련 처리를 담당해줄 레포지토리가 생성된 것이니, 다음 단계로 넘어가겠다. 다음은 대망의 Bloc이다. 2. BlocsBloc 영역 또한 마찬가지로 lib/blocs 폴더를 구성해놓았다. vscode의 bloc extension을 사용하면 bloc 폴더와 함께 _bloc.dart, _event.dart, _state.dart 파일을 함께 만들어준다. 이 세가지 파일은 이름에서 알 수 있듯, 앞서 살펴본 Bloc 영역과 UI 영역 사이의 구성요소들을 정의한 것이다. Bloc 객체는 UI로부터 event를 받아서 변경된 state를 전달해줄 것이다. 각 파일들을 열어보면 미리 작성된 구조 코드가 있다. 1234567891011// counter_state.dartpart of 'counter_bloc.dart';abstract class CounterState extends Equatable { const CounterState(); @override List&lt;Object&gt; get props =&gt; [];}class CounterInitial extends CounterState {} 123456789// counter_event.dartpart of 'counter_bloc.dart';abstract class CounterEvent extends Equatable { const CounterEvent(); @override List&lt;Object&gt; get props =&gt; [];} 12345678910111213141516171819// counter_bloc.dartimport 'dart:async';import 'package:bloc/bloc.dart';import 'package:equatable/equatable.dart';part 'counter_event.dart';part 'counter_state.dart';class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; { CounterBloc() : super(CounterInitial()); @override Stream&lt;CounterState&gt; mapEventToState( CounterEvent event, ) async* { // TODO: implement mapEventToState }} authentication_state일단 상태부터 정의해보자. 내가 Felix의 코드를 보면서 제일 헷갈렸던 부분이 같은 의미를 갖는 것 같은 변수들이 너무 많다는 것이다. 도대체 status와 state를 왜 동시에 쓰는 것인가… 뭐 그만큼 대체할 만한 단어가 없었던 것이겠지만 상당히 헷갈린다. 나중에 내 프로젝트를 할 때에는 헷갈리지 않게 정의해볼 것이며, 일단은 Felix의 코드를 헷갈리지 않고 이해하는 것이 중요하겠다. 123456789101112131415161718192021// lib/blocs/authentication/bloc/authentication_state.dartpart of 'authentication_bloc.dart';class AuthenticationState extends Equatable { final AuthenticationStatus status; final User user; const AuthenticationState._( {this.status = AuthenticationStatus.unknown, this.user = User.empty}); const AuthenticationState.unknown() : this._(); const AuthenticationState.authenticated(User user) : this._(status: AuthenticationStatus.authenticated, user: user); const AuthenticationState.unauthenticated() : this._(status: AuthenticationStatus.unauthenticated); @override List&lt;Object&gt; get props =&gt; [this.status, this.user];} AuthenticationState, 말그대로 인증 관련 상태를 클래스로 만들어주고 있다. 해당 클래스로 만든 객체 자체가 상태인 것이다. AuthenticationState를 구성하는 요소에는 authentication_repository에서 정의해놓은 AuthenticationStatus와 User가 있다. 즉 인증 관련 상태는 레포지토리에서 스트림으로 관리되고 있는 인증 현황 데이터(데이터 영역 내에 있으니 말그대로 데이터)와 유저 데이터, 이렇게 두가지 데이터로 구성되어 있는 셈이다. 아래 코드들을 살펴보면 AuthenticationState.authenticated() 등 몇 가지 정의되어 있는 것을 볼 수 있는데, 생긴건 함수처럼 생겨서 헷갈릴 수 있지만 이는 단일 상속이라는 문법이다. AuthenticationState를 상속받아 unknown, authenticated 등의 서브 클래스를 정의하는 것이다. 즉, 해당 코드 내에 있는 3가지의 클래스 모두 AuthenticationState를 상속받은 것이다. 마지막으로 get props를 하면 해당 state의 status와 user 값을 가져올 수 있다. authentication_event다음은 event이다. 이벤트 역시 앞선 상태와 마찬가지로 서브 클래스를 선언해주어야 한다. AuthenticationStatus 즉 데이터가 변경되었다는 이벤트와 로그아웃이 요청되었다는 이벤트 두가지가 있기 때문이다. 1234567891011121314151617181920// authentication_event.dartpart of 'authentication_bloc.dart';abstract class AuthenticationEvent extends Equatable { const AuthenticationEvent(); @override List&lt;Object&gt; get props =&gt; [];}class AuthenticationStatusChanged extends AuthenticationEvent { final AuthenticationStatus status; const AuthenticationStatusChanged(this.status); @override List&lt;Object&gt; get props =&gt; [status];}class AuthenticationLogoutRequested extends AuthenticationEvent {} authentication_bloc마지막은 bloc이다. 앞서 만든 event와 state는 모두 bloc의 구성요소였다. 그래서 part of로 시작했던 것이다. bloc은 여태까지 작업한 모든 것을 연결한다고 생각하면 편하다. 데이터 영역과 연결하기 위해 Repository를 연결해주고, 해당 레포지토리에서 스트림으로 제공하는 데이터가 있다면 그 데이터를 계속 구독해놓는다. 그러다가 데이터에 변화가 생기면 이벤트를 발생시킨다. 그리고 이벤트가 발생했다면 어떤 이벤트인지에 따라 상태를 변화시킨다. 이것은 앞서 배웠던 bloc의 기본 메소드인 mapEventToState()를 정의하여 할 수 있다. 이를 통해 어디서든 이벤트가 발생하면 bloc은 해당 이벤트를 처리하여 상태를 변화시킬 수 있다. 상태가 변화하면 UI도 자동으로 변경될 것이다. 이것은 UI를 구현할 때 flutter_bloc 패키지의 위젯들이 도와줄 것이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// authentication_bloc.dartimport 'dart:async';import 'package:bloc/bloc.dart';import 'package:bloc_login/models/user.dart';import 'package:equatable/equatable.dart';import 'package:bloc_login/repositories/authentication_repository.dart';import 'package:bloc_login/repositories/user_repository.dart';part 'authentication_event.dart';part 'authentication_state.dart';class AuthenticationBloc extends Bloc&lt;AuthenticationEvent, AuthenticationState&gt; { final AuthenticationRepository _authenticationRepository; final UserRepository _userRepository; late StreamSubscription&lt;AuthenticationStatus&gt; _authenticationStatusSubscription; AuthenticationBloc({ required AuthenticationRepository authenticationRepository, required UserRepository userRepository, }) : _authenticationRepository = authenticationRepository, _userRepository = userRepository, super(const AuthenticationState.unknown()) { _authenticationStatusSubscription = _authenticationRepository.status.listen( (status) =&gt; add(AuthenticationStatusChanged(status)), ); } @override Stream&lt;AuthenticationState&gt; mapEventToState( AuthenticationEvent event, ) async* { // TODO: implement mapEventToState if (event is AuthenticationStatusChanged) { yield await _mapAuthenticationStatusChangedToState(event); } else if (event is AuthenticationLogoutRequested) { _authenticationRepository.logOut(); } } @override Future&lt;void&gt; close() { _authenticationStatusSubscription.cancel(); _authenticationRepository.dispose(); return super.close(); } Future&lt;AuthenticationState&gt; _mapAuthenticationStatusChangedToState( AuthenticationStatusChanged event, ) async { switch (event.status) { case AuthenticationStatus.unauthenticated: return const AuthenticationState.unauthenticated(); case AuthenticationStatus.authenticated: final user = await _tryGetUser(); return user != null ? AuthenticationState.authenticated(user) : const AuthenticationState.unauthenticated(); default: return const AuthenticationState.unknown(); } } Future&lt;User?&gt; _tryGetUser() async { try { final user = await _userRepository.getUser(); return user; } on Exception { return null; } }} 코드가 긴데, 차근차근 보면 일단 맨 위에 생성자가 있다. 앞서 말한대로 데이터 영역과 연결되기 위해 레포지토리를 연결해주고 있다. 그리고 _authenticationStatusSubscription을 통해 authentication_repository에 있는 스트림 데이터를 구독한다. 그 데이터가 변경되면 AuthenticationStatusChanged(status) 이벤트를 발생시킨다. 다음으로는 이벤트를 상태의 변화로 이어지게 해주는 bloc의 기본 필수 메소드인 mapEventToState를 정의해야 한다. 당연히 event를 받아서 각 이벤트의 종류에 따라 무언가 행동을 시키는데, 이 행동은 각각 상태의 변화를 발생하게 하는 것이며 변경된 상태를 반환하게 한다. 즉 mapEventToState는 함수 이름에서 알 수 있듯 event를 받아 state를 반환한다. 지금과 같은 경우에는 이벤트가 두 종류라서 두개의 조건문으로 처리하고 있다. 첫번째 이벤트인 AuthenticationStatusChanged 이벤트에 대한 처리는 _mapAuthStatusChangedToState로 정의해두었다. 말그대로 AuthenticationStatusChanged 이벤트를 State의 변화로 이어지게 한다는 것이며, 실제 데이터인 AuthenticationStatus 데이터의 변화가 State의 변화로 이어지게 되는 것이다. 이벤트에는 방금 말한 AuthenticationStatus 데이터가 있고, 그 데이터가 지금 어떤 값이냐에 따라 상태를 변화시키고 있다. 정리해보면 다음과 같다. 데이터를 관리하는 레포지토리가 있고, 여기엔 실제 데이터가 있다. 그리고 Bloc은 이벤트가 발생했을 때 상태를 변화시키는 일을 하며 여기서 이벤트는 데이터의 변경, 변경 요청 등이 있다. 이러한 이벤트가 발생했을 때 각 이벤트에 따라 상태를 변화시키고, 이 상태의 변화는 UI로 반영될 것이다. 그럼 UI만 구성하면 하나의 Bloc 패턴은 완성될 것이다. login_bloc이 영역은 깃헙 레포로 대체하겠다. TIL인데 너무 설명이 길어지는 것 같아 생략하겠다. 3. viewsviews는 빠르게 넘어가겠다. 여기까지 봤다면 플러터로 UI를 구성하는 것 정도는 쉽게 할 수 있는 사람일 것이다. 그저 UI에 Bloc이 어떻게 연결되는지를 중점적으로 살펴보도록 하자. 나는 screens와 widgets로 폴더를 구성했다. 이는 각자 스타일대로 하면 될 것이다. main.dart본격적인 화면 디자인에 앞서 main.dart에서 App부터 정의하고 넘어가야 한다. 보통 MaterialApp으로 구성되는 App에 Bloc을 어떻게 적용하는지 확인해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// lib/main.dartimport 'package:bloc_login/blocs/authentication/bloc/authentication_bloc.dart';import 'package:bloc_login/repositories/authentication_repository.dart';import 'package:bloc_login/repositories/user_repository.dart';import 'package:bloc_login/views/screens/home_screen.dart';import 'package:bloc_login/views/screens/login_screen.dart';import 'package:bloc_login/views/screens/splash_screen.dart';import 'package:flutter/material.dart';import 'package:flutter_bloc/flutter_bloc.dart';void main() { runApp(MyApp( authenticationRepository: AuthenticationRepository(), userRepository: UserRepository(), ));}class MyApp extends StatelessWidget { final AuthenticationRepository authenticationRepository; final UserRepository userRepository; const MyApp( {Key? key, required this.authenticationRepository, required this.userRepository}) : super(key: key); @override Widget build(BuildContext context) { return RepositoryProvider.value( value: this.authenticationRepository, child: BlocProvider( create: (_) =&gt; AuthenticationBloc( authenticationRepository: authenticationRepository, userRepository: userRepository), child: MainApp(), ), ); }}class MainApp extends StatefulWidget { @override _MainAppState createState() =&gt; _MainAppState();}class _MainAppState extends State&lt;MainApp&gt; { final _navigatorKey = GlobalKey&lt;NavigatorState&gt;(); NavigatorState get _navigator =&gt; _navigatorKey.currentState!; @override Widget build(BuildContext context) { return MaterialApp( navigatorKey: _navigatorKey, builder: (context, child) { return BlocListener&lt;AuthenticationBloc, AuthenticationState&gt;( listener: (context, state) { switch (state.status) { case AuthenticationStatus.authenticated: _navigator.pushAndRemoveUntil&lt;void&gt;( HomeScreen.route(), (route) =&gt; false); break; case AuthenticationStatus.unauthenticated: _navigator.pushAndRemoveUntil&lt;void&gt;( LoginScreen.route(), (route) =&gt; false); break; default: break; } }, child: child, ); }, onGenerateRoute: (_) =&gt; SplashScreen.route(), ); }} 우선 void run()에 들어갈 MyApp에는 레포지토리가 선언되어 있다. 이는 앱 전체를 감싸는 Bloc과 연결되어야 하기에 선언한 것이다. 바로 밑에 Widget build()를 보면 BlocProvider에서 AuthenticationBloc을 생성하며 인자로 선언한 레포지토리들을 넣는 것을 확인할 수 있다. Widget build()를 좀 더 자세히 살펴보면, RepositoryProvider.value()를 통해 앱 전역에 레포지토리를 제공하고 있다. 즉, 앱 전역에서 데이터로 접근할 수 있다는 말이다. 또한 RepositoryProvider의 child는 BlocProvider인데, 역시 앱 전역에 AuthenticationBloc을 제공하기 위함이다. child에는 MainApp()이 있고, 이는 우리가 익히 잘 알고 있는 메인 앱의 구조이다. 대신 여기에는 BlocListener가 들어간다. 예전에 flutter_bloc 위젯들을 공부하며 BlocBuilder와 BlocListener의 차이점을 확인했었는데, BlocListener는 페이지 라우팅과 같이 상태 변화 한번에 대해 한번만 일어나는 이벤트들을 처리하기 위한 위젯이었다. MaterialApp 내에서 구현해야 하는 기능 중 하나인 라우팅을 처리하기 위해 BlocListener를 쓰고, Bloc의 State에 따라 어느 화면으로 이동할지에 대해 다루고 있다. home_screen.dart홈 화면에서는 로그인이 된 경우 나타나는 화면이며 UUID를 출력하고 로그아웃 버튼이 활성화된다. 이때 UUID 값은 회원 정보이므로 Bloc.state.user로부터 가져와야 하고, 로그아웃의 경우 로그아웃 요청 이벤트인 AuthenticationLogoutRequested 이벤트를 발생시켜야 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041// lib/screens/home_screen.dartimport 'package:bloc_login/blocs/authentication/bloc/authentication_bloc.dart';import 'package:flutter/material.dart';import 'package:flutter_bloc/flutter_bloc.dart';class HomeScreen extends StatelessWidget { static Route route() { return MaterialPageRoute&lt;void&gt;(builder: (_) =&gt; HomeScreen()); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Home'), ), body: Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Builder( builder: (context) { final userId = context .select((AuthenticationBloc bloc) =&gt; bloc.state.user); return Text('UserId: $userId'); }, ), ElevatedButton( child: Text('Logout'), onPressed: () { context .read&lt;AuthenticationBloc&gt;() .add(AuthenticationLogoutRequested()); }, ) ], ), ), ); }} home_screen은 하위 위젯이므로, 하위 위젯이 Bloc에 접근하는 방법에 대해 알 수 있는 부분이다. context.select((Bloc) =&gt; data);를 통해 Bloc의 상태 값을 말그대로 골라 가져올 수 있다. context.read().add(event)를 통해 해당 Bloc에 이벤트를 발생시킬 수 있다. 마치며이제 BloC 패턴이 어느정도 잘 이해가 된 느낌이다. 이제 남은 것은 이렇게 공부한 BloC 패턴을 프로젝트에 적용하면서 연습하는 것이다. 드디어 본 개발에 들어갈 수 있게 되었다..!","link":"/2021/04/18/2021-04-18-til/"},{"title":"[TIL] 21.04.16","text":"패키지 [flutter_bloc]https://bloclibrary.dev/#/coreconcepts bloc 공식 문서에 들어가보면 두가지 패키지가 존재한다. 하나는 bloc이고 하나는 flutter_bloc이다. 이 사람의 문서나 예제를 보면 뭔가 이름들이 헷갈리게끔 짓는다는 느낌을 받는데, 이 패키지명들도 마찬가지이다… 내가 이해한 bloc과 flutter_bloc의 차이점은 bloc은 말그대로 위의 패턴에서 가운데에 있는 bloc을 구현하기 위한 패키지이고, flutter_bloc은 Flutter의 UI 영역에서 bloc 관련 내용을 반영하기 위한 위젯들을 모아놓은 패키지라는 것이다. 쉽게 말해 bloc은 BloC 영역을, flutter_bloc은 UI 영역을 위한 패키지라는 것이고 결국 둘 다 필요한 것이다! 지난번까지는 bloc 패키지를 확인했다. 이제 flutter_bloc을 알아보자. flutter_bloc 기본앞서 확인했던 것처럼 Bloc 영역의 클래스를 사용하기 위한 UI 영역 측의 클래스가 flutter_bloc에 정의되어 있다. 즉 Bloc 영역을 잘 만들어 이것이 이벤트를 받아 상태 변화를 처리하는 등 기능을 잘 수행하게 만들었다면 UI에서는 이 Bloc을 활용할 수 있어야 한다. Bloc의 상태를 가져와서 상태가 변화할 때마다 위젯이 다시 빌드되도록 한다던지 등등.. 이것을 위한 패키지가 flutter_bloc이라는 점을 다시 강조하고 넘어가겠다. flutter_bloc의 위젯들UI 영역의 클래스이기 때문에 위젯의 형태를 갖게 된다. 어떤 위젯들이 있는지 확인해보도록 하자. BlocProvider, MultiBlocProviderBlocProvider는 Bloc을 자식 위젯들이 접근할 수 있도록 하는 위젯이다. BlocProvider를 선언할 때 Bloc과 child를 정의하고, 그러면 child 위젯은 해당 Bloc에 접근할 수 있게 된다. BlocProvider는 의존성 주입(DI)을 위한 위젯이라고 한다. 이게 무슨 얘기냐면, 최상위에서 BlocProvider로 Bloc을 만들어 놓으면, child 이하의 모든 위젯들이 해당 Bloc에 접근할 수 있다는 것이다. 이렇게 내부에 필요한 값(또는 객체)을 외부에서 선언해주는 것을 의존성 주입이라고 이해하면 된다. 외부에서 내부로 객체를 주입해주는 개념이다. 여기서는 BlocProvider가 내부로 Bloc을 주입해주었다. 내부에서는 그럼 Bloc을 가져다 쓰면 되는 것이다. 이를테면 아래와 같이 사용된다. 1234BlocProvider( create: (BuildContext context) =&gt; BlocA(), child: MaterialApp(),); 위처럼 BlocProvider는 BlocA를 생성한다. 그리고 그 BlocA를 MaterialApp에 주입한다. 그러면 MaterialApp 내의 모든 위젯들이 해당 BlocA를 사용할 수 있다. 아래와 같이 말이다. 1final _blocA = BlocProvider.of&lt;BlocA&gt;(context); 이렇게 BlocProvider로부터 받아온 _blocA를 어떻게 쓰는지 다음 내용(BlocBuilder)에서 살펴보고, 여러 개의 Bloc을 하위 위젯들에게 전달하기 위해서는 MultiBlocProvider를 사용한다. 1234567891011121314MultiBlocProvider( providers: [ BlocProvider&lt;BlocA&gt;( create: (BuildContext context) =&gt; BlocA(), ), BlocProvider&lt;BlocB&gt;( create: (BuildContext context) =&gt; BlocB(), ), BlocProvider&lt;BlocC&gt;( create: (BuildContext context) =&gt; BlocC(), ), ], child: MaterialApp(),) BlocBuilderBlocBuilder는 Bloc을 인자로 받아 위젯을 빌드하기 위한 위젯이다. 공식 문서에는 BlocProvider보다 BlocBuilder가 먼저 나오는데 설명의 순서를 바꾼 이유가 여기에 있다. 앞서 BlocProvider가 내부로 주입한 Bloc을 받아 해당 Bloc으로 위젯을 빌드해주는 위젯이 바로 BlocBuilder이기 때문에 이런 순서로 이해하는게 더 쉬울 것 같다. 12345678910final _blocA = BlocProvider.of&lt;BlocA&gt;(context);...BlocBuilder( bloc: _blocA, builder: (BuildContext context, BlocAState state) { // do with state.. }) 또는 _blocA를 따로 선언하지 않아도 BlocProvider에게 제공받을 수 있는 자식 위젯들이라면 아래와 같이 그냥 바로 사용할 수 있다. 12345BlocBuilder&lt;BlocA, BlocAState&gt;( builder: (context, state) { // return widget here based on BlocA's state }) StreamBuilder와 비슷한 구조를 가지고 있으며, Bloc을 인자로 받고 그 Bloc의 상태값을 활용해 위젯을 빌드하기에 상태의 변화에 따라 해당 위젯이 다시 빌드된다. 따라서 재빌드를 최소화하기 위해 상태와의 연결이 필요한 위젯만을 빌더에 넣는 것이 중요하겠다. BlocListener, MultiBlocListenerBlocListener는 Bloc의 상태값이 변경되었을 때 호출되도록 하는 위젯이다. 설명만으로는 BlocBuilder와 유사해보이는데, BlocListener는 한 번의 상태 변화에 대해 한 번 발생해야 하는 기능(페이지 네비게이션, SnackBar나 Dialog 띄우기 등)을 위해서만 사용되어야 한다고 공식 문서에 나와있다. 살짝 미묘한 차이가 있는 것 같기는 한데 정확히 감은 오지 않으니 이는 실제로 프로젝트에 적용하면서 배워보겠다. 123456BlocListener&lt;BlocA, BlocAState&gt;( listener: (context, state) { // do stuff here based on BlocA's state }, child: Container(),) 이런 식으로 BlocBuilder와 비슷한 방식으로 사용된다. 여러 상태에 대한 BlocListener가 필요한 경우 MultiBlocListener를 사용한다. 1234567891011121314MultiBlocListener( listeners: [ BlocListener&lt;BlocA, BlocAState&gt;( listener: (context, state) {}, ), BlocListener&lt;BlocB, BlocBState&gt;( listener: (context, state) {}, ), BlocListener&lt;BlocC, BlocCState&gt;( listener: (context, state) {}, ), ], child: ChildA(),) BlocConsumerBlocConsumer 내용까지는 다루지 않고 넘어가보겠다. RepositoryProvider, MultiRepositoryProvider드디어 처음으로 BloC 영역과 관련된 위젯이 아닌 데이터 영역과 관련된 위젯이 나왔다. RepositoryProvider는 BlocProvider와 유사한 개념이다. BlocProvider는 BloC 영역의 Bloc 객체를 내부로 주입하기 위한 위젯이였고, RepositoryProvider는 데이터 영역의 Repository 객체를 내부로 주입하기 위한 위젯인 것이다. 계속적으로 주입이라는 용어를 사용하는데, 위에서 이해했던 내용을 까먹었다면 그냥 쉽게 아래와 같이 이해해보자. 최상단에서 Bloc 또는 Repository를 생성하고, 그 Bloc과 Repository를 하위 위젯들이 사용할 수 있게끔 제공해주는 역할을 해주는 것이 Provider들이다. 사용법은 BlocProvider와 비슷하다. 1234RepositoryProvider( create: (context) =&gt; RepositoryA(), child: MaterialApp(),); 하위 위젯들이 접근할 때에도 비슷하게 사용한다. 12345// with extensionscontext.read&lt;RepositoryA&gt;();// without extensionsRepositoryProvider.of&lt;RepositoryA&gt;(context); 여러 개의 Repository를 제공해야 하는 경우 MultiRepositoryProvider를 사용한다. 역시 비슷하다. 1234567891011121314MultiRepositoryProvider( providers: [ RepositoryProvider&lt;RepositoryA&gt;( create: (context) =&gt; RepositoryA(), ), RepositoryProvider&lt;RepositoryB&gt;( create: (context) =&gt; RepositoryB(), ), RepositoryProvider&lt;RepositoryC&gt;( create: (context) =&gt; RepositoryC(), ), ], child: ChildA(),) 마치며드디어 bloc과 flutter_bloc의 모든 위젯들을 어느정도 만나보았다. 앞서 BloC의 구조와 개념에서 설명했듯 이는 방법이기 때문에 꼭 bloc과 flutter_bloc을 사용할 필요는 없다. 이들은 어디까지나 BloC 패턴의 구현을 도와주는 패키지들이기 때문이다. 그래도 우리는 정돈된 구조와 효율성을 위해 패키지들을 활용해 구현해보도록 하겠다.","link":"/2021/04/16/2021-04-16-til/"},{"title":"[개발] Ubuntu 20.04 Desktop 서버에 백엔드 서비스를 올리는 과정","text":"SpecVM 1 : Flask + uwsgi + nginx + sqliteVM 2 : Golang Gin + postgres(docker) Common - 00. ssh 설치로컬에서 접속해서 설정하기 위해 ssh 설치 필요 12$ sudo apt-get install openssh-server$ sudo systemctl status ssh 방화벽을 설정해서 ssh 접속 포트(22번)를 허용해야 함 12$ sudo ufw allow 22/tcp$ sudo ufw enable 로컬에서는 다음과 같이 접속하면 됨 12# Mac OS X Terminal$ ssh user@IP_ADDRESS Common - 00. git 설치git이 없다면 설치해야 함(백엔드 어플리케이션 소스코드 배포를 위함) 1$ sudo apt-get install git Flask - 00. Flask - 01. 소스코드 clone / requirements.txt주로 /srv 디렉토리에 저장 123user@user /srv$ sudo git clone https://github.com/TaeBbong/Flask-Board.gitpython3 -m venv venvsource venv/bin/activate 12pip install -r requirements.txtflask run Flask - 02. uwsgi12345# wsgi.pyfrom app import app as applicationif __name__ == &quot;__main__&quot;: application.run() 1234567891011[uwsgi]module = wsgisocket = /tmp/uwsgi.sockchmod-socket = 666vacuum = truedaemonize = /srv/uwsgi.logdie-on-term = true 123pip install uwsgiuwsgi --ini uwsgi.inils -l /tmp | grep uwsgi.sock Flask - 03. nginx1sudo apt-get install nginx 12345678910/etc/nginx/sites-available/my_nginxserver { listen 5000; server_name localhost; location / { include uwsgi_params; uwsgi_pass unix:/tmp/uwsgi.sock; }} 123sudo ln -s /etc/nginx/sites-available/my_nginx /etc/nginx/sites-enabledsudo nginx -tsudo service nginx restart Flask - 04. Firewall123$ sudo ufw allow 80/tcp$ sudo ufw allow 443/tcp$ sudo ufw allow 5000/tcp Go - 01. install123456789101112131415$ wget https://golang.org/dl/go1.16.5.linux-amd64.tar.gz$ tar -C /usr/local -xvf go1.16.5.linux-amd64.tar.gz$ sudo vi ~/.profile# GOROOT: 설치된 Go 패키지의 경로export GOROOT=/usr/local/go # GOPATH: Go 패키지를 이용해 작업할 공간export GOPATH =/usr/local/workplace/go# 동일export PATH=$GOPATH/bin:$GOROOT/bin:$PATH$ source ~/.profile Go - 02. Source Code12345$ cd /srv$ git clone https://github.com/TaeBbong/Go-Board.git$ cd Go-Board$ go mod tidy$ go run main.go Go - 03. Firewall123$ sudo ufw allow 80/tcp$ sudo ufw allow 443/tcp$ sudo ufw allow 8080/tcp","link":"/2022/03/10/2022-03-10-backend/"},{"title":"[개발] Docker 개념 정리 &amp; Docker로 postgres 설치&#x2F;운용하기","text":"docker컨테이너라는 개념을 갖고 있는 가상화 SW 기존 VM은 OS 자체를 가상화된 하드웨어에 올린다면,docker container는 자체적인 파일 시스템을 가상화된 OS에 올려서 독립적인 공간을 만들어냄 위의 설명은 사전적인 의미고, 쉽게 이해하자면호스트 운영체제가 무엇이든 상관 없이 그 안에 독립적인 공간(docker container)을 만들어내고,그 독립적인 공간 안에 SW를 설치해서 운용하는 개념이다. 이 독립적인 공간은 아까 자체적인 파일 시스템이라고 했는데,그래서 아주 기본적인 OS의 파일 시스템 형태를 갖고 있다.따라서 docker container 안에 운용하고 싶은 SW가 있다면,그 SW 실행에 필요한 모든 의존성은 docker container 내에만 존재하는 것이다.이 말은 즉 docker container를 A 운영체제에 놓아도, B 운영체제에 놓아도 똑같이 실행이 된다는 것이다. docker imageexample) docker로 postgres 설치 &amp; 운용하기https://blog.dalso.org/linux/ubuntu-20-04-lts/13118 https://devinlife.com/postgresql/run-postgresql-on-docker/ https://semtax.tistory.com/12","link":"/2022/03/11/2022-03-11-docker/"},{"title":"[TIL] 21.04.13","text":"패키지 [bloc] 이어서Cubit: BlocBase를 상속받은 클래스로, 간단한 상태에 대한 구현을 아주 간결하게 할 수 있도록 도와주는 Bloc 영역의 클래스이다. Bloc: BlocBase를 상속받은 클래스로, 좀 더 복잡한 상태에 대한 구현을 위한 Bloc 영역의 클래스이다. 지난번에는 Cubit까지 정리했고 Bloc을 확인해보도록 하겠다. Bloc 기본앞서 알아봤던 것처럼 Bloc은 Cubit과 동일하게 BlocBase로 시작한다. Bloc이 다른 점은 상태를 변화시키는 방식인데, 아래 그림을 보면 쉽게 이해된다. 이전에 Cubit의 경우 상태를 변화시킬 때 Cubit 내에 정의된 메소드에 바로 접근하여 해당 메소드가 emit을 수행, 상태를 변화시킬 수 있었다. Bloc의 경우 그렇게 하지 않고 event를 UI로부터 받아서 Bloc 내부에서 event를 처리, 상태를 변화시킨다. 12345enum CounterEvent { increment }class CounterBloc extends Bloc&lt;CounterEvent, int&gt; { CounterBloc() : super(0);} 이렇게 하면 기본적인 Bloc이 생성된 것이다. Cubit은 int만 정의해주었던 것과 달리, Bloc을 상속받을 때 Event도 함께 정의하도록 한다. 상단의 enum CounterEvent { increment } 는 CounterEvent의 요소 중 하나를 increment로 정의하고 있는 것이다. 여기서 상태를 변화시킬 수 있도록 하려면 아래와 같이 할 수 있다. 1234567891011121314enum CounterEvent { increment }class CounterBloc extends Bloc&lt;CounterEvent, int&gt; { CounterBloc() : super(0); @override Stream&lt;int&gt; mapEventToState(CounterEvent event) async* { switch (event) { case CounterEvent.increment: yield state + 1; break; } }} 단순히 increment() 메소드를 내부에 정의해놓았던 Cubit과 달리 Bloc에는 mapEventToState()라는 메소드를 오버라이딩하여 재정의하고 있다. mapEventToState()라는 이름에서 알 수 있듯 Event를 State로 바꿔준다고 이해할 수 있겠다. 위 코드에서는 switch-case를 통해 event의 종류에 따라 처리를 달리하는데 앞서 enum으로 정의한 CounterEvent.increment의 경우 state + 1을 반환하는 것으로 알 수 있다. yield는 return과 비슷하지만 비동기방식의 return이라고 이해하면 되겠다. 함수가 종료되지 않는 상태로 요청이 올 때마다 연산하는 구문이다. Bloc을 사용하는 방법은 나중에 실제로 사용되는 예제를 통해 확인하고 넘어가겠다. 간단히 이벤트를 넣는 방법에 대해서만 보자면, 12345678Future&lt;void&gt; main() async { final bloc = CounterBloc(); print(bloc.state); // 0 bloc.add(CounterEvent.increment); await Future.delayed(Duration.zero); print(bloc.state); // 1 await bloc.close();} 이런식으로 bloc.add(Event)를 통해 처리한다. Bloc 관찰하기Cubit에서와 마찬가지로 onChange()를 오버라이딩하여 상태의 변화를 감지할 수 있다. 1234567891011121314151617181920enum CounterEvent { increment }class CounterBloc extends Bloc&lt;CounterEvent, int&gt; { CounterBloc() : super(0); @override Stream&lt;int&gt; mapEventToState(CounterEvent event) async* { switch (event) { case CounterEvent.increment: yield state + 1; break; } } @override void onChange(Change&lt;int&gt; change) { print(change); super.onChange(change); }} onTransition()이라는 메소드도 있는데, 이것은 상태의 변화가 일어났을 때 어떤 이벤트의 발생으로 상태가 변화했는지 나타낼 수 있다. 이것이 Bloc이 가진 장점 중 하나인 Traceability(추적 가능)인 것 같다. 1234567891011121314151617181920212223242526enum CounterEvent { increment }class CounterBloc extends Bloc&lt;CounterEvent, int&gt; { CounterBloc() : super(0); @override Stream&lt;int&gt; mapEventToState(CounterEvent event) async* { switch (event) { case CounterEvent.increment: yield state + 1; break; } } @override void onChange(Change&lt;int&gt; change) { super.onChange(change); print(change); } @override void onTransition(Transition&lt;CounterEvent, int&gt; transition) { super.onTransition(transition); print(transition); }} Cubit 때와 마찬가지로 BlocObserver를 적용시켜 onChange나 onTransition을 통합적으로 탐지하도록 할 수 있다. 12345678910111213141516171819class SimpleBlocObserver extends BlocObserver { @override void onChange(BlocBase bloc, Change change) { super.onChange(bloc, change); print('${bloc.runtimeType} $change'); } @override void onTransition(Bloc bloc, Transition transition) { super.onTransition(bloc, transition); print('${bloc.runtimeType} $transition'); } @override void onError(BlocBase bloc, Object error, StackTrace stackTrace) { print('${bloc.runtimeType} $error $stackTrace'); super.onError(bloc, error, stackTrace); }} 추가적인 내용이 몇 가지 있지만 일단 이렇게 넘어가자. 나머지 필요한 내용은 하면서 배우면 된다. 결론어쨌든 Bloc이나 Cubit이나 BloC 영역에서 동작하는 클래스였다. 이들이 하는 역할은 UI로부터 이벤트를 받아서 상태를 변화시키고, UI에는 상태를 제공하고, 데이터 영역으로부터 데이터를 받아오는 작업을 수행하는 것이다. 어차피 실제 프로젝트에서 구현하는 것은 나중에 할 것이고, 지금은 기본적인 역할 및 개념만 익히면 될 것 같다. 다음번에는 UI 영역에서 BloC 영역을 사용하기 위한 여러 위젯들을 담고 있는 flutter_bloc 패키지를 알아보겠다.","link":"/2021/04/13/2021-04-13-til/"},{"title":"[TIL] 22.04.25","text":"도커도커는 공부할게 참 많은 분야인 것 같다. 기본 개념은 간단하면서도 똑똑한 사람들이 그걸 기반으로 이것저것 만들어내서 꽤나 복잡해졌다. 오늘 배운 내용을 기반으로 도커를 완벽히 정리해보자. docker 전반(시리즈)docker-compose 도커 용어 정리(이미지, 컨테이너)이미지 서비스 운영에 필요한 OS, 서버 프로그램, 소스코드, 설정 파일 등 필요한 모든 파일들을 묶는 형태, ISO와 동일 Immutable한 상태 Dockerhub을 통해 공유되는 것들이 이미지 Dockerhub에서 pull하면 이미지를 받아올 수 있고, push하면 이미지를 버전 관리하여 올릴 수 있음 Dockerfile에 적어놓은 대로 이미지를 생성/빌드(Dockerfile : 이미지 제작 레시피) 컨테이너 이미지를 실행시킨 상태, VM와 동일 당연히 컨테이너 상에서 작업한 내용은 이미지랑 상관이 없음 Dockerfile, docker-compose.yml 내용 정리Dockerfile12FROM ubuntu:20.04 =&gt; 새로운 이미지의 기반이 될 이미지(base 이미지)ENTRYPOINT [&quot;echo&quot;, &quot;hello&quot;] =&gt; 컨테이너를 시작할 때 실행할 명령어 Dockerfile로 이미지 빌드12$ docker build --tag myimage:1.0 . # 현재 디렉토리(Dockerfile 있는)에 myimage라는 이름으로 도커 이미지를 생성/빌드$ docker images # 내 컴퓨터에 갖고 있는(어디서 받아왔거나 내가 만들었거나) 이미지 목록 출력 생성된 이미지로 컨테이너 생성, 실행12345678910111213$ docker create &amp; docker start # 이미지로부터 컨테이너 생성 &amp; 컨테이너 시작 == run$ docker run --rm myimage:1.0 # run 명령어는 이미지를 기반으로 컨테이너를 생성 후 실행하는 명령어, --rm : 컨테이너 종료될 때 컨테이너 자동 삭제$ docker run -d --name web -p 8080:80 -e MYSQL_PASS=root nginx:latest # -d : 백그라운드 실행, --name : 컨테이너 이름 지정, -e : 환경변수 전달$ docker container ls # 실행중인 컨테이너 목록$ docker ps # 실행중인 컨테이너 목록$ docker ps -a # 모든 컨테이너 목록(실행 중 아니어도)$ docker stop web(or ID) # 컨테이너 실행 중지$ docker rm web # 컨테이너 삭제$ docker exec -it web /bin/bash # 실행 중인 컨테이너에 bash로 접속$ docker run -d --name web --rm \\&gt; --mount type=bind,src=/home/vagrant/html,dst=/usr/share/nginx/html \\ # mount : 로컬 디렉토리와 컨테이너 디렉토리를 연결&gt; -p 8080:80 \\&gt; nginx:latest Dockerfile 예제 - 212345678910#!/bin/sh# entrypoint.sh =&gt; 스프링 어플리케이션을 실행시키기 위한 스크립트ACTIVE_PROFILE=&quot;${PROFILE:-dev}&quot;echo &quot;ACTIVE_PROFILE=${ACTIVE_PROFILE}&quot;exec java -Djava.security.egd=file:/dev/./urandom \\ -Dspring.profiles.active=${ACTIVE_PROFILE} \\ -jar hello.jar 1234567891011FROM openjdk:8-jdk-alpine =&gt; 이미지를 받아와서RUN apk --no-cache add tzdata &amp;&amp; cp /usr/share/zoneinfo/Asia/Seoul /etc/localtime =&gt; 실행할 명령어 1(패키지 설치)WORKDIR /app =&gt; 작업 디렉토리 지정(없으면 새로 생성)COPY hello.jar hello.jar =&gt; Dockerfile 있는 디렉토리에 있는 파일을 이미지로 복사COPY entrypoint.sh run.sh =&gt; Dockerfile 있는 디렉토리에 있는 파일을 이미지로 복사 2(다른 이름으로 저장)RUN chmod 774 run.sh =&gt; 실행할 명령어 2(sh 파일 실행권한)ENV PROFILE=local =&gt; 이미지에서 사용할 환경변수 값 지정, 여기까지 이미지 빌드 내용ENTRYPOINT [&quot;./run.sh&quot;] =&gt; 이 이미지로 컨테이너를 생성할 때 실행할 명령어 12$ docker build --tag myspring:1.0 .$ docker run -rm -p 80:9090 myspring:1.0 =&gt; host 포트 : 컨테이터 포트 매칭 도커 볼륨 mount의 bind와 달리 도커에서 직접 관리하는 파일 시스템 여러 컨테이너에서 공유 가능 123456$ docker vulume create --driver local myvol # --drivder : 볼륨 생성시 사용할 스토리지 드라이버$ docker run -d --name web --rm \\&gt; --mount type=volume,src=myvol,dst=/usr/share/nginx/html \\ # 도커 볼륨과 컨테이너 디렉토리를 연결&gt; -p 8080:80 \\&gt; nginx:latest$ docker volume prune # 사용 중이지 않은 볼륨 모두 삭제 도커 네트워크1$ docker network ls # 도커가 제공 중인 네트워크 목록 docker-compose.yml 도커 명령어를 yml 파일로 관리해서 좀 더 간단하게 만들기 위해 사용(각종 옵션 너무 길어짐..) 특히 여러 도커 컨테이너끼리 연동시켜야 하는 경우(여러 컨테이너 사용하는 경우) 더 효과적임 1234567891011121314151617181920212223242526272829version: '3'volumes: postgres_data: {}services: db: image: postgres volumes: - postgres_data:/var/lib/postgres/data environment: - POSTGRES_DB=djangosample - POSTGRES_USER=sampleuser - POSTGRES_PASSWORD=samplesecret django: build: context: . dockerfile: ./compose/django/Dockerfile-dev volumes: - ./:/app/ command: [&quot;./manage.py&quot;, &quot;runserver&quot;, &quot;0:8000&quot;] environment: - DJANGO_DB_HOST=db depends_on: - db restart: always ports: - 8000:8000 docker-compose.yml로 하면 이렇게 간단한 것이 1234567891011121314151617# network 생성$ docker network create --driver bridge web-service# 해당 network를 활용하여 컨테이너 실행$ docker run --rm -d --name postgres \\ --network web-service \\ -e POSTGRES_DB=djangosample \\ -e POSTGRES_USER=sampleuser \\ -e POSTGRES_PASSWORD=samplesecret \\ postgres$ docker run -d --rm --name django1 \\ --network web-service \\ -p 8000:8000 \\ -e DJANGO_DB_HOST=db \\ --link postgres:db \\ django-sample 명령어로 일일이 구현하려면 이렇게 귀찮아진다. 123456$ docker compose up -d # (컨테이너들 실행)$ docker compose up --build # (이미지 빌드 후 실행)$ docker compose down # (컨테이너들 종료, 삭제)$ docker compose start # (정지했던 컨테이너 다시 시작)$ docker compose start postgres # (정지했던 컨테이너 다시 시작)$ docker compose restart # (이미 실행 중인 컨테이너 다시 시작) 도커 응용 체계 정리도커 스웜클러스트 환경에서 서비스 관리 1234567891011121314151617181920version: &quot;3.6&quot;services: # 서비스 목록 web: # 서비스 이름 image: madvirus/simplenode:0.1 ports: - &quot;5000:5000&quot; deploy: mode: replicated replicas: 2 # 2개로 복사 update_config: parallelism: 1 order: start-first delay: 10s failure_action: rollback healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:5000/health&quot;] interval: 10s timeout: 5s retries: 3 start_period: 10s 1$ docker stack deploy -c docker-compose.yml simple # simple_default 네트워크 생성, 서비스 생성(도커 스웜은 클러스트 기반으로 여러 컨테이너를 구동시키므로 네트워크 생성이 기본) paramikopython으로 ssh 접속 paramiko bash, zsh, 터미널 꾸미기쉘, bash, zsh콘솔 vs 터미널 vs 쉘 콘솔 : 서버의 로컬 장치에서 직접 명령어를 작성할 수 있는 입출력 장치(물리 장치 개념) 터미널 : 로컬 + 원격으로 접속할 수 있는 콘솔을 구현한 SW(SW 개념) 쉘 : 터미널과 사용자 사이에서 명령어를 입력받아 전달해주는 프로그램 =&gt; 우리가 직접적으로 만나는 친구! 쉘의 종류 sh : Stephan Bourne… csh : C Shell tcsh : /bin/tcsh zsh : /bin/zsh bash : /bin/bash 1$ echo $SHELL alias 명령어 설정 1$ alias ll='ls -alGh' oh-my-zsh zsh 꾸미기 위한 도구 SSH 키 관리SSH 키 개념 공개키 알고리즘 기반 공개키(pub) : 서버에 저장 ~/.ssh/authorized_keys에 추가 $ echo [public_key_string(cat id_rsa.pub)] &gt;&gt; ~/.ssh/authorized_keys 개인키(priv) : 클라이언트가 보관, 사용 SSH 키 쌍은 클라이언트가 자기 컴퓨터에서 생성 $ ssh-keygen id_rsa(개인키), id_rsa.pub(공개키) 키는 비밀번호랑 상관 없음!! SSH 키 생성, 저장, 활용 명령어123456789# 클라이언트(내 컴퓨터)에서 키 생성$ ssh-keygen...$ ls ~/.sshid_rsa id_rsa.pub # 키 생성 완료!# 서버에다 id_rsa.pub 파일 업로드하고 시작$ echo &quot;$(cat id_rsa.pub)&quot; &gt;&gt; ~/.ssh/authorized_keys$ done! Github 키 관리Personal Access TokenGithub Personal Access Token으로 로그인","link":"/2021/04/18/2022-04-25-til/"},{"title":"[개발] 앱 개발자 키 &amp; 앱 서명에 관하여","text":"앱 서명키 &amp; Signing어떤 개발자가 개발한 앱인지 인증하기 위한 방법으로, 개발자가 만들어놓은 앱 서명키를 활용해 앱에다가 서명을 하는 것이다.앱에 서명을 하여, 나중에 해당 앱에 대한 업데이트를 진행할 때 원본 앱 개발자의 업데이트가 맞는지 확인하기 위해 필수적이다. 안드로이드 디버그 키 해시 keytool -exportcert -alias androiddebugkey -keystore ./key.jks | openssl sha1 -binary | openssl base64 1. 안드로이드 안드로이드 앱은 구버전 방식과 신버전 방식(2019년 이후)으로 나뉜다. 차이점은 앱 번들(.aab)이 공식 배포 포맷으로 변경되면서 발생한 것으로, APK가 압축파일 형태의 앱이라면 AAB는 기기마다 최적화된 APK 생성을 위한 번들 파일이다. 이 방식으로 바뀌면서 서명 방식도 변경되었다. 구버전 앱 서명키 저장소는 서명키(비밀키)와 인증서(공개키)로 구성된다. 처음 키를 생성하면 서명키(비밀키)와 인증서(공개키) 쌍이 생성되는 것이다. 기본적인 서명 알고리즘과 동일하다. 12345671. 개발자는 서명키(비밀키)와 인증서(공개키) 쌍을 생성한다.2. 그 중 서명키(비밀키)로 앱에 서명한다.3. 플레이스토어에 인증서(공개키)를 업로드한다.4. 플레이스토어에 서명된 앱을 업로드한다.5. 플레이스토어에서는 인증서(공개키)로 서명된 앱을 검증한다.6. 업데이트가 생겼을 때 개발자는 역시 서명키(비밀키)로 앱에 서명한다.7. 플레이스토어에서는 예전에 올린 인증서(공개키)로 역시 서명된 앱을 검증한다. 이 방식은 개발자가 직접 서명키를 관리하는 방식이다. 키를 분실하면 다시는 해당 ID의 앱을 업데이트할 수 없다. 신버전(앱 서명 키 + 앱 업로드 키) 2021년부터 공식 방법으로 채택되었기 때문에 사실 이것만 알고 있으면 된다. 안드로이드 공식 문서에도 해당 내용을 먼저, 주로 설명하고 있다.기존 방식에서 앱 업로드 키 개념이 추가되었다. 12345671. 개발자는 서명키(비밀키)와 서명 인증서(공개키) 쌍을 생성한다.2. 플레이스토어에 서명키(비밀키)와 서명 인증서(공개키)를 업로드한다. =&gt; 관리는 이제 플레이스토어가 한다.3. 개발자는 업로드키(비밀키)와 업로드 인증서(공개키) 쌍을 생성한다.4. 플레이스토어에 업로드 인증서(공개키)를 업로드한다.5. 앱 번들에 업로드키(비밀키)로 서명한다.6. 플레이스토어에 서명된 앱 번들을 올린다.7. 플레이스토어는 서명키(비밀키)로 앱에 서명하여 유저에게 배포한다. 안드로이드 개발자가 생성하는 키는 .jks 또는 .keystore 확장자를 갖는다.안드로이드 스튜디오로 생성하면 .jks 파일이 생성되며, keytool로 생성하면 .keystore 파일이 생성되는 것이다.이 파일들은 앱 서명 키가 담긴 파일로, 나중에 배포할 때 이 키 파일을 활용해 앱에 서명을 하면 된다. 안드로이드 스튜디오 활용 키 생성(.jks)keytool 활용 키 생성(.keystore)=&gt; keystore 비밀번호와 key alias 비밀번호가 같으면 에러 발생 2. iOSiOS 키체인 생성https://eunjin3786.tistory.com/295","link":"/2022/01/03/2022-01-03-app-key-social/"},{"title":"[오늘의 플러터] 소셜 로그인(Google, Kakao)을 Firebase 없이 구현해보자","text":"소셜 로그인 및 인증 기본 개념Firebase VS 백엔드(REST API 서버)소셜 로그인 구현하기https://debaeloper.tistory.com/68 Google Kakao","link":"/2022/01/03/2022-01-04-flutter-social-login/"},{"title":"리액트 프로젝트 기본 이해 및 설치","text":"Hello World!","link":"/2022/12/14/2022-12-14-react-drf/"},{"title":"[회고록] 19에서 20으로 - 1) 시작하며, 동아리 DevKor","text":"확실히 회고록을 쓰지 않으면 일년이라는 긴 시간을 기억해놓기에는 어려운 것 같아요. 그리고 이렇게라도 한 해를 돌아보면서 나는 과연 시작했을 때보다 많이 발전했는가, 그때의 그 마음 그대로 잘 살아왔는가를 돌아보고 반성하면서 다시금 동기부여를 받을 수 있는 좋은 활동인 것 같습니다. 요새 개발자 문화로 회고록 쓰고 공유하는게 유행이라지만 꼭 개발자가 아니더라도 각자의 한 해를 정리하는 기회가 있으면 좋겠습니다. 작년 회고로부터올해 회고를 위해 작년 회고를 읽어봤습니다..! 항상 금방 훅 지나갔다고 생각했는데 이렇게 한게 많았었나 싶기도 하더라구요. 요것저것 많이 했었는데 가장 기억에 남았던 문장은 게으르게 살지 말자는 것이였어요. 작년은 긴 휴식기가 잦아서 그랬나 싶기도 하고 뭔가 게으름을 최대한 이겨보자는게 올해 목표가 되었었는데 괜히 벌써 못 지킨 것 같아 두렵네요ㅠㅠ 한 번 올해는 어땠나 살펴보겠습니다. 학과 개발 동아리 DevKor 창립 (2018.12 ~ 2019.12)올 한 해 했던 가장 뿌듯한 일은 학과 내에 개발 동아리를 만든 것이었습니다! 작년 회고에 들어갔어야 하는 내용이지만 역시 게으름 때문에^^; 학과 자체가 개발보다는 보안 분야에 많이 강점을 두고 있다보니 저는 학부 1~2학년 때부터 개발 공부를 함에 있어 학과와 관련된 많은 것을 포기했어야 했습니다. 당연히 지원도 많이 받지 못했습니다. 그러다보니 학과에 개발 동아리를 만들어 개발 쪽에 관심 있는 학우들을 도와주고, 개발을 안 해본 친구들도 개발의 참 재미를 느낄 수 있도록 하면 좋겠다는 선한 생각과, 그래도 졸업 전에 뭐 하나 남기고 가야하지 않겠나 하는 속물적인 마음으로 학과 개발 동아리 DevKor를 만들게 되었습니다! 개발 동아리에서 참 여러가지 활동을 했었는데요, 몇 가지 기억에 남는 것만 정리해보면 다음과 같아요. 정기 세미나 개최 (2018.12 ~ 2019.12)동아리에서의 개발 스터디는 크게 두 종류였는데, 하나는 매주 2시간으로 끝내는 가벼운 정기 세미나와 분야별로 모여서 공부하고 개발하는 스터디였습니다. 제가 맡았던 스터디는 제가 게을러서 계획대로 잘 굴러가지 못했었고, 대신 매주 진행했던 정기 세미나는 나름 잘 진행되었었습니다. 정기 세미나를 하면서 제가 얻을 수 있던 경험과 교훈이 몇 가지 있는데, 라이브 코딩하면서 강의하기는 정말 어렵다사실 발표나 강의는 경험도 꽤 있고 자신 있다고 생각했는데 라이브 코딩으로 세미나를 진행하다보니 정말 어렵더라구요. 코드를 다 외워서 쓸 정도로 잘 알고 있어야 원활하게 진행이 되는데, 그 정도로 열심히 준비하지도 않았고 최근에 공부한 내용들을 발표하는 것이다보니 더더욱 어려웠습니다. 물론 여러 차례 하면서 요령도 생기긴 했지만 라이브 코딩이 포함되는 강의는 정말 열심히 준비해야겠다는 걸 느꼈습니다. 나는 그동안 강의 준비에 성실하지 못했다제가 일반 과외를 1년 정도, 프로그래밍 과외를 2년 정도 했었는데 생각해보면 강의 준비랄게 거의 없었던 것 같아요. 대충 다 알고 있는 내용이고, 준비하는데 드는 시간은 시급으로 안쳐주니까 아깝다는 생각이 든거죠. 그래도 과외는 충분히 커버할 수 있었는데, 비슷한 레벨의 학생들에게 세미나를 진행하는 것은 꽤 어려웠습니다. 항상 제가 생각해보지 않은 분야의 질문이 나오고, 이런 거는 대충 넘어가자 하고 넘어갔던 것들에서 항상 질문과 문제가 발생했었습니다. 이 때 저는 누군가에게 지식을 알려줄 때는 절대 대충하는 마음을 가지면 안되겠구나 라는 교훈을 얻었습니다. 그래도 뿌듯하다!그래도 동아리 부원들이 많이 와주고, 좋은 반응을 보여주며 열심히, 성실하게 따라 오는 것을 보면 괜히 뿌듯하고 그랬습니다ㅎㅎ 어찌 되었든 지식을 알려주고 그로 인해 성장하는 모습을 보는 것은 참 뿌듯한 일입니다. 해커톤 2번 개최 (2019.06, 2019.12)개발 동아리를 만들며 꼭 하고 싶던 활동 중 하나는 동아리 내부 해커톤이었습니다. 그래서 열심히 준비하고 진행했었는데, 1회 해커톤인 1학기 때의 해커톤은 거의 90%의 내용을 혼자 준비했었습니다. 해커톤에 나가본 경험은 많았지만 동아리 행사를 진행하는 것은 처음이었기 때문에 좀 막막했는데 그래도 돌이켜보면 꽤 잘 준비했던 것 같습니다. 이후에 나가본 몇몇 대회들에서 내가 꽤 준비랑 운영을 잘 했었구나 라는 생각이 들기도 했답니다. 공간을 빌리고 포스터를 만들어 홍보하고, 굿즈도 만들면서 각종 식사나 간식, 이벤트 등을 전부 준비하고 기획하는게 쉽지 않았지만 정말 재밌어서 스스로 할 수 있었던 활동들이었어요. 실제로 다른 동아리 친구들과 함께 운영진을 꾸려 진행해도 되었지만 1회 대회 때는 준비 과정이 너무 재밌어서 혼자 다 했었습니다! 2회 대회 때는 운영진을 꾸려서 진행했는데 여럿이서 진행하면서 얻는 편함과 불편함이 공존했었던 것 같아요. 2회 대회 상세 페이지 무엇보다 가장 기억에 남는 것은 동아리 부원들의 실력이 성장했음을 볼 수 있던 것과 동아리의 틀이 잡혀가고 있었다는 것이었습니다. 1학기에 열었던 1회 대회 때는 개발을 시작한지 3~6개월 되는 부원들이 뭐라도 만드려고 노력했었습니다. 다들 그때만 해도 기본적인 실수나 고민, 에러에 부딪혀 고생했었는데, 2학기에 열린 2회 대회 때는 다들 성장하여 정말 다양하고 창의적이며 기술력도 꽤 높은 결과물을 내놓더라구요. 다들 스스로 공부를 열심히 한 덕분이지만 **개발 동아리를 만들지 않았더라면 이 중에 절반은 아직 개발을 안해보지 않았을까**라는 생각이 들면서 동아리에 대한 뿌듯함을 느낄 수 있었습니다. 이제 저는 졸업을 하고 동아리를 남기고 가겠지만, 이 동아리가 학과의 역사와 함께 했으면 좋겠습니다. 이후의 친구들이 저보다 더 잘 운영해줄 거라 믿습니다:)","link":"/2019/12/26/remember2019-1/"},{"title":"[회고록] 19에서 20으로 - 2) 외주, 보이저엑스","text":"회고가 생각보다 할게 많아서 총 4편으로 나눴습니다..! 지난번은 동아리 창단과 관련된 내용이었다면 이번에는 개발 업무 부분의 회고를 정리해보겠습니다. 올해 했던 업무는 외주와 보이저엑스 인턴이었습니다. 외주 진행 (2019.03 ~ 2019. 12)사실 외주는 작년에도 열심히 했었습니다! 예전에도 회고에서 말했었지만 외주에 대한 어느정도의 선망과, 일이 익숙해지다보니 꽤 편하게 할 수 있었거든요. 그래서 올해에는 Django + Crawling 분야의 외주를 한 4~5건 정도 진행했습니다. 그래도 외주는 힘들었어요. 왜 해도해도 힘든지는 모르겠지만 항상 새로운 방식의 스트레스가 주어집니다^^ 1학기 때 했던 웹 개발 외주는 클라이언트의 요청이 너무 갑질스러웠고, 1학기가 끝나갈 때 쯤 했던 외주는 꼭 술마시고 접대하는 기분이 들어 차단하고 더 이상 진행하지 않았습니다. 그리고 작년부터 진행했던 단골 클라이언트가 있으신데, 바쁘다는 이유로 한동안 작업을 진행하지 않다가 다시 진행 도와드리면서 유지보수를 쭉 해드리고 있습니다. 이렇게 외주를 많이 해왔는데, 좋은 점도 꽤 있었던 것 같아요. 적어도 실력을 아주 빠르게 늘릴 수 있다는 것과 나름 괜찮은 알바라는 장점이 있는데, 당연히 남의 돈을 받아서 진행하는 것이다보니 그에 따르는 책임감과 부담이 꽤 크게 느껴졌습니다. 그래서 한동안 또 쉬면서 성장하고, 이후 들어오는 요청에 대해서도 물불 안가리고 달려들었던 예전과 달리 거절할 수 있는 능력도 생겼습니다. 외주를 하면서 주로 다뤘던 기술들인 Django, Selenium, BeautifulSoup에 대해 숙련도가 생기고 익숙해졌습니다. 그래서 기능을 만들고 구현하는 것은 꽤 빨라졌고, 이제와서 생각해본 가장 큰 수확은 좋은 코드에 대한 고민이었습니다. 초반의 외주에서는 전혀 신경쓰지 못했고, 연말이 되어서야 비로소 조금 고민할 수 있었는데 이는 단순한 반복 작업이 많아졌기 때문이었습니다. 특히 웹 크롤링은 더더욱 비슷한 코드가 많아 이런 부분들을 리팩토링하고, 주석으로 범위를 묶고, 어떻게든 재사용성을 높이는 코드 작성을 위해 고민했었습니다. 내년에도 좀 더 고민하면서 개발하면 좋겠습니다. 외주에 관하여 후배들에게 팁을 주기 위해 동아리에서 세미나를 한 적이 있는데, 해당 자료를 공유합니다! 좀 민망하지만 그래도 도움이 될 거라 믿습니다:) 외주 세미나 자료 보이저 엑스 인턴 (2019.07 ~ 2019.09)외주만 하다보니 체계적으로 일을 하지 못한다는 생각이 들었어요. 혼자 일하는 외주이다보니 빠른 결과가 훨씬 중요하고 좋은 코드와 절차는 신경 쓸 수가 없었죠. 이와 별개로 인턴이 꼭 하고 싶었습니다. 입대 전에 회사를 꼭 경험해보고 싶었던 이유가 제일 컸고, 학교에서 전공 학점으로 인정도 해주기 때문에 더욱 하고 싶었습니다. 술마시고 접대하는 기분이 들었던 외주 클라이언트가 인턴 형태로 제공하겠다고 했지만 엎어졌으니.. 제 상황에서 인턴을 구하는 것은 정말정말 어려웠습니다. 우선 군대를 다녀오지 않았고, 학교를 휴학할 수 없었기 때문에 방학기간에만 일을 하거나 학교를 다니면서는 주 3~4일 정도를 근무해야 했죠. 이런 조건을 맞춰주는 회사가 정말 없었고, 그 와중에 딱 한 군데, 보이저엑스를 알게 되었습니다. 보이저엑스를 다니며 작성한 출근 일기는 블로그에 작성해두었으니 전반적인 소감만 간단히 말해보자면, 우선 제가 의도했던 목적인 회사를 경험해보자는 것은 정확히 성취했던 것 같아요. 애초에 회사를 다녀본 적이 없었기도 하고, 보이저엑스도 충분히 독특한 문화의 회사라고 생각이 되어 대부분의 회사가 이렇다고 할 수는 없겠지만 어쨌든 아주 기본적인 소프트웨어/서비스 회사의 문화를 경험할 수 있었습니다. 다만 이제와서 생각해보니 아쉬운 부분은 혼자 프로젝트를 맡아 진행하다보니 개발 실력 면에서 늘었다고 하기는 좀 힘들다는 것..? 사수가 있는 큰 팀에서 일을 했다면 얻을 수 있는 장점이었겠죠:) 하지만 당시에는 같이 일하는 게 좀 무섭기도 했고 뭔가 신경 쓰는 것이나 부담 없이 혼자 자유롭게 일하고 싶다는 생각이 더 강했기 때문에 그랬으니 딱히 후회되지는 않습니다! 보이저엑스의 문화 중 특이했던 부분은 자유로운 영역과 비자유로운 부분의 조화? 였는데 간단히 말하면 회사의 여러가지 복지를 즐기는 것부터 업무를 진행하는 과정에서 이렇게나 자유로워도 될까 싶을 정도로 많은 자유가 주어졌습니다. 자유가 너무 커서 수반되는 책임도 크지 않을까 싶었지만 또 그렇지는 않았어요. 이런 와중에도 중요한 결정이 들어가는 부분 등에서는 나름의 절차가 있어서 다니는데 큰 불편함 없었습니다. 저는 회사에서 Flutter로 모바일 앱 서비스를 개발했습니다. 아예 처음 만드는 것은 아니었고, 이전에 개발하시던 분들이 남겨 놓고 가신 프로젝트를 이어받았고, 혼자 맡다보니 모바일 앱 서비스와 관련된 작업 뿐만 아니라 백엔드의 코드를 수정하거나, AWS 쪽을 살피는 업무, 심지어 고객 대응 및 유치까지 맡아서 진행했었습니다. 일을 하면서 보고해야하는 것도 딱히 없었다보니 조금은 외롭기도 했는데, 그래도 담당 디자이너 분한테 방금 뭘 만들었다 이런 식으로 보여주면서 외로움이 좀 해소되지 않았나 싶습니다ㅎㅎ","link":"/2019/12/30/remember2019-2/"},{"title":"[회고록] 19에서 20으로 - 4) 마치며: 19살에서 20살","text":"회고록이 이렇게 길어지게 될 줄은 몰랐습니다..! 개발 동아리를 만들고, 외주랑 인턴을 하고, 여러 대회를 나가는 중에 가장 시간을 많이 쏟았던 부분은 진로에 대한 고민이었습니다. 4학년이 되었고 이제 정말 졸업만 남은 상황에서 어떠한 고민들을 했는지 자세히 다 얘기할 수는 없겠지만 간단히 정리해보았습니다. 또한 생활 면에서 나를 어떻게 관리하면 좋을지 고민한 내용도 함께 적고 2020년 4월 입대 전까지 무엇을 어떻게 하며 지낼지 신년 계획 비슷하게 적으면서 회고록을 마무리하겠습니다. 그냥 갑자기 대전 다녀오기(2019.03)동아리 활동을 하면서 생각보다 여유로운 방학을 보내다 3월에 개강을 했어요. 개강하고 지나다 동기를 통해서 외주를 맡아 진행하게 되었는데, 그러던 와중 갑자기 떠나고 싶다는 생각이 들어 노트북 들고 대전에 갔어요. 대전에는 마침 가장 친한 친구가 학교를 다니고 있어서 친구도 볼겸 다녀왔습니다:) 친구를 만나고 여러 밀린 이야기를 할 수 있었어요. 각자 바쁘게 살고 있다보니 얘기할 기회가 많지 않았는데 밀린 얘기를 다 할 수 있어 좋은 기회였습니다. 비슷한 진로를 걷고 있는 친구여서 대부분 일과 관련된 얘기였는데, 간단히 제 입장에서 느낀 점을 정리해보면 이렇습니다. 예전에는 딥러닝 등을 공부 안하면 안될 것 같았고 지금도 그렇지만 아직은 서비스 개발이 훨씬 재미있어 그쪽으로 쭉 공부하고 있다. 좋은 개발자가 되는 것도 의미있는 길일 것 같다. 친구는 창업을 하면서 지내고 있는데, 그만큼 몰두해서 일을 할 수 있는게 참 멋있다고 느꼈다. 뭔가 적당한 배수의 진이 쳐져 있어야 비로소 제대로 일을 하게 되는 걸까? 나처럼 가벼운 마음으로 시작해서는 아무것도 되지 않겠구나. 친구는 언제나 나보다 많이 앞서 있었다. 그리고 같은 진로를 갖게 되면서 그에 대한 질투나 부러움을 가졌었는데, 그래봤자 내게 동기부여 될 것은 아무것도 없었다. 친구에게는 친구만의 시간과 노력, 길이 있고 나에게도 나만의 시간과 노력, 길이 있을 것이다. 언제나 이런 진지한 고민을 하게 만드는 친구여서 참 좋습니다:) 무튼 이런 갑작스러운 대전 여행에서 외주를 성공적으로 잘 마무리하고 올라왔고, 또다시 살짝 휴식을 갖고 인턴을 알아보며 지냈습니다. 인턴을 하면서 마주한 결단의 시간(2019.07 ~ 2019.11)보이저엑스 인턴을 하며 느낀 점은 2편에서 적어두었지만, 이와는 살짝 별개로 개인적인 진로 고민 또한 하게 된 계기가 있었습니다. 원래는 출석체크를 안하는 교양을 넣어두고 회사에 출근하려 했는데, 갑자기 교수님이 출석을 부르겠다고 하신 것이죠..! 계속 빠지면 F를 맞을 것이고, 그러면 졸업이 안되고, 그러면 임관을 못하는 상황 속에서 병특 등을 구해서 병역을 해결하고 개발자로 취업하는 진로가 그려진 것이죠. 하지만 회사를 그만두면 학교를 무사히 마치고 안정적으로 임관을 하여 7년간 복무를 하며 비교적 개발과는 거리가 먼 보안과 관련된 업무를 하게 되는 것이었습니다. 단순히 보면 회사를 그만둘까 말까의 고민이었지만, 하나의 결정이 꽤나 큰 진로의 방향을 결정할 것이라고 생각하여 꽤나 고민되었답니다. 영 집중도 안되어 반차 쓰고 집에도 다녀오고, 여러가지로 고민을 해봤는데 간단히 정리해보면 이럴거 같아요. 순수한 기술자의 의미로서 개발자가 된다면, 나는 잘 할 수 있을까? 언제나 깊이 있는 공부나 연구를 싫어하고, 좀만 막히면 해결해보려 하기 보단 회피하는 습관이 강한 나인데, 그런 퓨어한 개발자가 되는 길이 잘 맞을까? 그런 의미로서 개발자가 되지 않겠다면 창업이나 좀 더 위험하지만 다양한 길을 선택할 수 있는데, 안정적인 길을 버리고 갈 만큼 내가 명확하게 바라보고 나를 던질 수 있는 길이 있을까? 7년의 복무가 많이 안정적임과 동시에 내가 가려던 길과는 전혀 먼 보안의 길인데 시간낭비가 되진 않을까? 복무를 하면서 파트타임 대학원을 진행하지 않으면 상당히 손해를 보게 되는데, 마찬가지로 내가 대학원에 가면 잘 맞을까? 참 많은 부분의 고민을 하면서 꽤 오래 고민을 했는데, 제가 내린 결론은 다음과 같았어요. 나에게는 아직 내가 이루어낸 안정적인 길을 버리고 달려갈만큼 간절하고 명확한 길이 없다. 적어도 그런 길을 찾는 시간을 여유롭게 갖기 위해서 대학원을 포함한 안정적인 길에 올라보자. 만약 그정도로 간절한 길을 찾아낸다면 주저 없이 대학원을 그만두고 내가 하려는 것을 하면서 살아보자. 이런 결론을 내리면서 동시에 꿈이라는 것에 대해서도 다시 정의를 해보았어요. 예전에는 30살 전에 100억 벌기라는 꿈이었는데, 이미 글렀고ㅎㅎ.. 무엇보다 창업을 대하는 자세가 달라졌기 때문에 다른 꿈을 가져보기로 했어요. 그러던 중 자신의 이름이 곧 가치가 되는 사람들을 바라보면서 이런 꿈을 갖게 되었습니다. 내 이름이 브랜드가 되는 사람이 되기 위해 평생을 살아보자. 이 꿈을 갖게 됨으로 저는 평생을 나침반처럼 따라갈 수 있는 지표가 생겼어요. 그러다보니 아주 지엽적인 행동과 활동들에 결과를 욕심내지 않게 되었고, 그저 그런 하나의 활동들을 꾸준히 기록하고 어떤 형태로든 쌓아 놓는 것이 꿈을 따라가는 길이라고 생각하게 되었습니다. 지난 대학생활 4년 동안의 고민 중 가장 큰 의미의 고민을 해냈던 것 같아요. 입대 전까지 할 것들앞서 말한 꿈을 위해서 저는 제가 가진 장점인 발표, 설명, 강의, 그리고 얕지만 넓은 지식을 활용해서 최대한 많은 컨텐츠를 남겨놓고 4월에 입대하려 합니다. 컨텐츠들로 발생하는 수익은 문제 없기도 하고(ㅎㅎ) 제가 지향하는 꿈에는 저를 표현할 수 있는 다양한 컨텐츠가 필요하기 때문이에요. 그래서 4월 전까지 목표하고 있는 일들은 다음과 같아요. 지극히 주관적으로 설명하는 프로그래밍 시작하기 강의 만들기 Flutter 클론 코딩 강의 만들기 Django REST Framework 강의 만들기 Flutter 기반의 앱 서비스 3개 배포해놓기 내심 이렇게 적어놓긴 했지만 걱정이 됩니다. 언제나 목표만 크게 잡아놓고 다 못할 것 같아서ㅠ 그렇지만 남들이 입대 전 여행을 다녀오면서 경험을 쌓는 것을 대신하여, 저는 내 이름의 가치를 찾는 여행을 떠난다고 생각하고 후회없이 다녀오려 합니다:) 뭐 사실 말은 이렇게 해도 위의 것들 중에 절반만 해도 뿌듯할 것 같긴 해요ㅋㅋㅋㅋ 회고를 마치며, 19살에서 20살로2019년에서 2020년으로 넘어가는 순간입니다. 사실 해가 바뀌는 것에 큰 의미를 갖지 못했었는데, 딱 19살에서 20살 될 때가 유일하게 기억에 남아요. 미성년자에서 법적 성인이 되었다는 것에서 무언가 해방감과 자유를 느꼈었거든요. 제 두번째 19살은 대학생활을 마치고 사회로 나아가야 하는 4학년 말, 즉 지금인 것 같아요. 아직은 미성년자 학생처럼 아는 것도 없고 막연히 나아가야 한다는 사실이 무섭기만 해요. 두번째 20살인 사회로의 진출은 이제는 다시 19살로 돌아갈 수 없을 거라고 경고하는 것 같아요. 그래도 다행인 점은 무엇을 고민하면서 살아야 할지도 몰랐던 첫번째 19살과는 달리, 충분한 고민을 하고 방향을 잡은, 꽤 멋지게 준비된 19살이라는 것이에요. 그래서 조금은 두번째 스무살이 기대가 되기도 합니다. 20살이 되어 19살 때의 자신을 되돌아볼 때 내가 많이 성장했구나라고 느끼듯, 사회를 경험하고 이제는 진지하게 평생을 고민하며 살던 제가 다시 이 글을 쓰고 있는 순간을 되돌아 볼 때 제가 많이 성장했다고 느낄 수 있으면 좋겠습니다.","link":"/2019/12/30/remember2019-4/"},{"title":"[회고록] 플러터 개발자의 2020년 돌아보기","text":"어느덧 벌써 2020년이 지나고 회고록을 또 쓰게 되었네요. 유독 올 한해는 시간이 참 빨리 지나갔던 것 같습니다. 회고록을 쓰다보면 글이 항상 길어지는데, 이번에는 개발 관련 활동, 배웠던 것, 앞으로의 목표를 위주로 간단하게 작성해볼까 합니다. 강의훈련소 들어가기 전에 뭐라도 남기고 가보자는 마음으로 플러터 영상 강의를 제작했습니다. 나름 인프런이나 유데미에서 강의를 많이 구매해보고 들어본 수강생 입장에서 어떤 강의가 완강할만한 좋은 강의일지 생각해보고 기준을 만들어 보았습니다. 클론코딩 방식의 강의가 프레임워크를 빠르게 배워 프로젝트에 적용하고 싶은 사람들에게 제일 좋다. 자막이 있으면 강의자의 전달력이 몇 배 늘어난다. 강의는 최대한 빠르고 컴팩트하게 진행해야 집중력이 올라간다. 코드는 일시정지하고 입력할 수 있다. 이런 나름의 기준으로 강의를 만들어보았고, 강의를 제작하는 프로세스는 다음과 같았습니다. 클론코딩 프로젝트를 미리 개발해보고 코드를 정리한다. 미리 개발해둔 프로젝트를 다른 화면에 띄워놓고 보면서 강의를 녹화한다. (화면녹화: QuickTime Player, 마이크: 맥북내장) Vrew를 사용해 녹화한 영상에 자막을 달며 음성이 없는 구간(코드 입력하는 구간)을 자르는 등의 편집을 한다. 이렇다보니 개발 시간의 두배 정도가 온전히 촬영과 편집에 들어갔습니다. 그나마 Vrew 덕분에 자막을 정말 쉽게 달았지만, 전문적 지식이 있는 편집자가 도와준다면 정말 편하겠다는 생각이 들었습니다. 첫 강의는 [무작정 플러터] Flutter+Firebase로 넷플릭스 클론코딩하기 였고 (@guinness의 로고 협찬),첫 강의 만들고 기분이 너무 좋아 바로 진행한 두번째 강의는 [무작정 풀스택] 플러터와 장고로 1시간만에 퀴즈앱/서버 만들기 였습니다. 각각 3월 24일, 4월 6일에 공개하였는데 12월 19일인 현재 수강생이 인프런에서 1985명, 2167명이네요. 무료로 공개한 강의인 점을 감안하여도 개인적으로 기대 이상의 관심과 사랑을 받은 것 같아 많이 놀랍고 뿌듯했고, 감사했습니다. 강의 하나 만들 때 2~3주 정도는 매일 새벽 내내 강의를 만든 만큼 참 집중하여 진행했던 것 같습니다. 이제 직장이 생겨 그런 라이프패턴으로 살 수 없지만 언젠가 휴가를 길게 쓰고 새로운 강의를 만들어볼까 하는 생각을 항상 갖고 있습니다. 개발자가 강의를 만들면 가장 큰 장점이 바로 자기 PR이라고 느꼈습니다. 실제로 강의를 올려 정말 많은 관심과 칭찬을 받으며 지내는 동안, 많은 작업 제안 연락을 받을 수 있었습니다. 너무나 유명한 온라인 강의 플랫폼에서 컨텐츠 제작 요청을 받기도 했고, 사업 제안이나 채용 관련 제안, 그리고 이어 출판 제안까지 제 역량 이상으로 좋은 일들을 많이 제안 받을 수 있었습니다. 여러 상황적 문제나 제 역량 부족으로 대부분의 제안은 거절했지만, 좋은 강의를 만들어 관심을 받으면 좋은 기회들이 많이 생긴다는 것에서 나름 자신감도 얻을 수 있었습니다. 집필학부생일 때에도 한 번 제안을 받았다가 결국 그만둔 적이 있는데, 책을 쓴다는 참 정적이고 꾸준함을 요하는 활동이 왜 그렇게 매력적으로 보이는 지 모르겠습니다. 제 성격과 참 맞지 않는 것 같은데 말이에요.. 금방 질리고 힘이 빠지는 타입이다보니 쉽사리 도전하기 어려웠습니다. 블로그 글도 꾸준히 못 쓰고 있으니 말입니다. 그래도 강의 활동과 블로그 활동을 통해 제안 받은 내용 중, 좋은 출판사의 좋은 편집자님을 만나 나름 본격적으로 책 쓰기에 도전했습니다. 현재도 진행 중이고, Django &amp; Django Rest Framework을 주제로 쓰고 있는데 뭔가 꾸준히 쓰는 건 제 스타일과 안맞는 것 같고 날 잡고 며칠 내내 집중해서 큰 챕터를 완성시키는 방식이 잘 맞겠다 싶었습니다. 목표는 21년 2~3월 내에 탈고를 하는 건데 꼭 그렇게 되었으면 좋겠습니다. 개발앞선 강의 활동이나 집필 활동은 이미 알고 있는 내용을 정리하고 가공하여 전달하는 활동입니다. 그러다보니 개인적으로 성장이 멈춘다는 느낌이 들었고, 결과적으로 좋은 기회를 만들어주는 활동이라 아주 큰 의미가 있지만 내 개발 실력에 큰 도움은 안된다고 생각했습니다. 결국 계속 공부하고 성장해야 한다고, 특히 이제 막 학부를 졸업한 제게는 더욱 성장이 중요하다고 느꼈습니다. 그래서 꾸준히 낯선 부분을 건드리려 하고 있습니다. 8~9월부터 그렇게 생각하고 지냈는데 직장을 다니게 되고 출퇴근의 늪에 빠지다보니 진도가 많이 나가진 않았던 것 같네요. 그래도 Provider를 어느정도 편하게 쓸 수 있게 되고, 플러터 웹을 조금 더 웹스럽게 만드는 방법을 알게 되고 이외 자잘한 내용들을 공부할 수 있었습니다. 매일 퇴근 후 @guinness와 구글 미팅을 키고 1시간 반 정도 개발 공부나 프로젝트를 하는데 이 시간이 없다면 분명 퇴근하고 누워있다 잠드는 하루들이 반복되지 않았을까 싶습니다. 앞으로도 매일 잘 부탁드립니다:) 직장직장은 소프트웨어 개발을 직접적으로 다루는 곳이 아닙니다. 그러다보니 처음에는 아쉬운 마음이 많이 들었는데, 성격도 좋고 실력도 너무 좋은 선배님들을 만나 제가 그동안 피해왔던 분야를 공부할 수 있게 되었습니다. 지금이야 개발이 제일 좋고 개발 관련 진로로 나아가고 싶지만, 좋은 직장에 개발자로 취업하기가 인생의 목표가 아닌 만큼 여러 분야를 경험하고 배우는 것은 참 중요하고 유익한 시간이라 생각하고 있습니다. 2020년을 마치며많은 분들에게 참 힘든 한 해였습니다. 제게 2020년은 새로운 환경과 경험으로 가득 찬 해였던 것 같습니다. 해보기 전에는 두려움도 참 많고 걱정이 정말 많았는데, 지나고 보니 어찌저찌 다 흘러가서 평화로운 상태가 되었네요. 당분간은 이 평화를 조금 누리면서 포트폴리오 페이지, 앱 서비스 런칭도 꼭 하고 컨텐츠 제작도 급하지 않게 조금씩 진행해볼까 합니다. 다들 한 해 동안 정말 고생 많으셨습니다!","link":"/2020/12/18/remember2020/"},{"title":"[회고록] 19에서 20으로 - 3) 다양한 대회들","text":"2019년을 나타내는 4가지 주제 중 이번에는 참가했었던 여러 해커톤, 공모전에 대해 정리해보겠습니다. 대회는 전반적으로 결과가 안타까웠네요ㅠㅠ 저는 해커톤을 참 좋아합니다. 원체 게으른 성격이다보니 이렇게 딱 한정적인 기간이 있어야 효율 좋게 일을 할 수 있는 것 같아요. 또한 대회 자체가 개발자스러워서 개발뽕 같은게 차오르기도 하고, 그러다보니 살짝 쳐져있던 개발 의욕을 불태울 수 있게 만들 수 있어 저는 가끔씩 동기부여가 필요할 때마다 대회를 신청해버립니다. 고려대학교 메이커스페이스 소확행 해커톤 (2019.01)이 대회는 고려대 내의 메이커스페이스(아두이노, 3D 프린터 등이 있는 작업 공간)을 활용하여 소확행을 위한 무언가를 만드는 해커톤이었습니다. 확실히 2019년은 소확행의 해였죠. 이 대회는 동아리 후배님들과 나갔는데, 아무래도 메이커스페이스를 활용해야 했다보니 하드웨어 활용이 필요했기 때문에 막 자유롭게 주제를 고르지는 못했어요. 저희는 아두이노와 안드로이드 앱을 활용하여 연예인 응원봉을 만들었습니다! 저는 앱 개발 쪽을 담당했는데, 예전 임산부를 위한 임산부석 서비스 HelpMom을 만들 때 안드로이드와 아두이노 통신 하는 것에 대해 앱을 만들어본 적이 있어서 상당히 쉽게 만들 수 있었습니다:) 부산 문화예술교육 해커톤 (2019.11)10개월만에 해커톤을 나갔습니다! 이전에는 외주하고, 인턴하다보니 해커톤 참여를 할 수 없었는데, 부산에서 열린다는 게 뭔가 여행 가는 것 같은 느낌이 들어 역시 동아리 후배님과 참여했습니다. 주제는 문화예술교육과 기술의 결합이라는 상당히 정부기관 스러운 주제였는데, 저희 주제는 Guinness의 도움으로 인문학 교육을 위한 글 읽고 쓰기 플랫폼 오늘의 세줄을 만들었습니다. 이 대회는 꽤 의미로웠는데 제게 가장 의미 있었던 이유는 완벽한 프론트엔드와 백엔드의 분리된 형태의 개발을 해냈다는 것이었습니다. 같이 간 후배님은 React.js, Vue.js 등 프론트엔드 쪽으로 잘 하던 분이었어서 이것저것 얕게 하는 제가 자연스레 백엔드 개발을 맡게 되었습니다. 저는 이러한 분업 구조에서는 REST 방식의 API Server를 백엔드에서 구성하면 좋겠다는 생각을 하고 Django Rest Framework로 API Server를 만들게 되었습니다! 초반에는 회원 인증, 로그인 부분에서 상당히 고전했는데, 이거는 언제 익숙해질 지 모르겠어요ㅠ 그리고 처음엔 Django Rest Framework 고유의 특징이 일반적인 Django와 달라서 이해하는데에도 꽤 시간을 쏟았죠. 하지만 한 번 이해하고 부터는 속도도 붙고 이해도 잘 되는 느낌이라서 기분 좋게 일할 수 있었습니다. 제가 해커톤을 많이 나가면서 형성된 해커톤을 대하는 방식은 잠을 무조건 챙겨 자는 것입니다. 예전에 대회에 나가서 밤 새면서 진짜 고생고생하고 발표했는데 상을 항상 못 타왔고, 그러면 늘 허탈한 마음이 너무 컸거든요. 그럴거면 차라리 해커톤의 맹점을 노려서 디자인과 아이디어, 발표에만 집중하고(그렇다기엔 항상 완성도에 집착하게 되지만) 잠을 꾸준히 챙겨가면서 최대한 덜 열심히 일해보자, 라는 생각을 갖게 되었어요. 물론 수상을 목표로 하지 않을 때에는 개발적 완성도에만 집중하고 디자인이나 아이디어 등에는 크게 비중을 두지 않는 경우도 있었고 본 대회는 그런 쪽에 가까웠습니다. 그리고 잠을 꼭 챙겨가면서 잤다보니 아무래도 수상에 대한 기대도 적게 되었구요. 그런데 깜짝스럽게 입선을 하게 되어 200만원의 후속개발비를 받아 후속개발을 하게 되었습니다..! 연말에 이것 때문에도 살짝 바빴지만 그래도 더 대박이라고 생각하게 되었던 좋은 대회였습니다. 오늘의 세줄 서비스백엔드 레포 KBSC 소프트웨어 공모전 (2019.11)바로 이어서 Guinness와 함께 올해에도 KBSC 소프트웨어 공모전에 신청했습니다. 이번 주제는 안전한 강아지 입양 &amp; 분양 서비스 였습니다. 이번 대회에서도 완벽한 백엔드와 프론트엔드의 분리전략을 활용하기로 하고, 제가 이번엔 프론트엔드를 앱으로 맡으며 Flutter로 앱을 만들었습니다. Flutter는 회사에서도 경험했었고, 퇴사한 이후에도 혼자 계속 공부했었기 때문에 프레임워크에 대한 자신감이 좀 있었습니다! 그리고 실제로 엄청난 속도로..! 한 4~5일 만에 앱을 완성하여 상당히 뿌듯했습니다ㅎㅎ 항상 느끼지만 Guinness와는 일 하는 스타일이 잘 맞아서 그런지 참 편하고 좋습니다. 함께 일하는 동안 몇 번은 삐걱이기도 했지만 그래도 전반적으로 많은 배려를 받으며 일할 수 있어서 참 좋았습니다:) 아쉽게도 본선에 진출하지는 못했는데, 이를 통해 또 한 번 개발 완성도 집착에 대한 고민을 하게 되었고, 작년엔 운이 좋기도 했구나라는 생각이 들기도 했습니다. 역시 대회는 어려운 거 같아요ㅠㅠ 4~5일 밤을 거의 지새우며 개발을 했는데, 수상하지 못한 건 아쉬웠지만 그래도 개인적으로 개발 실력이 많이 늘었다고 느껴서 뿌듯했습니다! 주제도 좋아서 더 재밌게 일할 수 있었던 거 같구요:) 앱 프론트엔드 레포 고려대학교 하나와영 해커톤 (2019.12)DevKor 해커톤이 끝난 다음주에 진행된 해커톤이었습니다. 이번 주제 역시 소확행이었는데, 처음엔 흔하디 흔한 주제들을 생각하다가 예전에 개발했던 Ekisu가 생각나 이를 개선하기로 결심합니다! 마침 같이 대회를 나간 후배님이 딥러닝 쪽으로 개발하던 친구여서 딥러닝 모델 GPT2를 활용해 요약과 글 자동 생성을 구현하기로 하였습니다. 그래서 모델 쪽은 개발할 게 없었고, 후배님과는 웹을 만들었는데 둘 다 얕은 풀스택 개발자였어서 각자 대충 나눠 하다가 서로 막히는 거 있으면 옮겨서 일하는, 상당히 자유로운 방식으로 협업했습니다. 개인적으로 Git Branch와 익숙하지 않아 몇 번 충돌을 냈는데, 이것 외에는 큰 문제 없이 개발을 마칠 수 있었습니다! 발표 때에도 다른 팀들이 생각보다 기본적인 느낌의 결과물을 보여줬거나 살짝 미흡한 발표를 보여줬기도 했고, 저희의 발표에서 호응이 가장 컸었기 때문에 압도적인 1위 수상을 내심 기대하고 있었지만 입상 조차 하지 못하면서 나름의 충격을 받았습니다ㅠ 심사조건에서 창의성과 주제적합성이 대부분의 비중이었고 완성도가 아주 낮았기 때문이었는지 주제가 재밌는 팀들이 부족한 완성도로 수상했습니다. 그래서 더욱 허탈했는데, 뭐 심사조건과 안맞았으니 어쩔 수 없죠ㅎㅎ.. 개발 완성도의 비중이 낮은 대회라는 점이 제일 큰 아쉬움을 남기네요. 프로젝트 레포","link":"/2019/12/30/remember2019-3/"},{"title":"[회고록] 책을 쓰며 도를 닦았던 개발자의 2021년","text":"2020년에 했던 주요 활동은 (입대 전) 플러터 영상 강의 제작, 책 집필 시작, 본격적인 개발 공부 시작 등이 있었습니다. 그리고 올해 2021년에 계획했던 것은 포트폴리오 페이지, 앱 서비스 런칭, 컨텐츠 제작이었습니다. 항상 회고를 쓰면 나름 계획을 세우기도 하는데 정작 그 계획은 2021년이 끝날 때쯤 회고를 쓰기 위해 처음 보게 되었네요.. 당초 계획과는 꽤 거리가 먼 활동들을 했는데, 하나씩 간단히 정리해보겠습니다. 집필역시나 예상대로 집필은 어려운 일이었습니다. 창의력을 필요로 하는 작업은 아니었지만 쓰기 귀찮다는 마음과 와중에 성에 안차는 퀄리티 때문에 마감이 많이 늦어졌습니다. 중간중간 출판사의 사정으로 연기된 적도 있었습니다. 그리고 최초 계획했던 분량보다 부족하여 더 쓰게 되는 일이 생겨 결국 얼마전에 마감할 수 있게 되었습니다. 확실히 처음 집필하는 것이다보니 많이 부족하다고 느꼈습니다. 아쉽다는 생각을 할 때쯤 플러터 책을 집필하자는 연락을 받았습니다. 플러터는 DRF보다 훨씬 자신감 있었고, 강의를 제작했던 적도 있으며 나름 짧지만 실무 경험도 있기 때문에 더 잘 쓸 수 있겠다는 생각을 하고 시작했습니다. 역시 마찬가지로 인고의 시간이었지만 훨씬 빠른 기간 내에 마감할 수 있었습니다. 첫 집필을 하며 배운 노하우를 활용하여 나름 원활하게 원고를 쓸 수 있었고 덕분에 아이러니하게도 첫 집필 원고보다 먼저 출간이 될 것 같습니다,, 책을 쓰면서 가장 힘들었던 것은 내가 잘 쓰고 있는게 맞나라는 생각이었습니다. 경험이 부족하고 그보다 실력이 더 부족한 제게 집필이라는 기회가 주어지며 너무 기쁘게 시작했었는데, 생각보다 힘든 부분이 많았습니다. 역시 책을 쓰기엔 부족한 사람이었구나 싶었고 그럼에도 좋은 글을 쓰고 싶다는 생각에 몇번을 지우고 썼습니다. 결국 마지막 쯤에는 힘이 풀려 조금 대충 마감한 부분이 없지 않습니다. 여기서 배웠던 것은 내가 만난 책 집필이 무조건 잡아야 했던 기회가 아닌 선택할 수 있는 하나의 일이었다는 것입니다. 선택한 이후의 책임은 온전히 제게 있었고, 아직 내가 그 일을 할 수 있는 능력이 없다면 거절할 수 있다는 것도 배울 수 있었습니다. 어쨌든 책은 모두 마감했고, 이제 어찌되든 2022년 내에는 세상으로 나올 것입니다. 결과를 빨리 볼 수 있는 작업도 아니고 뭔가 성장하고 있다는 생각이 들지 않아 더 힘들기도 했는데, 인고의 시간을 겪은 결과물이 세상으로 나온다면 정말 뿌듯할 것 같습니다. 사이드 프로젝트 개발@열음님과 뭔가 하나 만들어서 꼭 배포를 하자!는 생각으로 기계식 키보드 관련 앱 서비스 개발을 시작했었습니다. 대략 6월 말쯤 시작했는데 책 집필 때문에 시간을 많이 쓰지 못해 아직 완성은 못했습니다. 이제 앞으로 1~2달이면 배포까지 이뤄지지 않을까 싶습니다. 플러터로 개발을 했고 BloC 패턴 및 아키텍처를 도입해 상태 관리와 프로젝트 구조를 잡았습니다. 아무래도 배운게 많고 삽질한 것도 많다보니 자세한 개발 후기는 따로 작성해서 올려보겠습니다. 1일 1커밋(feat. Commit Driven Development)올해 여름쯤 부터 시작했던 하나의 습관은 1일 1커밋입니다. 퇴근 후 피곤한 상태로 일을 하려니 쉽지 않고 그저 눕게 되었습니다,, 그래서 뭔가 강제할 수 있는 습관을 만들어보자고 생각한게 1일 1커밋이었습니다. 커밋을 해야한다는 마음 때문에 앉아서 일을 하게 되고, 하다보니 좀 더 해야지 하는 마음 덕분에 생각했던 것보다 더 많이 일을 할 수 있게 되어 좋았습니다. 또 커밋 규칙에 대해서도 생각하면서 좀 더 체계적인 방법으로 커밋을 할 수 있게 되었습니다. 나름 지금까지 계속 이어지고 있는 습관이고 올해에도 쭉 이어서 진행해볼 계획입니다. 대신 단점은 점점 시간이 갈수록 커밋을 위한 커밋이 늘고 있다는건데, 그렇게라도 일을 하는 건 괜찮다고 생각합니다. 아직은 괜찮은거 같은데, 좀 더 심해지면 다른 방법을 생각해봐야 하지 않을까 싶습니다. 보안직장에서는 보안 쪽 일을 하고 있습니다. 개발을 정말 하고 싶지만 상황상 어쩔 수 없이 보안 쪽 일과 공부를 하고 있는데, 운좋게 2달간 보안 공부를 할 수 있는 교육 기회를 얻었습니다. 덕분에 보안 분야로 공부를 많이 할 수 있었는데, 가장 재밌었던 건 CTF 스타일의 문제를 푸는 것이었습니다. 교육 단계에서 푼 문제들이다보니 난이도가 쉬운 편이었지만 문제를 푸는 재미와 희열을 느낄 수 있었습니다. 팀끼리 모여서 모의 해킹 CTF를 할 때 남들은 하나도 풀지 못한 문제를 푼다는 그 기분은 이루 말할 수 없는 흥분이었습니다. 이것만으로 보안 분야로 전향하기엔 개발이 너무 좋지만, 그래도 보안 공부를 계속하는 것도 재밌겠다는 생각과 개발 분야에도 도움될 수 있겠다는 생각을 할 수 있었습니다. 2022년은 iOS 개발자로플러터를 그래도 1~2년 가량 공부하고 활용하면서 이제 어느정도 제품을 개발할 수 있는 수준까지 성장한 것 같습니다. 개인적인 마음으로 플러터는 이정도면 충분한 것 같고, 이제든 다른 쪽으로 테크를 정해야겠다는 생각이 들었습니다. 플러터는 아무래도 계속 공부하기엔 시장에서 수요가 충분하지 않은 것 같습니다. 그래서 플러터와 관련하여 이후 진행할 방향을 고민했는데, 앱 개발 분야를 계속 하려면 네이티브 개발을 꼭 해야할 것 같다는 생각이 들어 iOS 개발을 공부해야겠다고 결정했습니다. iOS는 네이티브 개발인만큼 플러터보다 자료도 훨씬 많고 이미 정해진 정답도 있는 분야인 것 같습니다. 그래서 최대한 정석대로 공부해보려 합니다. iOS 개발자로 전직하면서 어느정도 기본기를 쌓은 다음, 개발 동아리 등 대외활동을 하며 활동 영역을 넓혀보려 합니다. 코로나라는 핑계로 미뤄왔던 대외활동을 이제는 할 때가 되지 않았나 싶고 사람들을 만나며 내가 어느정도인지 확인하는 것도 좋은 기회인 것 같습니다. 그와 동시에 지금은 주변에 보안 전공자들밖에 없는데, 개발자들도 많이 알아가면 막연히 좋을 것 같다는 생각이 들었습니다. 2021년도 어느새 흘렀습니다. 혼자 있는 시간이 많았다보니 생각도 많아지고 쓸데없는 고민도 많이 했었습니다. 내년부터는 잡생각을 없애고, 조금은 미래를 보지 않더라도 당장 공부하는 것에 집중하여 여유있게 보내려 합니다. 올해도 고생 많으셨고, 내년도 우리 모두 파이팅입니다!","link":"/2021/12/30/remember2021/"},{"title":"[회고록] 2022년","text":"2022년은 여러가지로 기억에 남을만한 한 해일 것 같습니다. 무엇 하나 예상대로 흘러간 것이 없고, 무엇 하나 바라던 일이 된 적도 없습니다. 의지와 상관 없이 흘러가던 시간 속에서 예상치 못한 보상도 있었으나, 잃은 것이 더 많았다는 생각이 이따금 들었던 해였습니다. 작년에 개발 차원에서 목표했던 일은 iOS 개발이었고, 이에 대한 활동으로 개발 동아리를 하려 했지만 근처에도 가보지 않았습니다. 대신 많은 것들이 그 시간을 채웠으니, 그 채워진 시간에 대해 이야기하며 2022년을 정리해보겠습니다. 집필 그 이후작년까지 원고 집필을 마무리 했었고 올해 5월 드디어 제 이름이 적힌 책 두 권이 세상에 공개되었습니다. 아직까지 두려움에 리뷰는 보지 않고 있습니다. 집필할 때에는 그저 완성만 하고 싶다는 생각이 가득 차 있었는데, 모두 출판되고 나니 조금 더 완성도 있게 열심히 쓸 수 없었나 하는 아쉬움만 남습니다. 일이 끝난 후에 남는 것은 힘들었던 감정이 아닌 결과라고 하던데, 역시 맞는 것 같습니다. 결과만 간단히 자랑해보자면, 2022년 교보문고 IT 서적 TOP 200위 안에 두 권 모두 들어왔으며, Django 책은 현재 2쇄를 준비 중에 있습니다. React 관련 내용을 보강하여 넣게 될 예정입니다. Flutter 책은 실적에 관하여 연락받은 내용이 없어, 조만간 연락을 취해보려 합니다. 부족한 실력으로 집필한 책이 생각보다 더 많은 관심을 받게 되어 감사했고, 주변 분들도 많이 알아봐주시고, 책을 드리진 못할 망정 사오셔서 싸인을 요청하심에 부끄럽고 감사했습니다. 책 덕분에 강의 관련 요청도 몇 번 들어왔는데, 거의 모든 요청을 시간 관계상 거절하게 되어 아쉽고 죄송했습니다. 기술 특성상 몇 년이 지나도 관심받는 책이 되진 못하겠습니다. 그래도 소중했던 기회와 경험을 기억하고, 앞으로 나아가는데 있어 큰 도움이 될 것이라고 생각합니다. 갑자기 분위기 해외 출장?!책 집필이 끝났으니 다시 개발 공부를 하려 했습니다. 진행하던 프로젝트도 있었고, iOS 개발자가 되고자 했던 목표도 있었으니 나름 나아갈 길은 명확했습니다. 그러던 와중 직장의 부름을 받아 3차례의 대외 활동에 참여할 수 있게 되었습니다. 4월엔 원격 연결을 통한 국제 활동이었고, 5월엔 네덜란드, 10월엔 미국에 있었습니다. 또한 이를 준비하기 위해 모여서 연구하고 공부하는 과정을 각 1~2달씩 가졌습니다. 이 활동들이 2022년을 크게 좌우했습니다. 준비 기간을 포함하여 대략 6개월 이상을 이 활동들에 쏟게 되었고, 직장에서 하는 일이 보안 관련 업무이다보니 개발보단 보안을 공부한 시간이 한 해의 절반 이상이었던 것입니다. 물론 직장 내에서 누구나 잡게 되는 기회도 아니고, 정말 소중했던 경험과 기회였지만 어쨌거나 가려던 길이 아닌 다른 길을 오래 걷게 되다보니 생각이 많아졌습니다. 그렇지만 시간을 돌린다 해도 꼭 다시 하고 싶은, 내년에도 하고 싶을만큼 배운 것도 많고 뜻깊은 기회였습니다. 팀 내에서 맡은 역할은 웹 관련된 취약점을 찾고 보안 패치를 적용하거나 코드를 수정하여 취약점을 제거하고, 위협을 방지하는 일을 맡았습니다. 과정 속에서 웹 해킹 공부를 많이 할 수 있었고, 덕분에 드림핵 문제도 정말 많이 풀어봤습니다. 또한 정적 분석 도구도 써보게 되었으며, Rule-base로 취약점을 빠르게 찾아 제거하는 방법을 배웠습니다. 하지만 실전에서는 취약점을 제대로 찾지 못해서 많은 어려움을 겪어 폐를 끼치기도 했지만, 훌륭한 선배들 덕분에 오히려 대표적인 취약점들과 이에 대한 방어법, 그리고 다양한 기술들을 배울 수 있었습니다. 또한 한번에 많은 시스템 자원을 대상으로 명령을 실행시킬 수 있는 자동화 도구들을 많이 알게 되었고, 이를 대시보드화 하여 관리하는, 어떤 경지에 이른 개발 결과물을 만나볼 수 있었습니다. 이를 혼자 개발한 선배를 롤 모델로 삼아 내년에 또 나가게 된다면 해당 서비스를 구현하고 유지보수하는 일을 맡고 싶습니다. 이런 분야의 일을 직장 내에서 할 수 있으면 좋겠다고 생각했습니다. 직장 내에서 원래 하던 개발 분야와 아무 상관 없는 일을 하고 있어 아쉽던 찰나 외부 활동들을 하며 다양한 개발 소요와 공부 기회를 느낄 수 있었습니다. 또한 개발과 보안 모두 잘하는 멋진 선배를 만났기 때문에 앞으로 나아가고 싶은 방향도 어느정도 알게된 기회였습니다. 여행도 못가는 와중 해외 출장을 두번이나 나갔던 것도 참 행복했습니다:) 고요했던 호수에 운석이 떨어지다앞선 출장들을 다녀오고 개발과 보안이 접목된 일을 하면 정말 재밌겠다고 생각했습니다. 지루한 직장 생활에 활력을 기대했고, 마침 이런 일을 하는 부서를 잘 알고 있었기 때문에 그곳으로의 이동을 희망했습니다. 스스로도 100% 이동할 수 있을 것이라 생각했는데, 모종의 이유로 실패했습니다. 이때 큰 충격을 받았고, 또 한번 당연하게 기대하지 말자는 것을 상기했습니다. 앞으로의 커리어를 쌓는 방향에서 그리고 있던 그림이 있었는데, 보이지 않게 되어 막막했습니다. 6월, 지인들은 모두 알만한 개인적인 큰 사건이 발생했습니다. 당황스럽고 갑작스러웠지만, 사실 나도 모르게 조용히 한 걸음씩 다가오고 있던 시간이었나봅니다. 스무살이 되고 나서부터 항상 안정적이고 예상 가능한 삶을 살던 제게 많은 변수와 문제들이 생겨났습니다. 핑계 삼아 개발은 아예 손을 놓고 술도 정말 많이 마셨네요. 5년 동안 마신 양보다 6월 이후 마신 양이 더 많았습니다. 흘러 넘치는 시간과 불안정한 감정을 주체할 수 없었다고 생각합니다. (아마 술을 자주 마셔서 그렇게 나왔겠지만) 처음으로 건강검진에서 우울증 의심도 나왔어요. 이 시간들을 조금 더 건강히 보낼 수 있었겠지만, 그러지 못하고 다양한 사건 사고들을 겪으면서 심적으로 힘든 시간을 겪으며 방황했습니다. 지금은 거의 다 회복했다고 생각하지만, 아직은 잘 모르겠네요. 클라이밍과 친구들6월 이후 회복을 위해 했던 여러 일들 중 가장 생산적이고, 도움이 됐고, 행복했던 활동은 클라이밍이었습니다. 6월 이전까진 집 밖으로 나가는 시간은 일주일에 한 번 정도 있었고, 퇴근 후에는 더더욱 없었습니다. 그러던 중 직장 내 주변 분들이 클라이밍을 많이 한다는 얘기를 들었고, 같이 가자고 몇 번 제안을 해주셨었지만 집돌이는 절대 가지 않았죠. 6월 이후에는 거의 모든 제안을 받으면서 놀던 시기이기에, 흔쾌히 가자고 했습니다. 그리고 너무 재밌었죠. 처음에는 사람들과 같이 운동하러 가서 친해지고 뒷풀이에서 함께 노는 것에 즐거움을 느꼈지만 이제는 클라이밍 자체가 재밌어서 혼자서도 자주 가고, 일주일에 3번 이상은 가고 있습니다. 여러모로 부족한 몸이라 남들보단 실력이 많이 느리게 늘고 있지만, 그래도 예전에 비해 계속 늘고 있다는게 느껴져서 뿌듯하고 기분이 좋습니다. 특히 함께 하는 동료들과 정말 많이 친해진 것이 가장 큰 수확이었습니다. 스무살 이후로 단체 활동도 아예 안해왔고 만나는 친구들만 만나다보니 이렇게 젊게(?) 놀지 않았었는데, 재밌고 좋은 분들과 자주 놀러 다녀 참 즐거웠습니다. 일주일에 두번 이상 함께 클라이밍을 하고, 직장에서 만나면 스몰토크도 하고, 일상을 가득 채우고 있습니다. 여름엔 같이 계곡도 놀러 갔었습니다. 대학때도 안가던 MT를 이렇게 가니 참 재밌었네요.. 내년에도, 그리고 앞으로도 계속 함께 많은 시간을 보낼 수 있으면 좋겠습니다:) Recovery, 그저 살아가기회고를 쓰며 이 시기를 어떻게 표현할까 고민하다 문득 즐겨 듣던 앨범이 생각났습니다. Eminem의 Recovery라는 앨범인데, 힘든 시간을 겪고 회복을 해왔다는 주제의 앨범입니다. Eminem의 복귀 앨범이기도 하죠. 하반기의 생활을 그렇게 표현할 수 있을 것 같습니다. 3~4개월 정도 많은 방황과 어려움을 겪었고, 점차 회복 중입니다. 11월부터 자취를 시작했습니다. 자취에 적응할 겸, 또한 회복할 겸 그저 하루하루 살아가는 것에 집중하고 있습니다. 공부나 커리어, 성장은 잠시 멈추었습니다. 처음엔 걱정이 많이 됐고 금방 회복해서 시작해야겠다고 생각했었지만 이내 금방 마음을 접었습니다. 지금의 저는 그럴 상태가 아니라는 것을 알았고, 운동과 식사, 청소와 요리 등 건강하고 멋지게 살기 위해 노력하는게 지금은 더 중요한 것 같습니다. 그저 이렇게 살아가는 것이 지금까지 회복에 많은 도움을 주었습니다. 조금은 앞으로 나아갈 힘을 얻게 되었을지도 모르겠습니다. 다시 일어나기이제 쉴만큼 쉬었으니, 또 마침 해가 바뀌었으니 다시 일어나야겠죠. 앞으로 나아갈 방향을 고민해봤습니다. 23년에는 웹을 주로 할 것이고, 프론트는 React, Next.js + Typescript로, 백엔드는 DRF, Flask + Python, DB를 공부하려 합니다. 대부분 얕게 해봤던 내용들이라 금방 시작하고 잘 할 수 있을 것입니다. 과정 속에서 DevOps, 빌드 및 배포 등 관련 부가 내용 공부할 것입니다. 가능하면 이를 공부하는 과정에서 대외활동을 하나 해보고, 풀스택 프로젝트를 최소 2개 배포해보는 것이 목표입니다. 내년 크리스마스를 위한 프로젝트를 꼭 하나 개발 해봅시다. 매년 다짐하는데 금방 까먹네요.. 1일 1커밋을 부활시켜볼까 싶은데, 1월 1일이 모든 시작의 타이밍인만큼 한번 다시 해볼까 합니다. 또 올해 나갔던 출장들이 내년에도 있을 겁니다. 제가 갈 수 있다는 보장도 없지만 만약 가게 된다면, 그래도 한번 해봤던 활동이니 부담없이 참여하면서 앞서 직접 설정한 목표들을 달성하는데 집중하려 합니다. 22년은 정말 힘들었습니다. 중심이 많이 흔들렸죠. 내가 이렇게 약한 사람이구나 깨닫게 되었습니다. 23년은 흔들리지 않기 위해,첫번째, 내 감정에 솔직해지고 빠르게 그 감정을 인정하자. 두번째, 내가 어쩔 수 없는 일들은 흘러가게 두고, 내가 제어할 수 있는 시간은 하고 싶은 것들로 가득 채우자.라는 다짐을 세워보았습니다. 다시 일어나보겠습니다. 화이팅.","link":"/2022/12/29/remember2022/"}],"tags":[{"name":"think","slug":"think","link":"/tags/think/"},{"name":"taebbong","slug":"taebbong","link":"/tags/taebbong/"},{"name":"startup","slug":"startup","link":"/tags/startup/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"target","slug":"target","link":"/tags/target/"},{"name":"development","slug":"development","link":"/tags/development/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"State","slug":"State","link":"/tags/State/"},{"name":"setState","slug":"setState","link":"/tags/setState/"},{"name":"Provider","slug":"Provider","link":"/tags/Provider/"},{"name":"BloC","slug":"BloC","link":"/tags/BloC/"},{"name":"상태관리","slug":"상태관리","link":"/tags/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"server","slug":"server","link":"/tags/server/"},{"name":"ml","slug":"ml","link":"/tags/ml/"},{"name":"machine","slug":"machine","link":"/tags/machine/"},{"name":"learning","slug":"learning","link":"/tags/learning/"},{"name":"in","slug":"in","link":"/tags/in/"},{"name":"action","slug":"action","link":"/tags/action/"},{"name":"knn","slug":"knn","link":"/tags/knn/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"mlia","slug":"mlia","link":"/tags/mlia/"},{"name":"jekyll","slug":"jekyll","link":"/tags/jekyll/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"page","slug":"page","link":"/tags/page/"},{"name":"theme","slug":"theme","link":"/tags/theme/"},{"name":"picasso","slug":"picasso","link":"/tags/picasso/"},{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"work","slug":"work","link":"/tags/work/"},{"name":"lifestyle","slug":"lifestyle","link":"/tags/lifestyle/"},{"name":"about","slug":"about","link":"/tags/about/"},{"name":"TaeBbong","slug":"TaeBbong","link":"/tags/TaeBbong/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"MAC","slug":"MAC","link":"/tags/MAC/"},{"name":"자바","slug":"자바","link":"/tags/%EC%9E%90%EB%B0%94/"},{"name":"맥","slug":"맥","link":"/tags/%EB%A7%A5/"},{"name":"실행","slug":"실행","link":"/tags/%EC%8B%A4%ED%96%89/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"bash","slug":"bash","link":"/tags/bash/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"2018","slug":"2018","link":"/tags/2018/"},{"name":"remember","slug":"remember","link":"/tags/remember/"},{"name":"alone","slug":"alone","link":"/tags/alone/"},{"name":"together","slug":"together","link":"/tags/together/"},{"name":"MYSQL","slug":"MYSQL","link":"/tags/MYSQL/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"lecture","slug":"lecture","link":"/tags/lecture/"},{"name":"crawling","slug":"crawling","link":"/tags/crawling/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"bs4","slug":"bs4","link":"/tags/bs4/"},{"name":"requests","slug":"requests","link":"/tags/requests/"},{"name":"session","slug":"session","link":"/tags/session/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"네모","slug":"네모","link":"/tags/%EB%84%A4%EB%AA%A8/"},{"name":"파이썬","slug":"파이썬","link":"/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"장고","slug":"장고","link":"/tags/%EC%9E%A5%EA%B3%A0/"},{"name":"scrapy","slug":"scrapy","link":"/tags/scrapy/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"voyagerx","slug":"voyagerx","link":"/tags/voyagerx/"},{"name":"intern","slug":"intern","link":"/tags/intern/"},{"name":"Selenium","slug":"Selenium","link":"/tags/Selenium/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"Chromedriver","slug":"Chromedriver","link":"/tags/Chromedriver/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"drf","slug":"drf","link":"/tags/drf/"},{"name":"keyboard","slug":"keyboard","link":"/tags/keyboard/"},{"name":"키보드","slug":"키보드","link":"/tags/%ED%82%A4%EB%B3%B4%EB%93%9C/"},{"name":"개발자","slug":"개발자","link":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"기계식키보드","slug":"기계식키보드","link":"/tags/%EA%B8%B0%EA%B3%84%EC%8B%9D%ED%82%A4%EB%B3%B4%EB%93%9C/"},{"name":"강의","slug":"강의","link":"/tags/%EA%B0%95%EC%9D%98/"},{"name":"Django Rest Framework","slug":"Django-Rest-Framework","link":"/tags/Django-Rest-Framework/"}],"categories":[{"name":"개발","slug":"개발","link":"/categories/%EA%B0%9C%EB%B0%9C/"},{"name":"생활","slug":"생활","link":"/categories/%EC%83%9D%ED%99%9C/"},{"name":"강의자료","slug":"개발/강의자료","link":"/categories/%EA%B0%9C%EB%B0%9C/%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/"},{"name":"Django Rest Framework","slug":"개발/Django-Rest-Framework","link":"/categories/%EA%B0%9C%EB%B0%9C/Django-Rest-Framework/"},{"name":"워킹 라이프","slug":"생활/워킹-라이프","link":"/categories/%EC%83%9D%ED%99%9C/%EC%9B%8C%ED%82%B9-%EB%9D%BC%EC%9D%B4%ED%94%84/"},{"name":"Flutter","slug":"개발/Flutter","link":"/categories/%EA%B0%9C%EB%B0%9C/Flutter/"},{"name":"Jekyll &amp; Hexo","slug":"개발/Jekyll-Hexo","link":"/categories/%EA%B0%9C%EB%B0%9C/Jekyll-Hexo/"},{"name":"일상","slug":"생활/일상","link":"/categories/%EC%83%9D%ED%99%9C/%EC%9D%BC%EC%83%81/"},{"name":"Node.js","slug":"개발/Node-js","link":"/categories/%EA%B0%9C%EB%B0%9C/Node-js/"},{"name":"Machine Learning","slug":"개발/Machine-Learning","link":"/categories/%EA%B0%9C%EB%B0%9C/Machine-Learning/"},{"name":"개발 Tip","slug":"개발/개발-Tip","link":"/categories/%EA%B0%9C%EB%B0%9C/%EA%B0%9C%EB%B0%9C-Tip/"},{"name":"회고","slug":"생활/회고","link":"/categories/%EC%83%9D%ED%99%9C/%ED%9A%8C%EA%B3%A0/"},{"name":"Web Scraping &amp; Crawling","slug":"개발/Web-Scraping-Crawling","link":"/categories/%EA%B0%9C%EB%B0%9C/Web-Scraping-Crawling/"},{"name":"AWS","slug":"개발/AWS","link":"/categories/%EA%B0%9C%EB%B0%9C/AWS/"},{"name":"강의","slug":"강의","link":"/categories/%EA%B0%95%EC%9D%98/"},{"name":"TIL&amp;TID","slug":"TIL-TID","link":"/categories/TIL-TID/"},{"name":"(무작정 플러터) 넷플릭스 클론 코딩","slug":"강의/무작정-플러터-넷플릭스-클론-코딩","link":"/categories/%EA%B0%95%EC%9D%98/%EB%AC%B4%EC%9E%91%EC%A0%95-%ED%94%8C%EB%9F%AC%ED%84%B0-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4-%ED%81%B4%EB%A1%A0-%EC%BD%94%EB%94%A9/"},{"name":"(무작정 풀스택) 플러터&#x2F;DRF 퀴즈앱","slug":"강의/무작정-풀스택-플러터-DRF-퀴즈앱","link":"/categories/%EA%B0%95%EC%9D%98/%EB%AC%B4%EC%9E%91%EC%A0%95-%ED%92%80%EC%8A%A4%ED%83%9D-%ED%94%8C%EB%9F%AC%ED%84%B0-DRF-%ED%80%B4%EC%A6%88%EC%95%B1/"},{"name":"Flutter","slug":"TIL-TID/Flutter","link":"/categories/TIL-TID/Flutter/"},{"name":"Security","slug":"TIL-TID/Security","link":"/categories/TIL-TID/Security/"},{"name":"React.js","slug":"개발/React-js","link":"/categories/%EA%B0%9C%EB%B0%9C/React-js/"}],"pages":[{"title":"all-tags","text":"","link":"/all-tags/index.html"},{"title":"About TaeBbong","text":"플러터와 장고를 좋아하는 개발자, 강의 제작자입니다:) 이력서 보기 : 노션 프로필 권태형 (KWON TAE HYUNG, TaeBbong) mok05289@korea.ac.kr facebook.com/taebbong github.com/TaeBbong 학력 한성과학고등학교 23기 졸업(2014.03 ~ 2016.02) 고려대학교 정보보호학부 졸업(2016.03 ~ 2020.02) 경력 정보올림피아드 공부, 수상 (2011.03 ~ 2014.09) 한성과학고등학교 알고리즘 동아리 ‘LuckI’ 창단 &amp; 회장 (2014.07 ~ 2016.02) 삼성 sds sGen Club 4기 개발자 과정 수료 (2014.07 ~ 2016.07) 소프트웨어 마에스트로 8기 멘티 과정 수료 (2017.08 ~ 2017.12) Draper University &amp; 소프트웨어 마에스트로 해외 연수 (2017.08 ~ 2017.12) 유튜브 데이터 분석 스타트업 ‘Picasso’ 공동 설립 (2017.12 ~ 2018.06) 고려대학교 정보보호학부 개발 동아리 DevKor 창단, 초대 회장 (2018.12 ~ 2020.02) 오투잡 크롤링 전문 프리랜서 활동, 상위랭킹 15위 (2018.12 ~ 2018.08) (주) 보이저엑스 인턴, Flutter 앱/백엔드 서버 유지보수 및 기능 추가 (2019.07 ~ 2019.10) 개인 프로젝트 포트폴리오 Youtube Data Crawler: 유튜브 채널별 세부 데이터 크롤링 엔진 Youtube Data API, Node.js 기반 비동기 방식의 유튜브 채널 세부 데이터 크롤링 엔진 제작을 총괄하였습니다. Red FAN, 빨간팬: 내 유튜브 채널 댓글 분석 도움 어플리케이션 2018 오픈소스 해커톤에서 유튜브 채널 댓글 분석 도움 안드로이드 어플리케이션 개발 프로젝트에서 크롤링 엔진 및 댓글 분석 알고리즘 제작을 하였습니다. Ekisu: 영어 본문 번역 &amp; 요약 웹/PC 서비스 Papago API(번역)과 TextRank 알고리즘(요약)을 활용하여 영어 본문을 번역하고 요약하는 서비스를 PC, 웹 플랫폼으로 구현했습니다. BlackBoard-Alarm: 고려대학교 블랙보드 공지/과제 알림 서비스 Python 기반 Selenium, BS4, Mysql, SMTP을 활용해 블랙보드 알림 서비스를 만들었습니다. Help Mom!: 임산부 배려석 이용 도움 서비스 임산부들만 임산부 배려석을 이용할 수 있도록 하는, 아두이노 + 안드로이드 기반 프로젝트로 KBSC 공모전에서 우수상을 수상했습니다. Send2Me: 카톡 나에게 보내기 스타일의 메모앱 카톡 나에게 보내기 기능을 메모 앱으로 가져와 카테고리 드래그&amp;드롭까지 구현한 플러터 기반 앱입니다. 전장으로!: 하스스톤 전장 랭킹 및 통계 제공 웹 하스스톤 전장에서 제공되지 않는 랭킹 및 승률과 같은 통계를 제공하는 웹 서비스이며, Vue.js로 만들었습니다. 강의 이력 탈잉 코드윙즈 Git &amp; GitHub 강의 고려대학교 개발동아리 DevKor 회장, 스터디 리더 고려대학교 의대 그룹 스터디 리더 초, 중, 고등학생 20여 명의 프로그래밍 강사 담당 인프런, 구름, 유튜브에서 플러터, 장고 강의 무작정플러터 - Flutter+Firebase 넷플릭스 클론코딩 무작정풀스택 - Flutter+Django 퀴즈앱/서버 만들기 기술 스택 Flutter, Django &amp; DRF, Crawling, Java, Javascript 감사합니다!","link":"/about/index.html"},{"title":"all-categories","text":"","link":"/all-categories/index.html"}]}